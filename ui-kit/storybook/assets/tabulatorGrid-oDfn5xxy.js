import{_ as z,j as h}from"./extends-CKwpSh1k.js";import{r as s,R as S}from"./index-CTjT7uj6.js";import{I as ye,a as D,M as Pe,O as Ee,S as Me}from"./helpersObjects-NFjaQN06.js";import{G as ge}from"./helpersString-BLksZHLM.js";import{m as Q}from"./updateModalTheme-B8SEZoH6.js";import{d as Le,M as He}from"./modalRender-DFQ6MC1H.js";import{I as we}from"./useIsDebugMode-B-VM_G4X.js";import{D as de}from"./dFormModal-SuHK0VWP.js";import{R as je,a as Ge,b as Oe,L as Be}from"./dForm-CJJOu6el.js";import"./index-DGqZ_Opy.js";import{B as ve,a as ze}from"./buttonsRow-C9xXyeYk.js";import{_ as Ne}from"./iframe-BKQpQZga.js";import{R as Ke}from"./EyeOutlined-YuvBWI2n.js";import{u as _e,T as We,S as Ye,f as Re,R as Ae,c as Ue,a as $e,b as Qe,C as Xe,d as Je}from"./iconUtil--KG9isdm.js";import{R as Ze}from"./DeleteOutlined-CnGtlBuB.js";import{I as N,C as Ce,c as Ve}from"./compact-item-B2r7eKHn.js";import{R as et}from"./MenuOutlined-DbxqBojV.js";import{T as tt}from"./tabulator-BDPdayTO.js";import"./dayjs.min-BljPK31Q.js";import{a as at,_ as X}from"./useToken-DuQNFAH6.js";import{i as nt}from"./motion-4S5rSXvC.js";var ot={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z"}}]},name:"folder-open",theme:"outlined"},lt=function(t,a){return s.createElement(N,z({},t,{ref:a,icon:ot}))},rt=s.forwardRef(lt),it={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z"}}]},name:"folder",theme:"outlined"},st=function(t,a){return s.createElement(N,z({},t,{ref:a,icon:it}))},qe=s.forwardRef(st),ut={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M300 276.5a56 56 0 1056-97 56 56 0 00-56 97zm0 284a56 56 0 1056-97 56 56 0 00-56 97zM640 228a56 56 0 10112 0 56 56 0 00-112 0zm0 284a56 56 0 10112 0 56 56 0 00-112 0zM300 844.5a56 56 0 1056-97 56 56 0 00-56 97zM640 796a56 56 0 10112 0 56 56 0 00-112 0z"}}]},name:"holder",theme:"outlined"},dt=function(t,a){return s.createElement(N,z({},t,{ref:a,icon:ut}))},ct=s.forwardRef(dt);const ce=4;function pt(e){const{dropPosition:t,dropLevelOffset:a,prefixCls:n,indent:o,direction:l="ltr"}=e,r=l==="ltr"?"left":"right",i=l==="ltr"?"right":"left",u={[r]:-a*o+ce,[i]:0};switch(t){case-1:u.top=-3;break;case 1:u.bottom=-3;break;default:u.bottom=-3,u[r]=o+ce;break}return S.createElement("div",{style:u,className:`${n}-drop-indicator`})}const Te=S.forwardRef((e,t)=>{var a;const{getPrefixCls:n,direction:o,virtual:l,tree:r}=S.useContext(Ce),{prefixCls:i,className:u,showIcon:d=!1,showLine:c,switcherIcon:p,blockNode:f=!1,children:y,checkable:g=!1,selectable:R=!0,draggable:q,motion:F,style:I}=e,w=n("tree",i),P=n(),b=F??Object.assign(Object.assign({},nt(P)),{motionAppear:!1}),M=Object.assign(Object.assign({},e),{checkable:g,selectable:R,showIcon:d,motion:b,blockNode:f,showLine:!!c,dropIndicatorRender:pt}),[_,k,C]=_e(w),[,V]=at(),H=V.paddingXS/2+(((a=V.Tree)===null||a===void 0?void 0:a.titleHeight)||V.controlHeightSM),E=S.useMemo(()=>{if(!q)return!1;let m={};switch(typeof q){case"function":m.nodeDraggable=q;break;case"object":m=Object.assign({},q);break}return m.icon!==!1&&(m.icon=m.icon||S.createElement(ct,null)),m},[q]),W=m=>S.createElement(Ye,{prefixCls:w,switcherIcon:p,treeNodeProps:m,showLine:c});return _(S.createElement(We,Object.assign({itemHeight:H,ref:t,virtual:l},M,{style:Object.assign(Object.assign({},r==null?void 0:r.style),I),prefixCls:w,className:Ve({[`${w}-icon-hide`]:!d,[`${w}-block-node`]:f,[`${w}-unselectable`]:!R,[`${w}-rtl`]:o==="rtl"},r==null?void 0:r.className,u,k,C),direction:o,checkable:g&&S.createElement("span",{className:`${w}-checkbox-inner`}),selectable:R,switcherIcon:W,draggable:E}),y))}),pe=0,Y=1,he=2;function oe(e,t,a){const{key:n,children:o}=a;function l(r){const i=r[n],u=r[o];t(i,r)!==!1&&oe(u||[],t,a)}e.forEach(l)}function ht(e){let{treeData:t,expandedKeys:a,startKey:n,endKey:o,fieldNames:l}=e;const r=[];let i=pe;if(n&&n===o)return[n];if(!n||!o)return[];function u(d){return d===n||d===o}return oe(t,d=>{if(i===he)return!1;if(u(d)){if(r.push(d),i===pe)i=Y;else if(i===Y)return i=he,!1}else i===Y&&r.push(d);return a.includes(d)},Re(l)),r}function A(e,t,a){const n=X(t),o=[];return oe(e,(l,r)=>{const i=n.indexOf(l);return i!==-1&&(o.push(r),n.splice(i,1)),!!n.length},Re(a)),o}var fe=function(e,t){var a={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,n=Object.getOwnPropertySymbols(e);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(e,n[o])&&(a[n[o]]=e[n[o]]);return a};function ft(e){const{isLeaf:t,expanded:a}=e;return t?s.createElement(Ae,null):a?s.createElement(rt,null):s.createElement(qe,null)}function me(e){let{treeData:t,children:a}=e;return t||Qe(a)}const mt=(e,t)=>{var{defaultExpandAll:a,defaultExpandParent:n,defaultExpandedKeys:o}=e,l=fe(e,["defaultExpandAll","defaultExpandParent","defaultExpandedKeys"]);const r=s.useRef(),i=s.useRef(),u=()=>{const{keyEntities:k}=Ue(me(l));let C;return a?C=Object.keys(k):n?C=$e(l.expandedKeys||o||[],k):C=l.expandedKeys||o||[],C},[d,c]=s.useState(l.selectedKeys||l.defaultSelectedKeys||[]),[p,f]=s.useState(()=>u());s.useEffect(()=>{"selectedKeys"in l&&c(l.selectedKeys)},[l.selectedKeys]),s.useEffect(()=>{"expandedKeys"in l&&f(l.expandedKeys)},[l.expandedKeys]);const y=(k,C)=>{var V;return"expandedKeys"in l||f(k),(V=l.onExpand)===null||V===void 0?void 0:V.call(l,k,C)},g=(k,C)=>{var V;const{multiple:H,fieldNames:E}=l,{node:W,nativeEvent:m}=C,{key:j=""}=W,G=me(l),O=Object.assign(Object.assign({},C),{selected:!0}),Ie=(m==null?void 0:m.ctrlKey)||(m==null?void 0:m.metaKey),Fe=m==null?void 0:m.shiftKey;let T;H&&Ie?(T=k,r.current=j,i.current=T,O.selectedNodes=A(G,T,E)):H&&Fe?(T=Array.from(new Set([].concat(X(i.current||[]),X(ht({treeData:G,expandedKeys:p,startKey:j,endKey:r.current,fieldNames:E}))))),O.selectedNodes=A(G,T,E)):(T=[j],r.current=j,i.current=T,O.selectedNodes=A(G,T,E)),(V=l.onSelect)===null||V===void 0||V.call(l,T,O),"selectedKeys"in l||c(T)},{getPrefixCls:R,direction:q}=s.useContext(Ce),{prefixCls:F,className:I,showIcon:w=!0,expandAction:P="click"}=l,b=fe(l,["prefixCls","className","showIcon","expandAction"]),M=R("tree",F),_=Ve(`${M}-directory`,{[`${M}-directory-rtl`]:q==="rtl"},I);return s.createElement(Te,Object.assign({icon:ft,ref:t,blockNode:!0},b,{showIcon:w,expandAction:P,prefixCls:M,className:_,expandedKeys:p,selectedKeys:d,onSelect:g,onExpand:y}))},bt=s.forwardRef(mt),le=Te;le.DirectoryTree=bt;le.TreeNode=Xe;var yt={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M880.1 154H143.9c-24.5 0-39.8 26.7-27.5 48L349 597.4V838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V597.4L907.7 202c12.2-21.3-3.1-48-27.6-48zM603.4 798H420.6V642h182.9v156zm9.6-236.6l-9.5 16.6h-183l-9.5-16.6L212.7 226h598.6L613 561.4z"}}]},name:"filter",theme:"outlined"},gt=function(t,a){return s.createElement(N,z({},t,{ref:a,icon:yt}))},wt=s.forwardRef(gt);const ke=(e,t,a)=>{if(!t)return;const n=e.gridProps;return e.setCurrentDataFetchHandler(t,a),(o,l,r)=>new Promise((i,u)=>{const d={...r,...a},c=t(d,e);if(typeof c>"u"&&i(U(n,{data:[]})),!ye(c)){D(c)?i(U(n,{data:c})):u(new Error);return}c.then(p=>{e.getIsMounted()&&i(U(n,p))},p=>{u(p)})})},U=(e,t)=>e.pagination||e.progressiveLoad?{data:t.data,last_page:t.last_page??1}:t.data;var vt=function(){var e=s.useRef(!1);return s.useEffect(function(){return e.current=!1,function(){e.current=!0}},[]),e};const Rt={view:"Просмотр",viewRecord:"Просмотреть запись",create:"Создать",createNewRecord:"Создать новую запись",edit:"Редактировать",editRecord:"Редактировать запись",clone:"Клонировать",cloneRecord:"Клонировать запись",delete:"Удалить",deleteRecord:"Удалить запись",select:"Выбрать",selectRecord:"Выбрать запись",go:"Перейти",filter:"Фильтр",exportXls:"Экспортировать в Excel",columnsSettings:"Настройки столбцов",columns:"Columns",ok:"ОК",cancel:"Отмена",reset:"Сбросить",noRows:"Строки отсутствуют",tryAgainQt:"Попробовать снова?",deleteSelectedRecordsQt:"Удалить выбранные строки?"},Ct={view:"View",viewRecord:"View record",create:"Create",createNewRecord:"Create record",edit:"Edit",editRecord:"Edit record",clone:"Clone",cloneRecord:"Clone record",delete:"Delete",deleteRecord:"Delete record(s)",select:"Select",selectRecord:"Select record(s)",go:"Go",filter:"Filter",exportXls:"Export to Excel",columnsSettings:"Columns settings",columns:"Columns",ok:"OK",cancel:"Cancel",reset:"Reset",noRows:"No rows",tryAgainQt:"Try again?",deleteSelectedRecordsQt:"Delete selected record(s)?"},Vt={view:"查看",viewRecord:"查看记录",create:"创建",createNewRecord:"创建记录",edit:"编辑",editRecord:"编辑记录",clone:"克隆",cloneRecord:"克隆记录",delete:"删除",deleteRecord:"删除记录",select:"选择",selectRecord:"选择记录",go:"执行",filter:"过滤",exportXls:"导出到Excel",columnsSettings:"列设置",columns:"列",ok:"确定",cancel:"取消",reset:"重置",noRows:"无行",tryAgainQt:"再试一次?",deleteSelectedRecordsQt:"删除选定的记录?"},B={ru:Rt,en:Ct,cn:Vt},v=e=>s.useCallback(t=>{const a=e.language??"en",o={...B[a]??B.en,...e.translation};return Object.prototype.hasOwnProperty.call(o,t)?o[t]:Object.prototype.hasOwnProperty.call(B.en,t)?B.en[t]:t},[e.language,e.translation]),J=({gridApi:e,props:t,tableRef:a,editFormApi:n,selectionFormApi:o,buttonsApi:l,setColumnsDialog:r})=>{const i=s.useRef(void 0),u=s.useRef(),d=s.useRef(),[c,p]=s.useState(!1),f=vt();return qt(i,t.dataSet),e.gridProps=t,e.tableApi=a.current,e.editFormApi=n,e.selectionFormApi=o,e.buttonsApi=l,e.getIsMounted=kt(f),e.getId=Tt(e),e.getDataSet=St(i,e),e.setDataSet=xt(i,e),e.getIsLoading=Dt(c),e.setIsLoading=It(p),e.setActiveRowKey=Ft(e),e.getActiveRowKey=Pt(e),e.getActiveNode=Et(e),e.getActiveRow=Mt(e),e.getNextRowKey=Lt(e),e.getPrevRowKey=Ht(e),e.getSelectedRowKeys=jt(e),e.getSelectedNodes=Bt(e),e.getSelectedRows=zt(e),e.setSelectedRowKeys=Gt(e),e.setSelectedRows=Ot(e),e.getNodeByKey=Nt(e),e.getRowByKey=Kt(e),e.insertRows=_t(i,e),e.updateRows=Wt(i,e),e.removeRowsByKeys=Ut(i,e),e.removeRows=$t(e),e.deleteRows=Qt(e,t),e.fetchData=Xt(e),e.retryFetchData=ea(e),e.setCurrentDataFetchHandler=Jt(u,d),e.getCurrentDataFetchHandler=Zt(u,d),e.getRowData=ta(e),e.openColumnDialog=aa(e,r),e},qt=(e,t)=>{const a=s.useRef(void 0);a.current!==t&&(a.current=t,e.current=t)},Tt=e=>{const[t]=s.useState(e.gridProps.id??"grid-"+ge());return s.useCallback(()=>t,[t])},kt=e=>s.useCallback(()=>!e.current,[e]),St=(e,t)=>s.useCallback(()=>t.tableApi?t.tableApi.getData():e.current??void 0,[e,t.tableApi]),xt=(e,t)=>s.useCallback(a=>{var n,o,l,r,i,u;t.tableApi&&(e.current=a??void 0,(n=t.tableApi)==null||n.deselectRow(),(o=t.tableApi)==null||o.clearData(),(l=e.current)!=null&&l.length&&((r=t.tableApi)==null||r.setData(e.current)),(u=(i=t.gridProps).onDataChanged)==null||u.call(i,e.current,t))},[e,t]),Dt=e=>s.useCallback(()=>e,[e]),It=e=>s.useCallback(t=>{setTimeout(()=>{e(t)},0)},[e]),Ft=e=>s.useCallback((t,a,n)=>{e.tableApi&&e.tableApi.setActiveRowByKey(t,a,n)},[e]),Pt=e=>s.useCallback(()=>{var t,a;return(a=(t=e.tableApi)==null?void 0:t.getActiveRowKey)==null?void 0:a.call(t)},[e]),Et=e=>s.useCallback(()=>{var t,a;return(a=(t=e.tableApi)==null?void 0:t.getActiveRow)==null?void 0:a.call(t)},[e]),Mt=e=>s.useCallback(()=>{var t;return(t=e.getActiveNode())==null?void 0:t.getData()},[e]),Lt=e=>s.useCallback((t,a)=>{var o;if(!e.tableApi||!t)return;a||(a=1);let n=(o=e.tableApi)==null?void 0:o.getRow(t);if(n){for(let l=0;l<a;l++){const r=n==null?void 0:n.getNextRow();if(!r)return n.getData().id;n=r}return n.getData().id}},[e.tableApi]),Ht=e=>s.useCallback((t,a)=>{var o;if(!e.tableApi||!t)return;a||(a=1);let n=(o=e.tableApi)==null?void 0:o.getRow(t);if(n){for(let l=0;l<a;l++){const r=n==null?void 0:n.getPrevRow();if(!r)return n.getData().id;n=r}return n.getData().id}},[e.tableApi]),jt=e=>{const t=s.useRef([]);return s.useCallback(()=>{if(!e.tableApi)return t.current;const a=e.tableApi.getSelectedData(),n=[];for(const o of a)n.push(o.id);return n},[e])},Gt=e=>s.useCallback((t,a)=>{var o,l;if(!e.tableApi)return;(!t||a)&&((o=e.tableApi)==null||o.deselectRow());const n=D(t)?t:[t];(l=e.tableApi)==null||l.selectRow(n)},[e]),Ot=e=>s.useCallback((t,a)=>{if(!e.tableApi)return;if(!t)return e.setSelectedRowKeys(void 0,a);const n=[];for(const o of t)n.push(o.id);e.setSelectedRowKeys(n,a)},[e]),Bt=e=>s.useCallback(()=>{var t,a;return((a=(t=e.tableApi)==null?void 0:t.getSelectedRows)==null?void 0:a.call(t))??[]},[e]),zt=e=>s.useCallback(()=>{var t,a;return((a=(t=e.tableApi)==null?void 0:t.getSelectedData)==null?void 0:a.call(t))??[]},[e]),Nt=e=>s.useCallback(t=>{var a;if(!(!t||!e.tableApi))return(a=e.tableApi)==null?void 0:a.getRow(t)},[e]),Kt=e=>s.useCallback(t=>{var a;return(a=e.getNodeByKey(t))==null?void 0:a.getData()},[e]),_t=(e,t)=>s.useCallback((a,n,o,l)=>{var c,p;const r=t.tableApi;if(!r)return;const i=t.gridProps.dataTree,u=n==="above",d=D(a)?[...a]:[a];for(const f of d)i?Yt(t,[f],n,o):r.addData([f],u,o).then();e.current=r.getData()||[],(p=(c=t.gridProps).onDataChanged)==null||p.call(c,e.current,t),l&&d[0]&&t.setActiveRowKey(d[0].id,!0,"center"),r.setTableBodyFocus()},[e,t]),Wt=(e,t)=>s.useCallback((a,n)=>{var r,i,u;if(!t.tableApi)return;const o=t.gridProps.dataTree,l=D(a)?[...a]:[a];for(const d of l)o?At(t,d):t.tableApi.updateData([d]).then();e.current=((r=t.tableApi)==null?void 0:r.getData())||[],(u=(i=t.gridProps).onDataChanged)==null||u.call(i,e.current,t),n&&l[0]&&t.setActiveRowKey(l[0].id,!0,"center"),t.tableApi.setTableBodyFocus()},[e,t]),Se=(e,t)=>{if(!e.tableApi)return;const a=e.tableApi.options.dataTreeParentField,n=e.tableApi.options.index;if(!n||!a||!t[a])return;let o;if(typeof t[a]=="string"||typeof t[a]=="number"?o=t[a]:typeof t[a]=="object"&&(o=t[a][n]),!!o)return e.tableApi.getRow(o)||void 0},Yt=(e,t,a,n)=>{var r;if(!e.tableApi)return;if(!e.gridProps.dataTree){console.warn("TreeData mode is disabled. Tree row updating not available");return}const o=a==="above",l=D(t)?[...t]:[t];for(const i of l){const u=Se(e,i);u?(u.addTreeChild(i),re(u),u.reformat()):(r=e.tableApi)==null||r.addData([i],o,n)}},At=(e,t)=>{if(!e.tableApi)return;if(!e.gridProps.dataTree){console.warn("TreeData mode is disabled. Tree row updating not available");return}const a=e.tableApi.options.index,n=e.tableApi.options.dataTreeChildField;if(!a||!n)return;const o=D(t)?[...t]:[t];for(const l of o){const r=l[a],i=e.tableApi.getRow(r);if(!i){e.tableApi.addData([l]).then();continue}const u=i.getTreeParent(),d=Se(e,l);if(!u&&!d||u&&d&&u.getData()[a]===d.getData()[a]){e.tableApi.updateData([l]).then();continue}if(l[n]=i.getData()[n],e.tableApi.deselectRow(i),e.tableApi.deleteRow(r),u&&u.reformat(),!d){e.tableApi.addData([l]).then();continue}d.addTreeChild(l),re(d),d.reformat()}},re=e=>{if(!e)return;const t=e.getTreeParent();re(t),e.isTreeExpanded()||e.treeExpand()},Ut=(e,t)=>s.useCallback(a=>{var u,d;const n=t.tableApi;if(!n)return;const o=n.options.index,l=D(a)?[...a]:[a];let r=!1,i=!1;for(const c of l){const p=n.getRow(c);if(!p)continue;r&&p===r&&(r=!1),i=p.getNextRow()||p.getPrevRow(),i&&(r=i);const f=n.options.dataTree?p.getTreeParent():!1;n.deselectRow(p),n.deleteRow(c),f&&f.reformat()}r&&o&&(r=n.getRow(r.getData()[o])),n.setActiveRow(r||null,!0,"bottom"),e.current=(n==null?void 0:n.getData())??[],(d=(u=t.gridProps).onDataChanged)==null||d.call(u,e.current,t),n.setTableBodyFocus()},[e,t]),$t=e=>s.useCallback(t=>{const a=D(t)?[...t]:[t],n=[];for(const o of a)n.push(o.id);e.removeRowsByKeys(n)},[e]),Qt=(e,t)=>{const a=v(t);return s.useCallback(n=>{if(!n)return;const o=Array.isArray(n)?n:[n];let l;const r=()=>{var u;const i=(u=t==null?void 0:t.onDelete)==null?void 0:u.call(t,o,e);if(ye(i)){t.confirmDelete||e.setIsLoading(!0),i.then(()=>{e.getIsMounted()&&(e.removeRows(o),t.confirmDelete?l==null||l.destroy():e.setIsLoading(!1))}).catch(c=>{e.getIsMounted()&&(t.confirmDelete?l==null||l.destroy():e.setIsLoading(!1),Q.alert({language:t.language,content:h.jsxs(h.Fragment,{children:[h.jsx("p",{children:h.jsx("b",{children:c.message})}),c.stack&&we()?h.jsx("p",{children:c.stack}):""]}),colorType:"danger"}))});return}e.removeRows(o),l&&l.destroy()};t.confirmDelete?l=Q.confirmWaiter({language:t.language,content:t.rowDeleteMessage??a("deleteSelectedRecordsQt"),onOk:r}):r()},[e])},Xt=e=>s.useCallback((t,a)=>{const n=e.tableApi;n&&(n.modules.page.dataChanging=!0,n.modules.ajax.setUrl("-"),t&&(n.modules.ajax.loaderPromise=ke(e,t,a)),n.setData(void 0,a).then())},[e]),Jt=(e,t)=>s.useCallback((a,n)=>{e.current=a,t.current=n},[e,t]),Zt=(e,t)=>s.useCallback(()=>[e.current,t.current],[e,t]),ea=e=>s.useCallback(()=>{const[t,a]=e.getCurrentDataFetchHandler();t&&e.fetchData(t,a)},[e]),ta=e=>s.useCallback((t,a,n,o,l)=>{const r=e.tableApi;if(!r||!t)return{};const i=o?{}:{...t.getData()};if(!r.options.dataTree)return i;const u=r.options.dataTreeParentField,d=r.options.dataTreeChildField;if(!l&&d&&delete i[d],!u||typeof i[u]<"u")return i;const c=n?t:t.getTreeParent();if(!c)return i;const p=c.getData();return!l&&d&&delete p[d],i[u]=c.getData(),i},[e]),aa=(e,t)=>s.useCallback(a=>{t(a)},[t]);try{J.displayName="useInitGridApi",J.__docgenInfo={description:"",displayName:"useInitGridApi",props:{gridApi:{defaultValue:null,description:"",name:"gridApi",required:!0,type:{name:"IGridApi"}},props:{defaultValue:null,description:"",name:"props",required:!0,type:{name:"IGridProps"}},tableRef:{defaultValue:null,description:"",name:"tableRef",required:!0,type:{name:"MutableRefObject<TabulatorFull | undefined>"}},editFormApi:{defaultValue:null,description:"",name:"editFormApi",required:!0,type:{name:"IDFormModalApi"}},selectionFormApi:{defaultValue:null,description:"",name:"selectionFormApi",required:!0,type:{name:"IDFormModalApi"}},buttonsApi:{defaultValue:null,description:"",name:"buttonsApi",required:!0,type:{name:"IButtonsRowApi & { refreshButtons: () => void; }"}},setColumnsDialog:{defaultValue:null,description:"",name:"setColumnsDialog",required:!0,type:{name:"Dispatch<SetStateAction<boolean>>"}}}}}catch{}const na=(e,t)=>s.useMemo(()=>{const a=t==null?void 0:t.editFormProps;if(!a)return;const n={...a};t.language&&!n.language&&(n.language=t.language);const o=a==null?void 0:a.onSubmitSuccess;return n.onSubmitSuccess=(l,r,i)=>{if(o&&o(l,r,i)===!1)return!1;const u={...i.model.getFormDataSet(),...r},d=i.model.getFormMode();if(d==="create"||d==="clone"){u.id||(u.id=ge());const c=e.getActiveRowKey();e.insertRows(u,"below",c??void 0,!0)}else d==="update"&&e.updateRows(u,!0)},n},[e,t==null?void 0:t.editFormProps,t.language]),Z=e=>{const[,t]=s.useState({}),a=e.gridProps.buttons,n=e.gridProps.buttonsSize??"small",o=e.gridProps.buttonsPosition??"right",l=e.gridProps.buttonsIconsOnly,r=e.getActiveRow(),i=e.getSelectedRows();e.buttonsApi.refreshButtons=oa(t);const u=la(e),d=ra(e,r,i),c=ia(e),p=sa(e,r,i),f=ua(e,r,i),y=ca(e,i),g=da(e),R=pa(e,e.tableApi),q=ha(e);return s.useMemo(()=>{var w;const I=Pe({headerLabel:u,view:d,create:c,clone:p,update:f,select:g,delete:y,filterToggle:R,system:q},a);for(const P in I){const b=I[P];!b||P==="headerLabel"||(b.size=b.size??n,b.position=b.position??o,l&&(b.tooltip=b.tooltip??((w=b.title)==null?void 0:w.toString()),b.title=void 0),b.checkDisabled&&(b.disabled=!r||i.length!==1),b.checkHidden&&(b.hidden=!r||i.length!==1))}return I},[u,d,c,p,f,g,y,R,q,a,n,o,l,r,i.length])},oa=e=>s.useCallback(()=>{e({})},[e]),la=e=>s.useMemo(()=>{const t=e.gridProps;if(t.headerLabel)return{weight:1,title:t.headerLabel,type:"element",position:"left"}},[e]),ra=(e,t,a)=>{var l;const n=e.gridProps,o=v(n);return s.useMemo(()=>{var i;const r=e.editFormApi;if(!(!n.editFormProps||!n.readOnly||((i=n.buttons)==null?void 0:i.view)===null))return{weight:100,title:o("view"),tooltip:o("viewRecord"),icon:h.jsx(Ke,{}),position:"right",disabled:!t||a.length!==1,hotKeys:[{key:"Enter"}],onClick:()=>{if(!e.getActiveRow())return;const u=K(e,!1);r.open("view",u)}}},[t,e,(l=n.buttons)==null?void 0:l.view,n.editFormProps,n.readOnly,a.length,o])},ia=e=>{var n;const t=e.gridProps,a=v(t);return s.useMemo(()=>{var l;const o=e.editFormApi;if(!(!t.editFormProps||t.readOnly||((l=t.buttons)==null?void 0:l.create)===null))return{weight:110,title:a("create"),tooltip:a("createNewRecord"),icon:h.jsx(je,{}),position:"right",hotKeys:[{key:"Insert"}],onClick:()=>{const r=K(e,!0,!0);o.open("create",r)}}},[e,(n=t.buttons)==null?void 0:n.create,t.editFormProps,t.readOnly,a])},sa=(e,t,a)=>{var l;const n=e.gridProps,o=v(n);return s.useMemo(()=>{var i;const r=e.editFormApi;if(!(!n.editFormProps||n.readOnly||((i=n.buttons)==null?void 0:i.clone)===null))return{weight:120,title:o("clone"),tooltip:o("cloneRecord"),icon:h.jsx(Ge,{}),position:"right",disabled:!t||a.length!==1,hotKeys:[{key:"F9"}],onClick:()=>{if(!e.getActiveRow())return;const u=K(e,!1);r.open("clone",u)}}},[t,e,(l=n.buttons)==null?void 0:l.clone,n.editFormProps,n.readOnly,a.length,o])},ua=(e,t,a)=>{var l;const n=e.gridProps,o=v(n);return s.useMemo(()=>{var i;const r=e.editFormApi;if(!(!n.editFormProps||n.readOnly||((i=n.buttons)==null?void 0:i.update)===null))return{weight:130,title:o("editRecord"),tooltip:o("editRecord"),icon:h.jsx(Oe,{}),position:"right",disabled:!t||a.length!==1,hotKeys:[{key:"Enter"},{key:"F2"}],onClick:()=>{if(!e.getActiveRow())return;const u=K(e,!1);r.open("update",u)}}},[t,e,(l=n.buttons)==null?void 0:l.update,n.editFormProps,n.readOnly,a.length,o])},da=e=>{var n;const t=e.gridProps,a=v(t);return s.useMemo(()=>{var l;const o=e.selectionFormApi;if(!(!t.selectionFormProps||t.readOnly||((l=t.buttons)==null?void 0:l.select)===null))return{weight:130,title:a("select"),tooltip:a("selectRecord"),icon:h.jsx(Je,{}),position:"right",hotKeys:[{key:"Insert"}],onClick:()=>{const r=e.getDataSet();o.open("update",{select:r})}}},[e,(n=t.buttons)==null?void 0:n.select,t.readOnly,t.selectionFormProps,a])},ca=(e,t)=>{var o;const a=e.gridProps,n=v(a);return s.useMemo(()=>{var l;if(!(!a.editFormProps&&!a.selectionFormProps||a.readOnly||((l=a.buttons)==null?void 0:l.delete)===null))return{weight:140,title:n("delete"),tooltip:n("deleteRecord"),icon:h.jsx(Ze,{}),position:"right",colorType:"danger",disabled:!t||t.length===0,hotKeys:[{key:"Delete",ctrl:!0}],onClick:()=>{const r=e.getSelectedRows();e.deleteRows(r)}}},[e,(o=a.buttons)==null?void 0:o.delete,a.editFormProps,a.readOnly,a.selectionFormProps,t,n])},pa=(e,t)=>{var o;const a=e.gridProps,n=v(a);return s.useMemo(()=>{var l;if(((l=a.buttons)==null?void 0:l.filterToggle)!==null&&t!=null&&t.isHeaderFilterAvailable())return{weight:1e3,icon:h.jsx(wt,{}),position:"right",active:t==null?void 0:t.isHeaderFilterVisible(),tooltip:n("filter"),onClick:()=>{const r=t==null?void 0:t.toggleHeaderFilter();e.buttonsApi.updateButtons({filterToggle:{active:r}})}}},[e.buttonsApi,(o=a.buttons)==null?void 0:o.filterToggle,n,t])},K=(e,t,a)=>{const n=e.getActiveNode();return e.getRowData(n,!0,t,a)},ha=e=>{var n;const t=e.gridProps,a=v(t);return s.useMemo(()=>{var o;if(((o=t.buttons)==null?void 0:o.filterToggle)!==null)return{weight:2e3,expandIcon:h.jsx(et,{}),position:"right",children:{toXlsx:{title:a("exportXls"),onClick:()=>{Ne(()=>import("./xlsx-B8nI__6b.js"),[],import.meta.url).then(r=>{var i;window.XLSX=r,(i=e.tableApi)==null||i.download("xlsx","table.xlsx")})}},columns:{title:a("columnsSettings"),onClick:()=>{e.openColumnDialog(!0)}}}}},[e,(n=t.buttons)==null?void 0:n.filterToggle,a])};try{Z.displayName="useInitButtons",Z.__docgenInfo={description:"",displayName:"useInitButtons",props:{getId:{defaultValue:null,description:"Get grid ID",name:"getId",required:!0,type:{name:"() => string"}},gridProps:{defaultValue:null,description:"Current grid props",name:"gridProps",required:!0,type:{name:"IGridProps"}},tableApi:{defaultValue:null,description:"Component table instance (Tabulator)",name:"tableApi",required:!0,type:{name:"ITabulator | undefined"}},getIsMounted:{defaultValue:null,description:"Get grid mounted state",name:"getIsMounted",required:!0,type:{name:"() => boolean"}},getDataSet:{defaultValue:null,description:"Get current data set",name:"getDataSet",required:!0,type:{name:"() => IGridRowData[] | undefined"}},setDataSet:{defaultValue:null,description:"Set data set",name:"setDataSet",required:!0,type:{name:"(dataSet: IGridRowData[] | null | undefined) => void"}},getIsLoading:{defaultValue:null,description:"Get current loading state",name:"getIsLoading",required:!0,type:{name:"() => boolean"}},setIsLoading:{defaultValue:null,description:"Set current loading state",name:"setIsLoading",required:!0,type:{name:"(isLoading: boolean) => void"}},insertRows:{defaultValue:null,description:"Insert new row/rows",name:"insertRows",required:!0,type:{name:'(rowData: IGridRowData | IGridRowData[], place?: "above" | "below" | undefined, key?: string | number | undefined, updateActiveRow?: boolean | undefined) => void'}},updateRows:{defaultValue:null,description:"Update existed row/rows",name:"updateRows",required:!0,type:{name:"(rowData: IGridRowData | IGridRowData[], updateActiveRow?: boolean | undefined) => void"}},removeRowsByKeys:{defaultValue:null,description:"Delete existed row/rows by keys",name:"removeRowsByKeys",required:!0,type:{name:"(keys: IRowKeys) => void"}},removeRows:{defaultValue:null,description:"Simple remove existed row/rows from grid without any logic (not to be confused with deleteRows)",name:"removeRows",required:!0,type:{name:"(rowData: IGridRowData | IGridRowData[]) => void"}},deleteRows:{defaultValue:null,description:"Delete existed row/rows from grid with deletion confirmation and asynchronous processing (not to be confused with removeRows)",name:"deleteRows",required:!0,type:{name:"(rowData: IGridRowData | IGridRowData[]) => void"}},setActiveRowKey:{defaultValue:null,description:"Set active row",name:"setActiveRowKey",required:!0,type:{name:"(key: string | number | null, clearSelection?: boolean | undefined, scrollPosition?: ScrollToRowPosition | undefined) => void"}},getActiveRowKey:{defaultValue:null,description:"",name:"getActiveRowKey",required:!0,type:{name:"() => string | number | undefined"}},getActiveNode:{defaultValue:null,description:"Get active row node",name:"getActiveNode",required:!0,type:{name:"() => RowComponent | undefined"}},getActiveRow:{defaultValue:null,description:"Get active row",name:"getActiveRow",required:!0,type:{name:"() => IGridRowData | undefined"}},getNextRowKey:{defaultValue:null,description:"",name:"getNextRowKey",required:!0,type:{name:"(key: string | number | undefined, step?: number | undefined) => string | number | undefined"}},getPrevRowKey:{defaultValue:null,description:"",name:"getPrevRowKey",required:!0,type:{name:"(key: string | number | undefined, step?: number | undefined) => string | number | undefined"}},getSelectedRowKeys:{defaultValue:null,description:"Get selected rows keys",name:"getSelectedRowKeys",required:!0,type:{name:"() => (string | number)[]"}},setSelectedRowKeys:{defaultValue:null,description:"Set selected row/rows keys",name:"setSelectedRowKeys",required:!0,type:{name:"(keys: IRowKeys | null | undefined, clearPrevSelection?: boolean | undefined) => void"}},setSelectedRows:{defaultValue:null,description:"Set selected row/rows keys",name:"setSelectedRows",required:!0,type:{name:"(rows: IGridRowData[] | undefined, clearPrevSelection?: boolean | undefined) => void"}},getSelectedNodes:{defaultValue:null,description:"Get selected tabulator row nodes",name:"getSelectedNodes",required:!0,type:{name:"() => RowComponent[]"}},getSelectedRows:{defaultValue:null,description:"Get selected rows",name:"getSelectedRows",required:!0,type:{name:"() => IGridRowData[]"}},getRowData:{defaultValue:null,description:`@return row data (suitable as a dataSet for dForm)
@param node - row node
@param withParent - Add parent information to data
@param selfParent - The parent of a row must be the row itself
@param parentOnly - The data should not contain any data other than parent data
@param withChildren - The data must contain children data`,name:"getRowData",required:!0,type:{name:"(node: RowComponent | undefined, withParent?: boolean | undefined, selfParent?: boolean | undefined, parentOnly?: boolean | undefined, withChildren?: boolean | undefined) => Record<...>"}},openColumnDialog:{defaultValue:null,description:"Open columns properties dialog",name:"openColumnDialog",required:!0,type:{name:"(open: boolean) => void"}},getNodeByKey:{defaultValue:null,description:"Returns row node by key",name:"getNodeByKey",required:!0,type:{name:"(key: string | number) => RowComponent | undefined"}},getRowByKey:{defaultValue:null,description:"Returns row by key",name:"getRowByKey",required:!0,type:{name:"(key: string | number) => IGridRowData | undefined"}},editFormApi:{defaultValue:null,description:"edit form api",name:"editFormApi",required:!0,type:{name:"IDFormModalApi"}},selectionFormApi:{defaultValue:null,description:"selection form api",name:"selectionFormApi",required:!0,type:{name:"IDFormModalApi"}},buttonsApi:{defaultValue:null,description:"Buttons api",name:"buttonsApi",required:!0,type:{name:"IButtonsRowApi & { refreshButtons: () => void; }"}},fetchData:{defaultValue:null,description:"Fetch data. If onDataFetch callback  is undefined,the request will use the previously set onDataFetch callback",name:"fetchData",required:!0,type:{name:"(onDataFetch?: ((params: IRequestProps, gridApi: IGridApi) => IGridRowData[] | IGridDataSourcePromise | undefined) | undefined, params?: Record<...> | undefined) => void"}},retryFetchData:{defaultValue:null,description:"Retry fetch data (with last fetch function)",name:"retryFetchData",required:!0,type:{name:"() => void"}},setCurrentDataFetchHandler:{defaultValue:null,description:"Set current data fetch handler",name:"setCurrentDataFetchHandler",required:!0,type:{name:"(dataFetchHandler: ((params: IRequestProps, gridApi: IGridApi) => IGridRowData[] | IGridDataSourcePromise | undefined) | undefined, params?: Record<...> | undefined) => void"}},getCurrentDataFetchHandler:{defaultValue:null,description:"Get current data fetch handler",name:"getCurrentDataFetchHandler",required:!0,type:{name:"() => [((params: IRequestProps, gridApi: IGridApi) => IGridRowData[] | IGridDataSourcePromise | undefined) | undefined, Record<...> | undefined]"}}}}}catch{}const ee=({gridApi:e})=>{const t=e.gridProps,a=Z(e),[n,o]=s.useState(void 0);return s.useLayoutEffect(()=>{var r;const l=Ee(a)>0;(typeof n>"u"||n!==l)&&(o(l),(r=t==null?void 0:t.onMenuVisibilityChanged)==null||r.call(t,l,e))},[a,e,t,t==null?void 0:t.onMenuVisibilityChanged,n]),a?h.jsx("div",{style:{width:"100%",paddingBottom:8,paddingTop:8},children:h.jsx(ve,{buttons:a,apiRef:e.buttonsApi,context:e,responsiveBreakpoint:t.responsiveBreakpoint})}):null};try{ee.displayName="MenuRow",ee.__docgenInfo={description:"",displayName:"MenuRow",props:{gridApi:{defaultValue:null,description:"",name:"gridApi",required:!0,type:{name:"IGridApi"}}}}}catch{}const fa=(e,t)=>{const a=t.events,n=v(t);return s.useMemo(()=>({tableBuilt:()=>{var o;(o=a==null?void 0:a.tableBuilt)==null||o.call(a),e.buttonsApi.refreshButtons()},dataLoading:o=>{var l,r,i;(l=a==null?void 0:a.dataLoading)==null||l.call(a,o),(i=(r=e.gridProps).onDataLoading)==null||i.call(r,o,e),e.gridProps.progressiveLoad||e.setIsLoading(!0)},dataLoaded:o=>{var l,r,i;(l=a==null?void 0:a.dataLoaded)==null||l.call(a,o),(i=(r=e.gridProps).onDataLoaded)==null||i.call(r,o,e),e.getIsMounted()&&(e.gridProps.progressiveLoad||e.setIsLoading(!1))},dataProcessed:o=>{var l,r,i;(l=a==null?void 0:a.dataProcessed)==null||l.call(a,o),(i=(r=e.gridProps).onDataProcessed)==null||i.call(r,o,e)},dataLoadError:o=>{var i,u,d;(i=a==null?void 0:a.dataLoadError)==null||i.call(a,o);const l=o;if((d=(u=e.gridProps).onDataLoadError)==null||d.call(u,l.message,l.code,e),!e.getIsMounted())return;e.setIsLoading(!1);const r=Q.confirm({language:e.gridProps.language,content:h.jsxs("div",{children:[h.jsx("p",{children:h.jsx("b",{children:o.message})}),o.stack&&we()?h.jsx("p",{children:o.stack}):"",h.jsx("p",{children:n("tryAgainQt")})]}),colorType:"danger",buttons:{ok:{onClick:()=>{r.destroy(),e.retryFetchData()}}}})},rowDblClick:(o,l)=>{var r;(r=a==null?void 0:a.rowDblClick)==null||r.call(a,o,l),e.buttonsApi.triggerClick("update")},activeRowChanged:o=>{var l;(l=a==null?void 0:a.activeRowChanged)==null||l.call(a,o),e.buttonsApi.refreshButtons()},rowSelectionChanged:(o,l,r,i)=>{var u,d,c;(u=a==null?void 0:a.rowSelectionChanged)==null||u.call(a,o,l,r,i),(c=(d=e.gridProps).onSelectionChange)==null||c.call(d,o,l,r,i,e)}}),[a,e,n])},te=({tableRef:e,gridApi:t,gridProps:a,tabulatorProps:n})=>{const o=fa(t,a),l=s.useRef(void 0),r=s.useCallback(p=>{e.current=p.current,t.tableApi=p.current,a.resizeHeightWithParent&&(l.current=ma(e,a.resizeHeightWithParent))},[t,a.resizeHeightWithParent,e]),i=v(a);s.useEffect(()=>()=>{var p;(p=l.current)==null||p.disconnect()},[]),s.useEffect(()=>{Le.pushToStack(t.getId())},[t]);const u=s.useMemo(()=>ke(t,a==null?void 0:a.onDataFetch),[t,a.onDataFetch]),d=s.useCallback((p,f)=>{var y;return(y=a.onDataFetching)==null?void 0:y.call(a,p,f,t)},[t,a.onDataFetching]),c=s.useCallback((p,f,y)=>{var g;return(g=a.onDataFetchResponse)==null?void 0:g.call(a,y,f,t)},[t,a.onDataFetchResponse]);return h.jsx(tt,{...n,id:t.getId(),layout:n.layout??"fitData",movableColumns:n.movableColumns!==!1,height:"100%",dataLoader:!1,onTableRef:r,dataTreeFilter:!0,data:a.dataSet,ajaxRequesting:a.onDataFetching?void 0:d,ajaxRequestFunc:a.onDataFetch?u:void 0,ajaxResponse:a.onDataFetchResponse?c:void 0,containerClassName:a.className,placeholder:a.placeholder??i("noRows"),events:o})},ma=(e,t)=>{var u,d;const a=(d=(u=e.current)==null?void 0:u.element)==null?void 0:d.closest(".tabulator-grid-container"),n=a==null?void 0:a.closest(t);if(!a||!n||a.style.height.endsWith("%"))return;let o=parseInt(a.style.height),l=n.getBoundingClientRect().height;const r=()=>{if(!e.current)return;const c=n.getBoundingClientRect().height;o=o+(c-l),a.style.height=(o>0?o:0)+"px",l=n.getBoundingClientRect().height},i=new ResizeObserver(r);return i.observe(n),i};try{te.displayName="GridRender",te.__docgenInfo={description:"",displayName:"GridRender",props:{tableRef:{defaultValue:null,description:"",name:"tableRef",required:!0,type:{name:"MutableRefObject<ITabulator | undefined>"}},gridApi:{defaultValue:null,description:"",name:"gridApi",required:!0,type:{name:"IGridApi"}},gridProps:{defaultValue:null,description:"",name:"gridProps",required:!0,type:{name:"IGridProps"}},tabulatorProps:{defaultValue:null,description:"",name:"tabulatorProps",required:!0,type:{name:"ITabulatorProps"}}}}}catch{}const ae=e=>{const[t]=s.useState({}),a=e.gridApi.gridProps,n=v(a);return h.jsx(He,{title:n("columns"),destroyOnClose:!0,centered:!0,open:e.open,onCancel:()=>e.gridApi.openColumnDialog(!1),footer:h.jsx(ya,{formProps:e,dialogApi:t}),children:e.open&&h.jsx(ba,{dialogProps:e,dialogApi:t})})},ba=({dialogProps:e,dialogApi:t})=>{const a=e.gridApi.tableApi,[n,o]=s.useState([]),[l,r]=s.useState([]),[i,u]=s.useState([]);t.gridApi=e.gridApi,t.setNodes=u,t.setChecked=o,t.setExpanded=r,s.useEffect(()=>{const f=De(a.getColumns(!0));xe(t,f),ga(t)},[]);const d=Ta(t,o),c=qa(t),p=Va(t);return h.jsx(le,{draggable:!0,blockNode:!0,showIcon:!0,defaultExpandAll:!0,checkable:!0,expandedKeys:l,checkedKeys:n,treeData:i,selectable:!1,onCheck:d,allowDrop:p,onDrop:c,onExpand:f=>{r(f)}})},ya=({formProps:e,dialogApi:t})=>{const a=t.gridApi.gridProps,n=v(a);return h.jsx(ve,{arrowsSelection:!0,buttons:{ok:{title:n("ok"),position:"right",active:!0,onClick:()=>ka(e,t)},cancel:{title:n("cancel"),position:"right",onClick:()=>{e.gridApi.openColumnDialog(!1)}},default:{title:n("reset"),position:"left",onClick:()=>Sa(e,t)}}})},xe=(e,t)=>{e.columnsDefsMap={};const a=(l,r)=>{var d;r||(r={val:0});let i=[];const u=[];for(const c of l){if(c.formatter==="rowSelection")continue;r.val++;const p=r.val.toString(),f={key:p,title:c.title};let y=c.visible!==!1;if((d=c.columns)!=null&&d.length){f.icon=h.jsx(qe,{});const[g,R]=a(c.columns,r);f.children=g,i=[...i,...R],R.length<c.columns.length&&(y=!1)}u.push(f),y&&i.push(p),e.columnsDefsMap[p]=c}return[u,i]},[n,o]=a(t);e.nodes=n,e.checked=o,e.setNodes(n),e.setChecked(o)},ga=e=>{const t=[];for(const a in e.columnsDefsMap)t.push(a);e.setExpanded(t)},wa=e=>{const t=n=>{var r;const o=[];let l=!1;for(const i of n){const u=e.columnsDefsMap[i.key.toString()];if(u.visible=e.checked.indexOf(i.key)>-1,(r=i.children)!=null&&r.length){const[d,c]=t(i.children);u.columns=d,c&&(u.visible=!0)}else delete u.columns;u.visible&&(l=!0),o.push(u)}return[o,l]},[a]=t(e.nodes);return a},De=e=>{const t=[];for(const a of e){const n={...a.getDefinition()};n.visible=a.isVisible(),n.width=a.getWidth();const o=a.getSubColumns();o!=null&&o.length&&(n.columns=De(o)),t.push(n)}return t},va=e=>{const t=(a,n)=>{var l;const o=[];for(const r of a){const i={...n,...r};i.visible=i.visible!==!1,i.width||(i.width=0),(l=i.columns)!=null&&l.length&&(i.columns=t(i.columns,n)),o.push(i)}return o};return t(e.columns,e.columnDefaults??{})},Ra=(e,t)=>{if(t.default&&e.gridApi.gridProps.persistence){const o=e.gridApi.gridProps.persistenceID??e.gridApi.getId();localStorage.removeItem(`tabulator-${o}-columns`)}const a=wa(t),n=t.gridApi.tableApi;n==null||n.setColumnLayout(a),n!=null&&n.isHeaderFilterVisible()||n==null||n.toggleHeaderFilter(!1)},L=(e,t)=>{var a;for(const n of e){if(n.key===t)return n;if(!((a=n.children)!=null&&a.length))continue;const o=L(n.children,t);if(o)return o}},ie=(e,t)=>{var n;let a=0;for(const o of e){if(o.key===t)return e.splice(a,1),!0;(n=o.children)!=null&&n.length&&ie(o.children,t),a++}},x=(e,t,a)=>{var n;for(const o of e){if(o.key===t.key)return a;if(!((n=o.children)!=null&&n.length))continue;const l=x(o.children,t,o);if(l)return l}},se=(e,t,a)=>{const n=e,o=x(a.nodes,e);if((o==null?void 0:o.key)===(t==null?void 0:t.key))return n;if(o)return se(o,t,a)},ue=e=>{var a,n;if(!((a=e.children)!=null&&a.length))return e;const t=e.children[e.children.length-1];return(n=t.children)!=null&&n.length?ue(t):t},Ca=(e,t,a)=>{var o;if(!(t!=null&&t.children))return!1;const n=x(a.nodes,e);return t.key===(n==null?void 0:n.key)?(ie(a.nodes,e.key),(o=t.children)==null||o.unshift(e),!0):!1},$=(e,t,a,n)=>{if(!t)return!1;const o=x(n.nodes,e),l=x(n.nodes,t);if(!o&&l||o&&!l||(o==null?void 0:o.key)!==(l==null?void 0:l.key))return!1;let r=[];if(!o&&!l)r=n.nodes;else if((o==null?void 0:o.key)===(l==null?void 0:l.key))r=l.children;else return!1;ie(n.nodes,e.key);const i=r.indexOf(t);return i<0?!1:(r.splice(i+(a==="below"?1:0),0,e),!0)},Va=e=>{const t=a=>{const n=L(e.nodes,a.dragNode.key),o=L(e.nodes,a.dropNode.key);if(!n||!o)return!1;const l=x(e.nodes,n),r=x(e.nodes,o);if(a.dropPosition===-1)return l===r;if(a.dropPosition===0||a.dropPosition===1){if(!o.children&&l===r||o.children&&l===o)return!0;const i=se(o,l,e);if(!i)return!1;if(o===ue(i))return!0}return!1};return s.useCallback(t,[e])},qa=e=>{const t=a=>{const n=L(e.nodes,a.dragNode.key),o=L(e.nodes,a.node.key);if(!o||!n)return;const l=x(e.nodes,n);if(a.node.dragOverGapTop)$(n,o,"above",e);else{const r=se(o,l,e);r&&o===ue(r)?$(n,r,"below",e):o.children?Ca(n,o,e):$(n,o,"below",e)}e.setNodes([...e.nodes])};return s.useCallback(t,[e])},Ta=(e,t)=>s.useCallback(a=>{let n;Array.isArray(a)?n=a:n=[...a.checked,...a.halfChecked],e.checked=n,t(n)},[e,t]),ka=(e,t)=>{Ra(e,t),e.gridApi.openColumnDialog(!1)},Sa=(e,t)=>{const a=va(e.gridApi.gridProps);t.default=!0,xe(t,a)};try{ae.displayName="ColumnsDialog",ae.__docgenInfo={description:"",displayName:"ColumnsDialog",props:{open:{defaultValue:null,description:"",name:"open",required:!1,type:{name:"boolean"}},gridApi:{defaultValue:null,description:"",name:"gridApi",required:!0,type:{name:"IGridApi"}}}}}catch{}const xa=(e,t)=>s.useMemo(()=>{var l;const a=(l=e.gridProps)==null?void 0:l.selectionFormProps;if(!a)return;const n={...a};t.language&&!n.language&&(n.language=t.language);const o=a==null?void 0:a.onSubmitSuccess;return n.onSubmitSuccess=(r,i,u)=>{if(o&&o(r,i,u)===!1)return!1;const c={...u.model.getFormDataSet(),...i}.select??[];if(!t.appendSelection)return e.setDataSet(c);const p=e.getDataSet()??[];for(const f of c)p.find(y=>y.id===f.id)||e.insertRows(f)},n},[e,t.appendSelection,t.language]),ne=({tableRef:e,gridApi:t,gridProps:a,tabulatorProps:n,columnsDialog:o})=>{const l=na(t,a),r=xa(t,a);return h.jsxs("div",{className:"tabulator-grid-container",style:{height:a.height||void 0,minHeight:a.minHeight,maxHeight:a.maxHeight},children:[h.jsx(Be,{isLoading:t.getIsLoading(),notHideContent:!0,spinStyle:{height:"100%"},children:h.jsxs(ze,{style:{display:"flex",flexDirection:"column"},children:[h.jsx(ee,{gridApi:t}),h.jsx(te,{tableRef:e,gridApi:t,gridProps:a,tabulatorProps:n})]})}),h.jsx(ae,{open:o,gridApi:t}),l?h.jsx(de,{...l,apiRef:t.editFormApi}):null,r?h.jsx(de,{...r,apiRef:t.selectionFormApi}):null]})};try{ne.displayName="ContainerRender",ne.__docgenInfo={description:"",displayName:"ContainerRender",props:{tableRef:{defaultValue:null,description:"",name:"tableRef",required:!0,type:{name:"MutableRefObject<ITabulator | undefined>"}},gridApi:{defaultValue:null,description:"",name:"gridApi",required:!0,type:{name:"IGridApi"}},gridProps:{defaultValue:null,description:"",name:"gridProps",required:!0,type:{name:"IGridProps"}},tabulatorProps:{defaultValue:null,description:"",name:"tabulatorProps",required:!0,type:{name:"ITabulatorProps"}},columnsDialog:{defaultValue:null,description:"",name:"columnsDialog",required:!0,type:{name:"boolean"}}}}}catch{}const be=e=>{var d,c;const t=Da(e),a=s.useRef(),[n]=s.useState(((d=e.editFormProps)==null?void 0:d.apiRef)??{}),[o]=s.useState(((c=e.selectionFormProps)==null?void 0:c.apiRef)??{}),[l]=s.useState({}),[r]=s.useState(e.apiRef||{}),[i,u]=s.useState(!1);return J({gridApi:r,props:e,tableRef:a,editFormApi:n,selectionFormApi:o,buttonsApi:l,setColumnsDialog:u}),h.jsx(ne,{tableRef:a,gridApi:r,gridProps:e,tabulatorProps:t,columnsDialog:i})},Da=e=>s.useMemo(()=>Me(e,{apiRef:!0,id:!0,gridMode:!0,dataSet:!0,className:!0,headerLabel:!0,buttons:!0,buttonsSize:!0,buttonsPosition:!0,buttonsIconsOnly:!0,readOnly:!0,editFormProps:!0,selectionFormProps:!0,appendSelection:!0,noHover:!0,rowDeleteMessage:!0,confirmDelete:!0,placeholder:!0,onMenuVisibilityChanged:!0,onDataLoading:!0,onDataLoadError:!0,onDataLoaded:!0,onDataChanged:!0,onDataProcessed:!0,onDataFetch:!0,onDataFetching:!0,onDataFetchResponse:!0,onSelectionChange:!0,onDelete:!0,resizeHeightWithParent:!0,responsiveBreakpoint:!0,translation:!0,language:!0})[1],[e]);try{be.displayName="TabulatorGrid",be.__docgenInfo={description:"",displayName:"TabulatorGrid",props:{apiRef:{defaultValue:null,description:"A mutable object to merge with these controls api",name:"apiRef",required:!1,type:{name:"unknown"}},id:{defaultValue:null,description:`Grid Id
Grid ID`,name:"id",required:!1,type:{name:"string"}},gridMode:{defaultValue:null,description:"Grid mode: local or remote",name:"gridMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},dataSet:{defaultValue:null,description:"Grid data set",name:"dataSet",required:!1,type:{name:"IGridRowData[]"}},className:{defaultValue:null,description:"Grid class name",name:"className",required:!1,type:{name:"string"}},headerLabel:{defaultValue:null,description:"Grid label in header buttons row",name:"headerLabel",required:!1,type:{name:"ReactNode"}},buttons:{defaultValue:null,description:"Grid header buttons",name:"buttons",required:!1,type:{name:'Record<"view" | "create" | "update" | "clone" | "delete" | "select" | "filterToggle" | "system", ITabulatorButton | null> | ITabulatorButtons'}},buttonsSize:{defaultValue:null,description:"Grid header buttons size. Default: 'small'",name:"buttonsSize",required:!1,type:{name:"enum",value:[{value:'"small"'},{value:'"middle"'},{value:'"large"'}]}},buttonsIconsOnly:{defaultValue:null,description:"If true, only button icons will be displayed, without title",name:"buttonsIconsOnly",required:!1,type:{name:"boolean"}},buttonsPosition:{defaultValue:null,description:"Grid header buttons size. Default: 'right'",name:"buttonsPosition",required:!1,type:{name:"enum",value:[{value:'"center"'},{value:'"left"'},{value:'"right"'}]}},readOnly:{defaultValue:null,description:"Table can't be edited",name:"readOnly",required:!1,type:{name:"boolean"}},editFormProps:{defaultValue:null,description:"Edit DFormModal parameters",name:"editFormProps",required:!1,type:{name:"IDFormModalProps"}},selectionFormProps:{defaultValue:null,description:"Selection DFormModal parameters",name:"selectionFormProps",required:!1,type:{name:"IDFormModalProps"}},appendSelection:{defaultValue:null,description:"Append row selection when using selectionFormProps (by default, the dataSet is replaced with the selected rows. This option allows you to change this behavior)",name:"appendSelection",required:!1,type:{name:"boolean"}},noHover:{defaultValue:null,description:"Disable row hover effect",name:"noHover",required:!1,type:{name:"boolean"}},rowDeleteMessage:{defaultValue:null,description:"Confirm message before rows delete",name:"rowDeleteMessage",required:!1,type:{name:"ReactNode"}},confirmDelete:{defaultValue:null,description:"Should confirm before delete",name:"confirmDelete",required:!1,type:{name:"boolean"}},placeholder:{defaultValue:null,description:`No rows placeholder
placeholder element to display on empty table.`,name:"placeholder",required:!1,type:{name:"(string & (string | HTMLElement | ((this: TabulatorFull | Tabulator) => string)))"}},resizeHeightWithParent:{defaultValue:null,description:"Selector of parent container (.className or #id). Tabulator Grid will resize height on container height change",name:"resizeHeightWithParent",required:!1,type:{name:"string"}},responsiveBreakpoint:{defaultValue:null,description:"Breakpoint for responsive design",name:"responsiveBreakpoint",required:!1,type:{name:"enum",value:[{value:'"xl"'},{value:'"md"'},{value:'"sm"'},{value:'"xs"'},{value:'"lg"'},{value:'"xxl"'}]}},language:{defaultValue:null,description:"Language",name:"language",required:!1,type:{name:"enum",value:[{value:'"ru"'},{value:'"en"'},{value:'"cn"'}]}},translation:{defaultValue:null,description:"Custom translation",name:"translation",required:!1,type:{name:"Partial<{ view: string; viewRecord: string; create: string; createNewRecord: string; edit: string; editRecord: string; clone: string; cloneRecord: string; delete: string; deleteRecord: string; select: string; ... 11 more ...; deleteSelectedRecordsQt: string; }>"}},onMenuVisibilityChanged:{defaultValue:null,description:"Fires when menu visibility status changed",name:"onMenuVisibilityChanged",required:!1,type:{name:"((isVisible: boolean, gridApi: IGridApi) => void)"}},onDataFetch:{defaultValue:null,description:"special callback used to fetch remote data. If not specified, the request will not be processed.",name:"onDataFetch",required:!1,type:{name:"((params: IRequestProps, gridApi: IGridApi) => IGridRowData[] | IGridDataSourcePromise)"}},onDataFetching:{defaultValue:null,description:"Called before a data fetching begins. If it returns false, then the fetch is canceled",name:"onDataFetching",required:!1,type:{name:"((url: string, params: IRequestProps, gridApi: IGridApi) => boolean)"}},onDataFetchResponse:{defaultValue:null,description:"Fires when a successful remote fetch request has been made. This callback can also be used to modify the received data before it is parsed by the table. If you use this callback it must return the data to be parsed by Tabulator, otherwise no data will be rendered.",name:"onDataFetchResponse",required:!1,type:{name:"((dataSet: IGridRowData[], params: IRequestProps, gridApi: IGridApi) => IGridRowData[])"}},onDataLoading:{defaultValue:null,description:"The callback is triggered when data set loading starts (regardless of whether it is an ajax request or a ready-made dataSet is passed)",name:"onDataLoading",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi) => void)"}},onDataLoaded:{defaultValue:null,description:"The callback is triggered when dataset changed or new dataSet is loaded into the table (regardless of whether it is an ajax request or a ready-made dataSet is passed)",name:"onDataLoaded",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi) => void)"}},onDataProcessed:{defaultValue:null,description:"The callback is triggered  after data has been processed and the table has been rendered.",name:"onDataProcessed",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi) => void)"}},onDataLoadError:{defaultValue:null,description:"Fires when the grid data loading failed",name:"onDataLoadError",required:!1,type:{name:"((message: string, code: number, gridApi: IGridApi) => void)"}},onDataChanged:{defaultValue:null,description:"Fires before the data change (the data set updated, rows added/deleted, etc.)",name:"onDataChanged",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi) => void)"}},onSelectionChange:{defaultValue:null,description:"Callback executed when selected rows change",name:"onSelectionChange",required:!1,type:{name:"((data: IGridRowData[], rows: RowComponent[], selectedRows: RowComponent[], deselectedRows: RowComponent[], gridApi: IGridApi) => void)"}},onDelete:{defaultValue:null,description:"Callback executed when selected rows delete",name:"onDelete",required:!1,type:{name:"((selectedRows: IGridRowData[], gridApi: IGridApi) => void | IGridDeletePromise)"}},height:{defaultValue:null,description:"Sets the height of the containing element, can be set to any valid height css value. If set to false (the default), the height of the table will resize to fit the table data.",name:"height",required:!1,type:{name:"string | number | false"}},width:{defaultValue:null,description:"Grid container width",name:"width",required:!1,type:{name:"string | number"}},containerClassName:{defaultValue:null,description:"Grid container class name",name:"containerClassName",required:!1,type:{name:"string"}},footerElement:{defaultValue:null,description:"Grid footer element",name:"footerElement",required:!1,type:{name:"ReactNode"}},columns:{defaultValue:null,description:"Grid columns",name:"columns",required:!0,type:{name:"ITabulatorColumn[]"}},maxHeight:{defaultValue:null,description:"Can be set to any valid CSS value. By setting this you can allow your table to expand to fit the data, but not overflow its parent element. When there are too many rows to fit in the available space, the vertical scroll bar will be shown. This has the added benefit of improving load times on larger tables",name:"maxHeight",required:!1,type:{name:"string | number"}},minHeight:{defaultValue:null,description:"With a variable table height you can set the minimum height of the table either defined in the min-height CSS property for the element or set it using the minHeight option in the table constructor, this can be set to any valid CSS value.",name:"minHeight",required:!1,type:{name:"string | number"}},renderVertical:{defaultValue:null,description:"",name:"renderVertical",required:!1,type:{name:"RenderMode"}},renderHorizontal:{defaultValue:null,description:"",name:"renderHorizontal",required:!1,type:{name:"RenderMode"}},rowHeight:{defaultValue:null,description:"",name:"rowHeight",required:!1,type:{name:"number"}},renderVerticalBuffer:{defaultValue:null,description:"Manually set the size of the virtual DOM buffer.",name:"renderVerticalBuffer",required:!1,type:{name:"number | boolean"}},placeholderHeaderFilter:{defaultValue:null,description:"",name:"placeholderHeaderFilter",required:!1,type:{name:"string | HTMLElement | ((this: TabulatorFull | Tabulator) => string)"}},keybindings:{defaultValue:null,description:"Keybinding configuration object.",name:"keybindings",required:!1,type:{name:"false | KeyBinding"}},reactiveData:{defaultValue:null,description:`The reactivity systems allow Tabulator to watch arrays and objects passed into the table for changes and then automatically update the table.

This approach means you no longer need to worry about calling a number of different functions on the table to make changes, you simply update the array or object you originally passed into the table and Tabulator will take care of the rest.

You can enable reactive data by setting the reactiveData option to true in the table constructor, and then passing your data array to the data option.

Once the table is built any changes to the array will automatically be replicated to the table without needing to call any functions on the table itself`,name:"reactiveData",required:!1,type:{name:"boolean"}},autoResize:{defaultValue:null,description:"Tabulator will automatically attempt to redraw the data contained in the table if the containing element for the table is resized. To disable this functionality, set the autoResize property to false.",name:"autoResize",required:!1,type:{name:"boolean"}},invalidOptionWarnings:{defaultValue:null,description:"Setting the invalidOptionWarnings option to false will disable console warning messages for invalid properties in the table constructor and column definition object.",name:"invalidOptionWarnings",required:!1,type:{name:"boolean"}},validationMode:{defaultValue:null,description:`There are now three different validation modes available to customize the validation experience:

blocking - if a user enters an invalid value while editing, they are blocked from leaving the cell until a valid value is entered (default)

highlight - if a user enters an invalid value, then the edit will complete as usual and they are allowed to exit the cell but a highlight is applied to the cell using the tabulator-validation-fail class

manual - no validation is automatically performed on edit, but it can be triggered by calling the validate function on the table or any Component Object`,name:"validationMode",required:!1,type:{name:"enum",value:[{value:'"blocking"'},{value:'"highlight"'},{value:'"manual"'}]}},textDirection:{defaultValue:null,description:"",name:"textDirection",required:!1,type:{name:"enum",value:[{value:'"ltr"'},{value:'"rtl"'},{value:'"auto"'}]}},rowHeader:{defaultValue:null,description:`Sometimes it can be useful to add a visual header to the start of a row.
The \`rowHeader\` option allows you to define a column definition for a stylized header column at the start of the row.

This can be great for adding row number, movable row handles or row selections, and keeps the controls visually separated from the table data.`,name:"rowHeader",required:!1,type:{name:"boolean | { formatter?: string; field?: string; headerSort?: boolean | undefined; hozAlign?: ColumnDefinitionAlign | undefined; ... 7 more ...; rowHandle?: boolean | undefined; } | undefined"}},editorEmptyValue:{defaultValue:null,description:"The value to set in the cell after the user has finished editing the cell.",name:"editorEmptyValue",required:!1,type:{name:"any"}},editorEmptyValueFunc:{defaultValue:null,description:"The function to determine if the value is empty.",name:"editorEmptyValueFunc",required:!1,type:{name:"((value: unknown) => boolean)"}},rowContextMenu:{defaultValue:null,description:"",name:"rowContextMenu",required:!1,type:{name:"RowContextMenuSignature"}},rowClickMenu:{defaultValue:null,description:"",name:"rowClickMenu",required:!1,type:{name:"RowContextMenuSignature"}},rowDblClickMenu:{defaultValue:null,description:"",name:"rowDblClickMenu",required:!1,type:{name:"RowContextMenuSignature"}},groupClickMenu:{defaultValue:null,description:"",name:"groupClickMenu",required:!1,type:{name:"GroupContextMenuSignature"}},groupDblClickMenu:{defaultValue:null,description:"",name:"groupDblClickMenu",required:!1,type:{name:"GroupContextMenuSignature"}},groupContextMenu:{defaultValue:null,description:"",name:"groupContextMenu",required:!1,type:{name:"MenuObject<GroupComponent>[]"}},popupContainer:{defaultValue:null,description:"",name:"popupContainer",required:!1,type:{name:"string | boolean | HTMLElement"}},groupClickPopup:{defaultValue:null,description:"",name:"groupClickPopup",required:!1,type:{name:"string"}},groupContextPopup:{defaultValue:null,description:"",name:"groupContextPopup",required:!1,type:{name:"string"}},groupDblPopup:{defaultValue:null,description:"",name:"groupDblPopup",required:!1,type:{name:"string"}},groupDblClickPopup:{defaultValue:null,description:"",name:"groupDblClickPopup",required:!1,type:{name:"string"}},rowClickPopup:{defaultValue:null,description:"",name:"rowClickPopup",required:!1,type:{name:"string"}},rowContextPopup:{defaultValue:null,description:"",name:"rowContextPopup",required:!1,type:{name:"string"}},rowDblClickPopup:{defaultValue:null,description:"",name:"rowDblClickPopup",required:!1,type:{name:"string"}},history:{defaultValue:null,description:"Enable user interaction history functionality",name:"history",required:!1,type:{name:"boolean"}},locale:{defaultValue:null,description:"You can set the current local in one of two ways. If you want to set it when the table is created, simply include the locale option in your Tabulator constructor. You can either pass in a string matching one of the language options you have defined, or pass in the boolean true which will cause Tabulator to auto-detect the browsers language settings from the navigator.language object.",name:"locale",required:!1,type:{name:"string | boolean"}},langs:{defaultValue:null,description:`You can store as many languages as you like, creating an object inside the langs object with a property of the locale code for that language. A list of locale codes can be found here.

At present there are three parts of the table that can be localized, the column headers, the header filter placeholder text and the pagination buttons. To localize the pagination buttons, create a pagination property inside your language object and give it the properties outlined below.

If you wish you can also localize column titles by adding a columns property to your language object. You should store a property of the field name of the column you wish to change, with a value of its title. Any fields that match this will use this title instead of the one provided by the column definition array.`,name:"langs",required:!1,type:{name:"any"}},downloadEncoder:{defaultValue:null,description:`The downloadEncoder callback allows you to intercept the download file data before the users is prompted to save the file.

The first argument of the function is the file contents returned from the downloader, the second argument is the suggested mime type for the output. The function is should return a blob of the file to be downloaded.`,name:"downloadEncoder",required:!1,type:{name:"((fileContents: any, mimeType: string) => false | Blob)"}},downloadConfig:{defaultValue:null,description:`By default Tabulator includes column headers, row groups and column calculations in the download output.

You can choose to remove column headers groups, row groups or column calculations from the output data by setting the values in the downloadConfig option in the table definition:`,name:"downloadConfig",required:!1,type:{name:"AdditionalExportOptions"}},downloadRowRange:{defaultValue:null,description:"By default, only the active rows (rows that have passed filtering) will be included in the download the downloadRowRange option takes a Row Range Lookup value and allows you to choose which rows are included in the download output.",name:"downloadRowRange",required:!1,type:{name:"enum",value:[{value:'"visible"'},{value:'"all"'},{value:'"selected"'},{value:'"active"'},{value:'"range"'}]}},downloadDataFormatter:{defaultValue:null,description:"If you want to make any changes to the table data before it is parsed into the download file you can pass a mutator function to the downloadDataFormatter callback.",name:"downloadDataFormatter",required:!1,type:{name:"((data: any) => any)"}},downloadReady:{defaultValue:null,description:`The downloadReady callback allows you to intercept the download file data before the users is prompted to save the file.

In order for the download to proceed the downloadReady callback is expected to return a blob of file to be downloaded.

If you would prefer to abort the download you can return false from this callback. This could be useful for example if you want to send the created file to a server via ajax rather than allowing the user to download the file.`,name:"downloadReady",required:!1,type:{name:"((fileContents: any, blob: Blob) => false | Blob)"}},autoColumns:{defaultValue:null,description:"If you set the autoColumns option to true, every time data is loaded into the table through the data option or through the setData function, Tabulator will examine the first row of the data and build columns to match that data.",name:"autoColumns",required:!1,type:{name:'boolean | "full"'}},autoColumnsDefinitions:{defaultValue:null,description:"",name:"autoColumnsDefinitions",required:!1,type:{name:"((columnDefinitions?: ColumnDefinition[]) => ColumnDefinition[]) | ColumnDefinition[] | Record<string, Partial<ColumnDefinition>>"}},layout:{defaultValue:null,description:"By default Tabulator will use the fitData layout mode, which will resize the tables columns to fit the data held in each column, unless you specify a width or minWidth in the column constructor. If the width of all columns exceeds the width of the containing element, a scroll bar will appear.",name:"layout",required:!1,type:{name:"enum",value:[{value:'"fitData"'},{value:'"fitColumns"'},{value:'"fitDataFill"'},{value:'"fitDataStretch"'},{value:'"fitDataTable"'}]}},layoutColumnsOnNewData:{defaultValue:null,description:`To keep the layout of the columns consistent, once the column widths have been set on the first data load (either from the data property in the constructor or the setData function) they will not be changed when new data is loaded.

If you would prefer that the column widths adjust to the data each time you load it into the table you can set the layoutColumnsOnNewData property to true.`,name:"layoutColumnsOnNewData",required:!1,type:{name:"boolean"}},responsiveLayout:{defaultValue:null,description:`Responsive layout will automatically hide/show columns to fit the width of the Tabulator element. This allows for clean rendering of tables on smaller mobile devices, showing important data while avoiding horizontal scroll bars. You can enable responsive layouts using the responsiveLayout option.

There are two responsive layout modes available:

hide - hide columns that no longer fit in the table
collapse - collapse columns that no longer fit on the table into a list under the row

Hide Extra Columns
By default, columns will be hidden from right to left as the width of the table decreases. You can choose exactly how columns are hidden using the responsive property in the column definition object.

When responsive layout is enabled, all columns are given a default responsive value of 1. The higher you set this value the sooner that column will be hidden as the table width decreases. If two columns have the same responsive value then they are hidden from right to left (as defined in the column definition array, ignoring user moving of the columns). If you set the value to 0 then the column will never be hidden regardless of how narrow the table gets.`,name:"responsiveLayout",required:!1,type:{name:'boolean | "hide" | "collapse"'}},responsiveLayoutCollapseStartOpen:{defaultValue:null,description:"Collapsed lists are displayed to the user by default, if you would prefer they start closed so the user can open them you can use the responsiveLayoutCollapseStartOpen option.",name:"responsiveLayoutCollapseStartOpen",required:!1,type:{name:"boolean"}},responsiveLayoutCollapseUseFormatters:{defaultValue:null,description:`By default any formatter set on the column is applied to the value that will appear in the list. while this works for most formatters it can cause issues with the progress formatter which relies on being inside a cell.

If you would like to disable column formatting in the collapsed list, you can use the responsiveLayoutCollapseUseFormatters option:`,name:"responsiveLayoutCollapseUseFormatters",required:!1,type:{name:"boolean"}},responsiveLayoutCollapseFormatter:{defaultValue:null,description:`If you set the responsiveLayout option to collapse the values from hidden columns will be displayed in a title/value list under the row.

In this mode an object containing the title of each hidden column and its value is generated and then used to generate a list displayed in a div .tabulator-responsive-collapse under the row data.

The inbuilt collapse formatter creates a table to neatly display the hidden columns. If you would like to format the data in your own way you can use the responsiveLayoutCollapseFormatter, it take an object of the column values as an argument and must return the HTML content of the div.

This function should return an empty string if there is no data to display.`,name:"responsiveLayoutCollapseFormatter",required:!1,type:{name:"((data: any[]) => any)"}},movableColumns:{defaultValue:null,description:"To allow the user to move columns along the table, set the movableColumns parameter in the options:",name:"movableColumns",required:!1,type:{name:"boolean"}},columnHeaderVertAlign:{defaultValue:null,description:"You can use the columnHeaderVertAlign option to set how the text in your column headers should be vertically.",name:"columnHeaderVertAlign",required:!1,type:{name:"enum",value:[{value:'"middle"'},{value:'"top"'},{value:'"bottom"'}]}},scrollToColumnPosition:{defaultValue:null,description:`The default ScrollTo position can be set using the scrollToColumnPosition option. It can take one of three possible values:

left - position column with its left edge at the left of the table (default)
center - position column with its left edge in the center of the table
right - position column with its right edge at the right of the table`,name:"scrollToColumnPosition",required:!1,type:{name:"enum",value:[{value:'"center"'},{value:'"left"'},{value:'"right"'},{value:'"middle"'}]}},scrollToColumnIfVisible:{defaultValue:null,description:`The default option for triggering a ScrollTo on a visible element can be set using the scrollToColumnIfVisible option. It can take a boolean value:

true - scroll to column, even if it is visible (default)
false - scroll to column, unless it is currently visible, then don't move`,name:"scrollToColumnIfVisible",required:!1,type:{name:"boolean"}},columnCalcs:{defaultValue:null,description:`By default column calculations are shown at the top and bottom of the table, unless row grouping is enabled, in which case they are shown at the top and bottom of each group.

The columnCalcs option lets you decided where the calculations should be displayed, it can take one of four values:

true - show calcs at top and bottom of the table, unless grouped, then show in groups (boolean, default)
both - show calcs at top and bottom of the table and show in groups
table - show calcs at top and bottom of the table only
group - show calcs in groups only`,name:"columnCalcs",required:!1,type:{name:'boolean | "both" | "table" | "group"'}},nestedFieldSeparator:{defaultValue:null,description:`If you need to use the . character as part of your field name, you can change the separator to any other character using the nestedFieldSeparator option
Set to false to disable nested data parsing`,name:"nestedFieldSeparator",required:!1,type:{name:"string | boolean"}},columnHeaderSortMulti:{defaultValue:null,description:"multiple or single column sorting",name:"columnHeaderSortMulti",required:!1,type:{name:"boolean"}},headerVisible:{defaultValue:null,description:"By setting the headerVisible option to false you can hide the column headers and present the table as a simple list if needed.",name:"headerVisible",required:!1,type:{name:"boolean"}},headerSort:{defaultValue:null,description:"The headerSort option can now be set in the table options to affect all columns as well as in column definitions.",name:"headerSort",required:!1,type:{name:"boolean"}},headerSortElement:{defaultValue:null,description:"",name:"headerSortElement",required:!1,type:{name:'string | ((column: ColumnComponent, dir: "none" | "asc" | "desc") => any)'}},columnDefaults:{defaultValue:null,description:"",name:"columnDefaults",required:!1,type:{name:"Partial<ColumnDefinition>"}},resizableColumnFit:{defaultValue:null,description:"If set to true, then when you resize a column its neighbouring column has the opposite resize applied to keep to total width of columns the same",name:"resizableColumnFit",required:!1,type:{name:"boolean"}},rowFormatter:{defaultValue:null,description:`Tabulator also allows you to define a row level formatter using the rowFormatter option. this lets you alter each row of the table based on the data it contains.
The function accepts one argument, the RowComponent for the row being formatted.`,name:"rowFormatter",required:!1,type:{name:"((row: RowComponent) => any)"}},rowFormatterPrint:{defaultValue:null,description:"When printing you may want to apply a different formatter may want to apply a different formatter from the one usually used to format the row.",name:"rowFormatterPrint",required:!1,type:{name:"false | ((row: RowComponent) => any)"}},rowFormatterHtmlOutput:{defaultValue:null,description:"When the getHtml function is called you may want to apply a different formatter may want to apply a different formatter from the one usually used to format the row",name:"rowFormatterHtmlOutput",required:!1,type:{name:"false | ((row: RowComponent) => any)"}},rowFormatterClipboard:{defaultValue:null,description:"When copying to the clipboard you may want to apply a different formatter may want to apply a different formatter from the one usually used to format the row. You can now do this using the rowFormatterClipboard table option, which takes the same inputs as the standard rowFormatter property. Passing a value of false into the formatter prevent the default row formatter from being run when the table is copied to the clipboard.",name:"rowFormatterClipboard",required:!1,type:{name:"false | ((row: RowComponent) => any)"}},addRowPos:{defaultValue:null,description:'The position in the table for new rows to be added, "bottom" or "top".',name:"addRowPos",required:!1,type:{name:"enum",value:[{value:'"top"'},{value:'"bottom"'}]}},selectable:{defaultValue:null,description:`The selectable option can take one of a several values:
false - selectable rows are disabled
true - selectable rows are enabled, and you can select as many as you want
integer - any integer value, this sets the maximum number of rows that can be selected (when the maximum number of selected rows is exceeded, the first selected row will be deselected to allow the next row to be selected).
"highlight" (default) - rows have the same hover stylings as selectable rows but do not change state when clicked. This is great for when you want to show that a row is clickable but don't want it to be selectable.
@deprecated Use selectableRows instead`,name:"selectable",required:!1,type:{name:'number | boolean | "highlight"'}},selectableRows:{defaultValue:null,description:`The selectableRows option can take one of a several values:

- false - selectable rows are disabled
- true - selectable rows are enabled, and you can select as many as you want
- integer - any integer value, this sets the maximum number of rows that can be selected (when the maximum number of selected rows is exceeded, the first selected row will be deselected to allow the next row to be selected).
- "highlight" (default) - rows have the same hover stylings as selectable rows but do not change state when clicked. This is great for when you want to show that a row is clickable but don't want it to be selectable.`,name:"selectableRows",required:!1,type:{name:'number | boolean | "highlight"'}},selectableRange:{defaultValue:null,description:`The selectableRange option can take one of a several values:

- false - range selection is disabled
- true - range selection is enabled, and you can add as many ranges as you want
- integer - any integer value, this sets the maximum number of ranges that can be selected (when the maximum
          number of ranges is exceeded, the first selected range will be deselected to allow the next range to be selected).`,name:"selectableRange",required:!1,type:{name:"number | boolean"}},selectableRangeColumns:{defaultValue:null,description:`By default you can only select ranges by selecting cells on the table. If you would like to allow the user to
select all cells in a column by clicking on the column header, then you can set the selectableRangeColumns option to true`,name:"selectableRangeColumns",required:!1,type:{name:"boolean"}},selectableRangeRows:{defaultValue:null,description:`By default you can only select ranges by selecting cells on the table. If you would like to allow the user to
select all cells in row by clicking on the row header, then you can set the selectableRangeColumns option to true`,name:"selectableRangeRows",required:!1,type:{name:"boolean"}},selectableRangeClearCells:{defaultValue:null,description:`If you want the user to be able to clear the values for all cells in the active range by pressing the backspace
or delete keys, then you can enable this behavior using the selectableRangeClearCells option:
@example var table = new Tabulator("#example-table", {
    selectableRangeClearCells:true,
});`,name:"selectableRangeClearCells",required:!1,type:{name:"boolean"}},selectableRangeClearCellsValue:{defaultValue:null,description:`By default the value of each cell in the range is set to undefined when this option is enabled and the user
presses the backspace or delete keys. You can change the value the cells are set to using the
selectableRangeClearCellsValue option
@example var table = new Tabulator("#example-table", {
    selectableRangeClearCellsValue: "", //clear cells by setting value to an empty string
});`,name:"selectableRangeClearCellsValue",required:!1,type:{name:"unknown"}},selectableRangeMode:{defaultValue:null,description:`By default you can select a range of rows by holding down the shift key and click dragging over a number of rows to toggle the selected state state of all rows the cursor passes over.

If you would prefer to select a range of row by clicking on the first row then holding down shift and clicking on the end row then you can achieve this by setting the selectableRangeMode to click
@deprecated Use selectableRowsRangeMode instead`,name:"selectableRangeMode",required:!1,type:{name:"enum",value:[{value:'"click"'}]}},selectableRowsRangeMode:{defaultValue:null,description:`By default you can select a range of rows by holding down the shift key and click dragging over a number of rows
to toggle the selected state state of all rows the cursor passes over.

If you would prefer to select a range of row by clicking on the first row then holding down shift and clicking
on the end row then you can achieve this by setting the selectableRowsRangeMode to click.
@example var table = new Tabulator("#example-table", {
    selectableRowsRangeMode:"click",
});`,name:"selectableRowsRangeMode",required:!1,type:{name:"enum",value:[{value:'"click"'}]}},selectableRollingSelection:{defaultValue:null,description:`By default, row selection works on a rolling basis, if you set the selectable option to a numeric value then when you select past this number of rows, the first row to be selected will be deselected. If you want to disable this behavior and instead prevent selection of new rows once the limit is reached you can set the selectableRollingSelection option to false.
@deprecated Use selectableRowsRollingSelection instead`,name:"selectableRollingSelection",required:!1,type:{name:"boolean"}},selectableRowsRollingSelection:{defaultValue:null,description:`By default, row selection works on a rolling basis, if you set the selectableRows option to a numeric value then
when you select past this number of rows, the first row to be selected will be deselected. If you want to
disable this behavior and instead prevent selection of new rows once the limit is reached you can set the
selectableRowsRollingSelection option to false.
@example var table = new Tabulator("#example-table", {
    selectableRows: 5,
    selectableRowsRollingSelection:false, // disable rolling selection
});`,name:"selectableRowsRollingSelection",required:!1,type:{name:"boolean"}},selectablePersistence:{defaultValue:null,description:`By default Tabulator will maintain selected rows when the table is filtered, sorted or paginated (but NOT when the setData function is used). If you want the selected rows to be cleared whenever the table view is updated then set the selectablePersistence option to false.
@deprecated Use selectableRowsPersistence instead`,name:"selectablePersistence",required:!1,type:{name:"boolean"}},selectableRowsPersistence:{defaultValue:null,description:`By default Tabulator will maintain selected rows when the table is filtered, sorted or paginated (but NOT when
the setData function is used). If you want the selected rows to be cleared whenever the table view is updated
then set the selectableRowsPersistence option to false.
@example var table = new Tabulator("#example-table", {
    selectableRows: true,
    selectableRowsPersistence: false, // disable selection persistence
});`,name:"selectableRowsPersistence",required:!1,type:{name:"boolean"}},selectableCheck:{defaultValue:null,description:"You many want to exclude certain rows from being selected. The selectableCheck options allows you to pass a function to check if the current row should be selectable, returning true will allow row selection, false will result in nothing happening. The function should accept a RowComponent as its first argument.",name:"selectableCheck",required:!1,type:{name:"((row: RowComponent) => boolean)"}},movableRows:{defaultValue:null,description:"To allow the user to move rows up and down the table, set the movableRows parameter in the options:",name:"movableRows",required:!1,type:{name:"boolean"}},movableRowsConnectedTables:{defaultValue:null,description:"Tabulator also allows you to move rows between tables. To enable this you should supply either a valid CSS selector string a DOM node for the table or the Tabulator object for the table to the movableRowsConnectedTables option. if you want to connect to multiple tables then you can pass in an array of values to this option.",name:"movableRowsConnectedTables",required:!1,type:{name:"string | string[] | HTMLElement | HTMLElement[]"}},movableRowsSender:{defaultValue:null,description:`The movableRowsSender option should be set on the sending table, and sets the action that should be taken after the row has been successfully dropped into the receiving table.
There are several inbuilt sender functions:

- false - do nothing(default)
- delete - deletes the row from the table
You can also pass a callback to the movableRowsSender option for custom sender functionality`,name:"movableRowsSender",required:!1,type:{name:'false | "delete" | ((fromRow: RowComponent, toRow: RowComponent, toTable: Tabulator) => any)'}},movableRowsReceiver:{defaultValue:null,description:`The movableRowsReceiver option should be set on the receiving tables, and sets the action that should be taken when the row is dropped into the table.
There are several inbuilt receiver functions:

- insert - inserts row next to the row it was dropped on, if not dropped on a row it is added to the table (default)
- add - adds row to the table
- update - updates the row it is dropped on with the sent rows data
- replace - replaces the row it is dropped on with the sent row`,name:"movableRowsReceiver",required:!1,type:{name:'"update" | "insert" | "add" | "replace" | ((fromRow: RowComponent, toRow: RowComponent, fromTable: Tabulator) => any)'}},movableRowsConnectedElements:{defaultValue:null,description:"",name:"movableRowsConnectedElements",required:!1,type:{name:"string | HTMLElement"}},resizableRowGuide:{defaultValue:null,description:"Allows the user to control the height of rows in the table by dragging the bottom border of the row.\nThese guides will only appear on columns with the `resizable` option enabled in their column definition.",name:"resizableRowGuide",required:!1,type:{name:"boolean"}},resizableColumnGuide:{defaultValue:null,description:"Allows the user to control the height of columns in the table by dragging the border of the column.\nThese guides will only appear if the `resizableRows` option is enabled.",name:"resizableColumnGuide",required:!1,type:{name:"boolean"}},scrollToRowPosition:{defaultValue:null,description:`The default ScrollTo position can be set using the scrollToRowPosition option. It can take one of four possible values:

top - position row with its top edge at the top of the table (default)
center - position row with its top edge in the center of the table
bottom - position row with its bottom edge at the bottom of the table
nearest - position row on the edge of the table it is closest to`,name:"scrollToRowPosition",required:!1,type:{name:"enum",value:[{value:'"center"'},{value:'"top"'},{value:'"bottom"'},{value:'"nearest"'}]}},scrollToRowIfVisible:{defaultValue:null,description:`The default option for triggering a ScrollTo on a visible element can be set using the scrollToRowIfVisible option. It can take a boolean value:

true - scroll to row, even if it is visible (default)
false - scroll to row, unless it is currently visible, then don't move`,name:"scrollToRowIfVisible",required:!1,type:{name:"boolean"}},tabEndNewRow:{defaultValue:null,description:"Allows you to specify the behavior when the user tabs from the last editable cell on the last row of the table.",name:"tabEndNewRow",required:!1,type:{name:"boolean | JSONRecord | ((row: RowComponent) => any)"}},frozenRowsField:{defaultValue:null,description:"",name:"frozenRowsField",required:!1,type:{name:"string"}},frozenRows:{defaultValue:null,description:"Freeze rows of data",name:"frozenRows",required:!1,type:{name:"number | string[] | ((row: RowComponent) => boolean)"}},editTriggerEvent:{defaultValue:null,description:`The editTriggerEvent option lets you choose which type of interaction event will trigger an edit on a cell.
@example var table = new Tabulator("#example-table", {
    editTriggerEvent:"dblclick", // trigger edit on double click
});

This option can take one of three values:

- focus - trigger edit when the cell has focus (default)
- click - trigger edit on single click on cell
- dblclick - trigger edit on double click on cell

This option does not affect navigation behavior, cells edits will still be triggered when they are navigated to
through arrow keys or tabs.`,name:"editTriggerEvent",required:!1,type:{name:"enum",value:[{value:'"focus"'},{value:'"click"'},{value:'"dblclick"'}]}},index:{defaultValue:null,description:"A unique index value should be present for each row of data if you want to be able to programmatically alter that data at a later point, this should be either numeric or a string. By default Tabulator will look for this value in the id field for the data. If you wish to use a different field as the index, set this using the index option parameter.",name:"index",required:!1,type:{name:"string | number"}},importFormat:{defaultValue:null,description:"",name:"importFormat",required:!1,type:{name:'"array" | "csv" | "json" | ((fileContents: string) => unknown[])'}},importReader:{defaultValue:null,description:"By default Tabulator will read in the file as plain text, which is the format used by all the built in importers. If you need to read the file data in a different format then you can use the importReader option to instruct the file reader to read in the file in a different format.",name:"importReader",required:!1,type:{name:"enum",value:[{value:'"text"'},{value:'"binary"'},{value:'"buffer"'},{value:'"url"'}]}},autoTables:{defaultValue:null,description:"",name:"autoTables",required:!1,type:{name:"boolean"}},ajaxParams:{defaultValue:null,description:"Parameters to be passed to remote Ajax data loading request.",name:"ajaxParams",required:!1,type:{name:"{}"}},ajaxConfig:{defaultValue:null,description:"The HTTP request type for Ajax requests or config object for the request.",name:"ajaxConfig",required:!1,type:{name:"HttpMethod | AjaxConfig"}},ajaxContentType:{defaultValue:null,description:`When using a request method other than "GET" Tabulator will send any parameters with a content type of form data. You can change the content type with the ajaxContentType option. This will ensure parameters are sent in the format you expect, with the correct headers. * * The ajaxContentType option can take one of two values:
"form" - send parameters as form data (default option)
"json" - send parameters as JSON encoded string
If you want to use a custom content type then you can pass a content type formatter object into the ajaxContentType option. this object must have two properties, the headers property should contain all headers that should be sent with the request and the body property should contain a function that returns the body content of the request`,name:"ajaxContentType",required:!1,type:{name:'"form" | "json" | AjaxContentType'}},ajaxURLGenerator:{defaultValue:null,description:`If you need more control over the url of the request that you can get from the ajaxURL and ajaxParams properties, the you can use the ajaxURLGenerator property to pass in a callback that will generate the URL for you.

The callback should return a string representing the URL to be requested.`,name:"ajaxURLGenerator",required:!1,type:{name:"((url: string, config: any, params: any) => string)"}},ajaxFiltering:{defaultValue:null,description:"Send filter config to server instead of processing locally",name:"ajaxFiltering",required:!1,type:{name:"boolean"}},ajaxSorting:{defaultValue:null,description:"Send sorter config to server instead of processing locally",name:"ajaxSorting",required:!1,type:{name:"boolean"}},progressiveLoad:{defaultValue:null,description:`If you are loading a lot of data from a remote source into your table in one go, it can sometimes take a long time for the server to return the request, which can slow down the user experience.

To speed things up in this situation Tabulator has a progressive load mode, this uses the pagination module to make a series of requests for part of the data set, one at a time, appending it to the table as the data arrives. This mode can be enable using the ajaxProgressiveLoad option. No pagination controls will be visible on screen, it just reuses the functionality of the pagination module to sequentially load the data.

With this mode enabled, all of the settings outlined in the Ajax Documentation are still available

There are two different progressive loading modes, to give you a choice of how data is loaded into the table.`,name:"progressiveLoad",required:!1,type:{name:"enum",value:[{value:'"load"'},{value:'"scroll"'}]}},progressiveLoadDelay:{defaultValue:null,description:"By default tabulator will make the requests to fill the table as quickly as possible. On some servers these repeats requests from the same client may trigger rate limiting or security systems. In this case you can use the ajaxProgressiveLoadDelay option to add a delay in milliseconds between each page request.",name:"progressiveLoadDelay",required:!1,type:{name:"number"}},progressiveLoadScrollMargin:{defaultValue:null,description:"The ajaxProgressiveLoadScrollMargin property determines how close to the bottom of the table in pixels, the scroll bar must be before the next page worth of data is loaded, by default it is set to twice the height of the table.",name:"progressiveLoadScrollMargin",required:!1,type:{name:"number"}},ajaxLoader:{defaultValue:null,description:"Show loader while data is loading, can also take a function that must return a boolean.",name:"ajaxLoader",required:!1,type:{name:"boolean | (() => boolean)"}},ajaxLoaderLoading:{defaultValue:null,description:"html for loader element.",name:"ajaxLoaderLoading",required:!1,type:{name:"string"}},ajaxLoaderError:{defaultValue:null,description:"html for the loader element in the event of an error.",name:"ajaxLoaderError",required:!1,type:{name:"string"}},ajaxRequesting:{defaultValue:null,description:"The ajaxRequesting callback is triggered when ever an ajax request is made.",name:"ajaxRequesting",required:!1,type:{name:"((url: string, params: any) => boolean)"}},dataLoader:{defaultValue:null,description:"",name:"dataLoader",required:!1,type:{name:"boolean"}},dataLoaderLoading:{defaultValue:null,description:"",name:"dataLoaderLoading",required:!1,type:{name:"string | HTMLElement"}},dataLoaderError:{defaultValue:null,description:"",name:"dataLoaderError",required:!1,type:{name:"string"}},dataLoaderErrorTimeout:{defaultValue:null,description:"",name:"dataLoaderErrorTimeout",required:!1,type:{name:"number"}},sortMode:{defaultValue:null,description:"",name:"sortMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},filterMode:{defaultValue:null,description:"",name:"filterMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},initialSort:{defaultValue:null,description:"Array of sorters to be applied on load.",name:"initialSort",required:!1,type:{name:"Sorter[]"}},sortOrderReverse:{defaultValue:null,description:"reverse the order that multiple sorters are applied to the table.",name:"sortOrderReverse",required:!1,type:{name:"boolean"}},headerSortClickElement:{defaultValue:null,description:"",name:"headerSortClickElement",required:!1,type:{name:"enum",value:[{value:'"icon"'},{value:'"header"'}]}},initialFilter:{defaultValue:null,description:"Array of filters to be applied on load.",name:"initialFilter",required:!1,type:{name:"Filter[]"}},initialHeaderFilter:{defaultValue:null,description:"array of initial values for header filters.",name:"initialHeaderFilter",required:!1,type:{name:'Pick<Filter, "value" | "field">[]'}},headerFilterLiveFilterDelay:{defaultValue:null,description:"When using real time header filtering, Tabulator will wait 300 milliseconds after a keystroke before triggering the filter. You can customize this delay by using the headerFilterLiveFilterDelay table setup option.",name:"headerFilterLiveFilterDelay",required:!1,type:{name:"number"}},groupBy:{defaultValue:null,description:"String/function to select field to group rows by",name:"groupBy",required:!1,type:{name:"GroupArg"}},groupValues:{defaultValue:null,description:`By default Tabulator will create groups for rows based on the values contained in the row data. if you want to explicitly define which field values groups should be created for at each level, you can use the groupValues option.

This option takes an array of value arrays, each item in the first array should be a list of acceptable field values for groups at that level`,name:"groupValues",required:!1,type:{name:"GroupValuesArg"}},groupHeader:{defaultValue:null,description:"You can use the setGroupHeader function to change the header generation function for each group. This function has one argument and takes the same values as passed to the groupHeader setup option.",name:"groupHeader",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},groupHeaderPrint:{defaultValue:null,description:"When printing you may want to apply a different group header from the one usually used in the table. You can now do this using the groupHeaderPrint table option, which takes the same inputs as the standard groupHeader property.",name:"groupHeaderPrint",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},groupStartOpen:{defaultValue:null,description:`You can set the default open state of groups using the groupStartOpen property* * This can take one of three possible values:

true - all groups start open (default value)
false - all groups start closed
function() - a callback to decide if a group should start open or closed
Group Open Function
If you want to decide on a group by group basis which should start open or closed then you can pass a function to the groupStartOpen property. This should return true if the group should start open or false if the group should start closed.`,name:"groupStartOpen",required:!1,type:{name:"boolean | boolean[] | ((value: any, count: number, data: any, group: GroupComponent) => boolean) | (boolean | ((value: any, count: number, data: any, group: GroupComponent) => boolean))[]"}},groupToggleElement:{defaultValue:null,description:`By default Tabulator allows users to toggle a group open or closed by clicking on the arrow icon in the left of the group header. If you would prefer a different behavior you can use the groupToggleElement option to choose a different option:* * The option can take one of three values:
arrow - toggle group on arrow element click
header - toggle group on click anywhere on the group header element
false - prevent clicking anywhere in the group toggling the group`,name:"groupToggleElement",required:!1,type:{name:'false | "header" | "arrow"'}},groupClosedShowCalcs:{defaultValue:null,description:"show/hide column calculations when group is closed.",name:"groupClosedShowCalcs",required:!1,type:{name:"boolean"}},groupUpdateOnCellEdit:{defaultValue:null,description:"",name:"groupUpdateOnCellEdit",required:!1,type:{name:"boolean"}},pagination:{defaultValue:null,description:"",name:"pagination",required:!1,type:{name:"boolean"}},paginationMode:{defaultValue:null,description:"",name:"paginationMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},paginationSize:{defaultValue:null,description:"Set the number of rows in each page.",name:"paginationSize",required:!1,type:{name:"number"}},paginationSizeSelector:{defaultValue:null,description:`Setting this option to true will cause Tabulator to create a list of page size options, that are multiples of the current page size. In the example below, the list will have the values of 5, 10, 15 and 20.

 When using the page size selector like this, if you use the setPageSize function to set the page size to a value not in the list, the list will be regenerated using the new page size as the starting valuer`,name:"paginationSizeSelector",required:!1,type:{name:"true | any[] | number[]"}},paginationElement:{defaultValue:null,description:"By default the pagination controls are added to the footer of the table. If you wish the controls to be created in another element pass a DOM node or a CSS selector for that element to the paginationElement option.",name:"paginationElement",required:!1,type:{name:"string | HTMLElement"}},dataReceiveParams:{defaultValue:null,description:`Lookup list to link expected data fields from the server to their function
\`\`\`typescript
default: {
  "current_page": "current_page",
  "last_page": "last_page",
  "data": "data",
  }
\`\`\``,name:"dataReceiveParams",required:!1,type:{name:"Record<string, string>"}},dataSendParams:{defaultValue:null,description:`Lookup list to link fields expected by the server to their function
\`\`\`typescript
default: {
  "page": "page",
  "size": "size",
  "sorters": "sorters",
  "filters": "filters",
}
\`\`\``,name:"dataSendParams",required:!1,type:{name:"Record<string, string>"}},paginationAddRow:{defaultValue:null,description:`When using the addRow function on a paginated table, rows will be added relative to the current page (ie to the top or bottom of the current page), with overflowing rows being shifted onto the next page.

If you would prefer rows to be added relative to the table (firs/last page) then you can use the paginationAddRow option. it can take one of two values:

page - add rows relative to current page (default)
table - add rows relative to the table`,name:"paginationAddRow",required:!1,type:{name:"enum",value:[{value:'"page"'},{value:'"table"'}]}},paginationCounter:{defaultValue:null,description:`You can choose to display a pagination counter in the bottom left of the footer that shows a summary of the current number of rows shown out of the total.
If you want to have a fully customized counter, then you can pass a function to the paginationCounter option

The formatter function accepts 5 arguments:

pageSize - Number of rows shown per page
currentRow - First visible row position
currentPage - Current page
totalRows - Total rows in table
totalPages - Total pages in table
The function must return the contents of the counter, either the text value of the counter, valid HTML or a DOM node`,name:"paginationCounter",required:!1,type:{name:'"rows" | "pages" | ((pageSize: number, currentRow: number, currentPage: number, totalRows: number, totalPages: number) => string | HTMLElement)'}},paginationCounterElement:{defaultValue:null,description:"By default the counter will be displayed in the left of the table footer. If you would like it displayed in another element pass a DOM node or a CSS selector for that element.",name:"paginationCounterElement",required:!1,type:{name:"string | HTMLElement"}},paginationButtonCount:{defaultValue:null,description:"The number of pagination page buttons shown in the footer using the paginationButtonCount option. By default this has a value of 5.",name:"paginationButtonCount",required:!1,type:{name:"number"}},paginationInitialPage:{defaultValue:null,description:"Specify that a specific page should be loaded when the table first load.",name:"paginationInitialPage",required:!1,type:{name:"number"}},persistenceID:{defaultValue:null,description:"ID tag used to identify persistent storage information.",name:"persistenceID",required:!1,type:{name:"string"}},persistenceMode:{defaultValue:null,description:`Persistence information can either be stored in a cookie or in the localStorage object, you can use the persistenceMode to choose which. It can take three possible values:

 local - (string) Store the persistence information in the localStorage object
 cookie - (string) Store the persistence information in a cookie
 true - (boolean) check if localStorage is available and store persistence information, otherwise store in cookie (Default option)`,name:"persistenceMode",required:!1,type:{name:'true | "local" | "cookie"'}},persistentLayout:{defaultValue:null,description:"Enable persistent storage of column layout information.",name:"persistentLayout",required:!1,type:{name:"boolean"}},persistentSort:{defaultValue:null,description:"You can ensure the data sorting is stored for the next page load by setting the persistentSort option to true.",name:"persistentSort",required:!1,type:{name:"boolean"}},persistentFilter:{defaultValue:null,description:"You can ensure the data filtering is stored for the next page load by setting the persistentFilter option to true.",name:"persistentFilter",required:!1,type:{name:"boolean"}},persistence:{defaultValue:null,description:"By setting the persistence property to true the table will persist the sort, filter, group (groupBy, groupStartOpen, groupHeader), pagination (paginationSize), and column (title, width, visibility, order) configuration of the table.",name:"persistence",required:!1,type:{name:"true | PersistenceOptions"}},persistenceWriterFunc:{defaultValue:null,description:"The persistenceWriterFunc function will receive three arguments, the persistance id of the table, the type of data to be written and an object or array representing the data",name:"persistenceWriterFunc",required:!1,type:{name:"((id: string, type: keyof PersistenceOptions, data: any) => any)"}},persistenceReaderFunc:{defaultValue:null,description:"The persistenceReaderFunc function will receive two arguments, the persistance id of the table, and the type of data to be written. This function must synchronously return the data in the format in which it was passed to the persistenceWriterFunc function. It should return a value of false if no data was present.",name:"persistenceReaderFunc",required:!1,type:{name:"((id: string, type: keyof PersistenceOptions) => any)"}},clipboard:{defaultValue:null,description:`You can enable clipboard functionality using the clipboard config option. It can take one of four possible values:
    true - enable clipboard copy and paste
    "copy" - enable only copy functionality
    "paste" - enable only paste functionality
    false - disable all clipboard functionality (default)`,name:"clipboard",required:!1,type:{name:'boolean | "copy" | "paste"'}},clipboardCopyRowRange:{defaultValue:null,description:"The clipboardCopyRowRange option takes a Row Range Lookup value and allows you to choose which rows are included in the clipboard output:",name:"clipboardCopyRowRange",required:!1,type:{name:"enum",value:[{value:'"visible"'},{value:'"all"'},{value:'"selected"'},{value:'"active"'},{value:'"range"'}]}},clipboardCopyFormatter:{defaultValue:null,description:'You can alter the finished output to the clipboard using the clipboardCopyFormatter callback. The callback function receives two arguments, the first is a string representing the type of content to be formatted (either "plain" or "html" depending on the type of data entering the clipboard). The second argument is the string that is about to be inserted into the clipboard. The function and should return a string that will be inserted into the clipboard.',name:"clipboardCopyFormatter",required:!1,type:{name:'"table" | ((type: "plain" | "html", output: string) => string)'}},clipboardCopyHeader:{defaultValue:null,description:"By default Tabulator will include the column header titles in any clipboard data, this can be turned off by passing a value of false to the clipboardCopyHeader property:",name:"clipboardCopyHeader",required:!1,type:{name:"boolean"}},clipboardPasteParser:{defaultValue:null,description:`Tabulator has one built in paste parser, that is designed to take a table formatted text string from the clipboard and turn it into row data. it breaks the data into rows on a newline character \\n and breaks the rows down to columns on a tab character \\t.
It will then attempt to work out which columns in the data correspond to columns in the table. It tries three different ways to achieve this. First it checks the values of all columns in the first row of data to see if they match the titles of columns in the table. If any of the columns don't match it then tries the same approach but with the column fields. If either of those options match, Tabulator will map those columns to the incoming data and import it into rows. If there is no match then Tabulator will assume the columns in the data are in the same order as the visible columns in the table and import them that way.

The inbuilt parser will reject any clipboard data that does not contain at least one row and two columns, in that case the clipboardPasteError will be triggered.

If you extend the clipboard module to add your own parser, you can set it to be used as default with the clipboardPasteParser property.
Built-in parsers are "table" and "range".`,name:"clipboardPasteParser",required:!1,type:{name:"string | ((clipboard: any) => any[])"}},clipboardPasteAction:{defaultValue:null,description:`Once the data has been parsed into row data, it will be passed to a paste action to be added to the table. There are three inbuilt paste actions:

insert - Inserts data into the table using the addRows function (default)
update - Updates data in the table using the updateOrAddData function
replace - replaces all data in the table using the setData function`,name:"clipboardPasteAction",required:!1,type:{name:"enum",value:[{value:'"update"'},{value:'"range"'},{value:'"insert"'},{value:'"replace"'}]}},clipboardCopyStyled:{defaultValue:null,description:`By default Tabulator will copy some of the tables styling along with the data to give a better visual appearance when pasted into other documents.

If you want to only copy the un-styled data then you should set the clipboardCopyStyled option to false in the table options object:`,name:"clipboardCopyStyled",required:!1,type:{name:"boolean"}},clipboardCopyConfig:{defaultValue:null,description:`By default Tabulator includes column headers, row groups and column calculations in the clipboard output.

You can choose to remove column headers groups, row groups or column calculations from the output data by setting the values in the clipboardCopyConfig option in the table definition:`,name:"clipboardCopyConfig",required:!1,type:{name:"boolean | AdditionalExportOptions"}},groupHeaderClipboard:{defaultValue:null,description:"When copying to clipboard you may want to apply a different group header from the one usually used in the table. You can now do this using the groupHeaderClipboard table option, which takes the same inputs as the standard groupHeader property.",name:"groupHeaderClipboard",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},groupHeaderHtmlOutput:{defaultValue:null,description:"When the getHtml function is called you may want to apply a different group header from the one usually used in the table. You can now do this using the groupHeaderHtmlOutput table option, which takes the same inputs as the standard groupHeader property.",name:"groupHeaderHtmlOutput",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},dataTree:{defaultValue:null,description:"To enable data trees in your table, set the dataTree property to true in your table constructor:",name:"dataTree",required:!1,type:{name:"boolean"}},dataTreeElementColumn:{defaultValue:null,description:"By default the toggle element will be inserted into the first column on the table. If you want the toggle element to be inserted in a different column you can pass the field name of the column to the dataTreeElementColumn setup option.",name:"dataTreeElementColumn",required:!1,type:{name:"string | boolean"}},dataTreeBranchElement:{defaultValue:null,description:"Show tree branch icon.",name:"dataTreeBranchElement",required:!1,type:{name:"string | boolean"}},dataTreeChildIndent:{defaultValue:null,description:"Tree level indent in pixels",name:"dataTreeChildIndent",required:!1,type:{name:"number"}},dataTreeChildField:{defaultValue:null,description:"By default Tabulator will look for child rows in the _children field of a row data object. You can change this to look in a different field using the dataTreeChildField property in your table constructor:",name:"dataTreeChildField",required:!1,type:{name:"string"}},dataTreeCollapseElement:{defaultValue:null,description:`The toggle button that allows users to collapse and expand the column can be customized to meet your needs. There are two options, dataTreeExpandElement and dataTreeCollapseElement, that can be set to replace the default toggle elements with your own.

Both options can take either an html string representing the contents of the toggle element`,name:"dataTreeCollapseElement",required:!1,type:{name:"string | boolean | HTMLElement"}},dataTreeExpandElement:{defaultValue:null,description:"The toggle button that allows users to expand the column.",name:"dataTreeExpandElement",required:!1,type:{name:"string | boolean | HTMLElement"}},dataTreeStartExpanded:{defaultValue:null,description:`By default all nodes on the tree will start collapsed, you can customize the initial expansion state of the tree using the dataTreeStartExpanded option.*
This option can take one of three possible value types, either a boolean to indicate whether all nodes should start expanded or collapsed:`,name:"dataTreeStartExpanded",required:!1,type:{name:"boolean | boolean[] | ((row: RowComponent, level: number) => boolean)"}},dataTreeSelectPropagate:{defaultValue:null,description:"Propagate selection events from parent rows to children.",name:"dataTreeSelectPropagate",required:!1,type:{name:"boolean"}},dataTreeFilter:{defaultValue:null,description:"",name:"dataTreeFilter",required:!1,type:{name:"boolean"}},dataTreeSort:{defaultValue:null,description:"",name:"dataTreeSort",required:!1,type:{name:"boolean"}},dataTreeChildColumnCalcs:{defaultValue:null,description:`When you are using the dataTree option with your table, the column calculations will by default only use the data for the top level rows and will ignore any children.
To include child rows in the column calculations set the dataTreeChildColumnCalcs option to true in the table constructor.`,name:"dataTreeChildColumnCalcs",required:!1,type:{name:"boolean"}},invalidOptionWarning:{defaultValue:null,description:"",name:"invalidOptionWarning",required:!1,type:{name:"boolean"}},debugInvalidOptions:{defaultValue:null,description:"Enabled by default this will provide a console warning if you are trying to set an option on the table that does not exist. With the new optional modular structure this is particularly valuable as it will prompt you if you are trying to use an option for a module that has not been installed",name:"debugInvalidOptions",required:!1,type:{name:"boolean"}},debugInitialization:{defaultValue:null,description:"Enabled by default this will provide a console warning if you try and call a function on the table before it has been initialized.",name:"debugInitialization",required:!1,type:{name:"boolean"}},debugEventsExternal:{defaultValue:null,description:"The debugEventsExternal option will create a console log for every external event that is fired so you can gain an understanding of which events you should be binding to.",name:"debugEventsExternal",required:!1,type:{name:"boolean"}},debugEventsInternal:{defaultValue:null,description:"The debugEventsInternal option will create a console log for every internal event that is fired so you can gain an understanding of which events you should be subscribing to in your modules.",name:"debugEventsInternal",required:!1,type:{name:"boolean"}},debugInvalidComponentFuncs:{defaultValue:null,description:"Disable component function warnings",name:"debugInvalidComponentFuncs",required:!1,type:{name:"boolean"}},debugDeprecation:{defaultValue:null,description:"Disable deprecation warnings",name:"debugDeprecation",required:!1,type:{name:"boolean"}},htmlOutputConfig:{defaultValue:null,description:"",name:"htmlOutputConfig",required:!1,type:{name:"AdditionalExportOptions"}},printAsHtml:{defaultValue:null,description:`By Default when a page is printed that includes a Tabulator it will be rendered on the page exactly as the table is drawn. While this ise useful in most cases, some users prefer to have more control over the print output, for example showing all rows of the table, instead of just those visible with the current position of the scroll bar.

Tabulator provides a print styling mode that will replace the Tabulator with an HTML table for the printout giving you much more control over the look and feel of the table for the print out., to enable this mode, set the printAsHtml option to true in the table constructor.

This will replace the table (in print outs only) with a simple HTML table with the class tabulator-print-table that you can use to style the table in any way you like.

It also has the benefit that because it is an HTML table, if it causes a page break your browser will automatically add the column headers in at the top of the next page.`,name:"printAsHtml",required:!1,type:{name:"boolean"}},printConfig:{defaultValue:null,description:`The HTML table will contain column header groups, row groups, and column calculations.

You can choose to remove any of these from the output data by setting the values in the printConfig option in the table definition`,name:"printConfig",required:!1,type:{name:"AdditionalExportOptions"}},printStyled:{defaultValue:null,description:"If you want your printed table to be styled to match your Tabulator you can set the printCopyStyle to true, this will copy key layout styling to the printed table.",name:"printStyled",required:!1,type:{name:"boolean"}},printRowRange:{defaultValue:null,description:"By default, only the rows currently visible in the Tabulator will be added to the HTML table. For custom row ranges it is also possible to pass a function into the printRowRange option that should return an array of Row Components",name:"printRowRange",required:!1,type:{name:"RowRangeLookup | (() => RowComponent[])"}},printHeader:{defaultValue:null,description:"You can use the printHeader table setup option to define a header to be displayed when the table is printed.",name:"printHeader",required:!1,type:{name:"StandardStringParam"}},printFooter:{defaultValue:null,description:"You can use the printFooter table setup option to define a footer to be displayed when the table is printed.",name:"printFooter",required:!1,type:{name:"StandardStringParam"}},printFormatter:{defaultValue:null,description:"The printFormatter table setup option allows you to carry out any manipulation of the print output before it is displayed to the user for printing.",name:"printFormatter",required:!1,type:{name:"((tableHolderElement: any, tableElement: any) => any)"}},groupHeaderDownload:{defaultValue:null,description:"",name:"groupHeaderDownload",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},spreadsheet:{defaultValue:null,description:`Enables the spreadsheet mode on the table.

The SpreadsheetModule must be installed to use this functionality.`,name:"spreadsheet",required:!1,type:{name:"boolean"}},spreadsheetRows:{defaultValue:null,description:"",name:"spreadsheetRows",required:!1,type:{name:"number"}},spreadsheetColumns:{defaultValue:null,description:"",name:"spreadsheetColumns",required:!1,type:{name:"number"}},spreadsheetColumnDefinition:{defaultValue:null,description:"",name:"spreadsheetColumnDefinition",required:!1,type:{name:"{ editor: string; resizable: string; }"}},spreadsheetSheets:{defaultValue:null,description:"",name:"spreadsheetSheets",required:!1,type:{name:"SpreadsheetSheet[]"}},spreadsheetSheetTabs:{defaultValue:null,description:"",name:"spreadsheetSheetTabs",required:!1,type:{name:"boolean"}},spreadsheetOutputFull:{defaultValue:null,description:"",name:"spreadsheetOutputFull",required:!1,type:{name:"boolean"}},dataTreeParentField:{defaultValue:null,description:"The parent key field name",name:"dataTreeParentField",required:!1,type:{name:"string | number"}},showHeaderFilter:{defaultValue:null,description:"Hide HeaderFilter when grid is initialized",name:"showHeaderFilter",required:!1,type:{name:"boolean"}},selectionMode:{defaultValue:null,description:"if true, use native tabulator selections rules without using active selection module",name:"selectionMode",required:!1,type:{name:"boolean"}},multiSelect:{defaultValue:null,description:"Allow multi select rows (default true)",name:"multiSelect",required:!1,type:{name:"boolean"}},onTableRef:{defaultValue:null,description:"On the tableRef ready callback",name:"onTableRef",required:!1,type:{name:"((ref: MutableRefObject<ITabulator>) => void)"}},events:{defaultValue:null,description:"Grid events",name:"events",required:!1,type:{name:"(Partial<EventCallBackMethods> & IActiveSelectionModuleTableEvents)"}},minWidth:{defaultValue:null,description:"Grid container max width",name:"minWidth",required:!1,type:{name:"string | number"}},maxWidth:{defaultValue:null,description:"Grid container max width",name:"maxWidth",required:!1,type:{name:"string | number"}},allowTextSelection:{defaultValue:null,description:"by default user text selection is disabled (CSS user-select='none')",name:"allowTextSelection",required:!1,type:{name:"boolean"}},updateColumnDefinition:{defaultValue:null,description:"",name:"updateColumnDefinition",required:!1,type:{name:"((column: ColumnLookup, definition: Partial<ColumnDefinition>) => Promise<void>)"}}}}}catch{}try{tabulatorGrid.displayName="tabulatorGrid",tabulatorGrid.__docgenInfo={description:"",displayName:"tabulatorGrid",props:{apiRef:{defaultValue:null,description:"A mutable object to merge with these controls api",name:"apiRef",required:!1,type:{name:"unknown"}},id:{defaultValue:null,description:`Grid Id
Grid ID`,name:"id",required:!1,type:{name:"string"}},gridMode:{defaultValue:null,description:"Grid mode: local or remote",name:"gridMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},dataSet:{defaultValue:null,description:"Grid data set",name:"dataSet",required:!1,type:{name:"IGridRowData[]"}},className:{defaultValue:null,description:"Grid class name",name:"className",required:!1,type:{name:"string"}},headerLabel:{defaultValue:null,description:"Grid label in header buttons row",name:"headerLabel",required:!1,type:{name:"ReactNode"}},buttons:{defaultValue:null,description:"Grid header buttons",name:"buttons",required:!1,type:{name:'Record<"view" | "create" | "update" | "clone" | "delete" | "select" | "filterToggle" | "system", ITabulatorButton | null> | ITabulatorButtons'}},buttonsSize:{defaultValue:null,description:"Grid header buttons size. Default: 'small'",name:"buttonsSize",required:!1,type:{name:"enum",value:[{value:'"small"'},{value:'"middle"'},{value:'"large"'}]}},buttonsIconsOnly:{defaultValue:null,description:"If true, only button icons will be displayed, without title",name:"buttonsIconsOnly",required:!1,type:{name:"boolean"}},buttonsPosition:{defaultValue:null,description:"Grid header buttons size. Default: 'right'",name:"buttonsPosition",required:!1,type:{name:"enum",value:[{value:'"center"'},{value:'"left"'},{value:'"right"'}]}},readOnly:{defaultValue:null,description:"Table can't be edited",name:"readOnly",required:!1,type:{name:"boolean"}},editFormProps:{defaultValue:null,description:"Edit DFormModal parameters",name:"editFormProps",required:!1,type:{name:"IDFormModalProps"}},selectionFormProps:{defaultValue:null,description:"Selection DFormModal parameters",name:"selectionFormProps",required:!1,type:{name:"IDFormModalProps"}},appendSelection:{defaultValue:null,description:"Append row selection when using selectionFormProps (by default, the dataSet is replaced with the selected rows. This option allows you to change this behavior)",name:"appendSelection",required:!1,type:{name:"boolean"}},noHover:{defaultValue:null,description:"Disable row hover effect",name:"noHover",required:!1,type:{name:"boolean"}},rowDeleteMessage:{defaultValue:null,description:"Confirm message before rows delete",name:"rowDeleteMessage",required:!1,type:{name:"ReactNode"}},confirmDelete:{defaultValue:null,description:"Should confirm before delete",name:"confirmDelete",required:!1,type:{name:"boolean"}},placeholder:{defaultValue:null,description:`No rows placeholder
placeholder element to display on empty table.`,name:"placeholder",required:!1,type:{name:"(string & (string | HTMLElement | ((this: TabulatorFull | Tabulator) => string)))"}},resizeHeightWithParent:{defaultValue:null,description:"Selector of parent container (.className or #id). Tabulator Grid will resize height on container height change",name:"resizeHeightWithParent",required:!1,type:{name:"string"}},responsiveBreakpoint:{defaultValue:null,description:"Breakpoint for responsive design",name:"responsiveBreakpoint",required:!1,type:{name:"enum",value:[{value:'"xl"'},{value:'"md"'},{value:'"sm"'},{value:'"xs"'},{value:'"lg"'},{value:'"xxl"'}]}},language:{defaultValue:null,description:"Language",name:"language",required:!1,type:{name:"enum",value:[{value:'"ru"'},{value:'"en"'},{value:'"cn"'}]}},translation:{defaultValue:null,description:"Custom translation",name:"translation",required:!1,type:{name:"Partial<{ view: string; viewRecord: string; create: string; createNewRecord: string; edit: string; editRecord: string; clone: string; cloneRecord: string; delete: string; deleteRecord: string; select: string; ... 11 more ...; deleteSelectedRecordsQt: string; }>"}},onMenuVisibilityChanged:{defaultValue:null,description:"Fires when menu visibility status changed",name:"onMenuVisibilityChanged",required:!1,type:{name:"((isVisible: boolean, gridApi: IGridApi) => void)"}},onDataFetch:{defaultValue:null,description:"special callback used to fetch remote data. If not specified, the request will not be processed.",name:"onDataFetch",required:!1,type:{name:"((params: IRequestProps, gridApi: IGridApi) => IGridRowData[] | IGridDataSourcePromise)"}},onDataFetching:{defaultValue:null,description:"Called before a data fetching begins. If it returns false, then the fetch is canceled",name:"onDataFetching",required:!1,type:{name:"((url: string, params: IRequestProps, gridApi: IGridApi) => boolean)"}},onDataFetchResponse:{defaultValue:null,description:"Fires when a successful remote fetch request has been made. This callback can also be used to modify the received data before it is parsed by the table. If you use this callback it must return the data to be parsed by Tabulator, otherwise no data will be rendered.",name:"onDataFetchResponse",required:!1,type:{name:"((dataSet: IGridRowData[], params: IRequestProps, gridApi: IGridApi) => IGridRowData[])"}},onDataLoading:{defaultValue:null,description:"The callback is triggered when data set loading starts (regardless of whether it is an ajax request or a ready-made dataSet is passed)",name:"onDataLoading",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi) => void)"}},onDataLoaded:{defaultValue:null,description:"The callback is triggered when dataset changed or new dataSet is loaded into the table (regardless of whether it is an ajax request or a ready-made dataSet is passed)",name:"onDataLoaded",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi) => void)"}},onDataProcessed:{defaultValue:null,description:"The callback is triggered  after data has been processed and the table has been rendered.",name:"onDataProcessed",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi) => void)"}},onDataLoadError:{defaultValue:null,description:"Fires when the grid data loading failed",name:"onDataLoadError",required:!1,type:{name:"((message: string, code: number, gridApi: IGridApi) => void)"}},onDataChanged:{defaultValue:null,description:"Fires before the data change (the data set updated, rows added/deleted, etc.)",name:"onDataChanged",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi) => void)"}},onSelectionChange:{defaultValue:null,description:"Callback executed when selected rows change",name:"onSelectionChange",required:!1,type:{name:"((data: IGridRowData[], rows: RowComponent[], selectedRows: RowComponent[], deselectedRows: RowComponent[], gridApi: IGridApi) => void)"}},onDelete:{defaultValue:null,description:"Callback executed when selected rows delete",name:"onDelete",required:!1,type:{name:"((selectedRows: IGridRowData[], gridApi: IGridApi) => void | IGridDeletePromise)"}},height:{defaultValue:null,description:"Sets the height of the containing element, can be set to any valid height css value. If set to false (the default), the height of the table will resize to fit the table data.",name:"height",required:!1,type:{name:"string | number | false"}},width:{defaultValue:null,description:"Grid container width",name:"width",required:!1,type:{name:"string | number"}},containerClassName:{defaultValue:null,description:"Grid container class name",name:"containerClassName",required:!1,type:{name:"string"}},footerElement:{defaultValue:null,description:"Grid footer element",name:"footerElement",required:!1,type:{name:"ReactNode"}},columns:{defaultValue:null,description:"Grid columns",name:"columns",required:!0,type:{name:"ITabulatorColumn[]"}},maxHeight:{defaultValue:null,description:"Can be set to any valid CSS value. By setting this you can allow your table to expand to fit the data, but not overflow its parent element. When there are too many rows to fit in the available space, the vertical scroll bar will be shown. This has the added benefit of improving load times on larger tables",name:"maxHeight",required:!1,type:{name:"string | number"}},minHeight:{defaultValue:null,description:"With a variable table height you can set the minimum height of the table either defined in the min-height CSS property for the element or set it using the minHeight option in the table constructor, this can be set to any valid CSS value.",name:"minHeight",required:!1,type:{name:"string | number"}},renderVertical:{defaultValue:null,description:"",name:"renderVertical",required:!1,type:{name:"RenderMode"}},renderHorizontal:{defaultValue:null,description:"",name:"renderHorizontal",required:!1,type:{name:"RenderMode"}},rowHeight:{defaultValue:null,description:"",name:"rowHeight",required:!1,type:{name:"number"}},renderVerticalBuffer:{defaultValue:null,description:"Manually set the size of the virtual DOM buffer.",name:"renderVerticalBuffer",required:!1,type:{name:"number | boolean"}},placeholderHeaderFilter:{defaultValue:null,description:"",name:"placeholderHeaderFilter",required:!1,type:{name:"string | HTMLElement | ((this: TabulatorFull | Tabulator) => string)"}},keybindings:{defaultValue:null,description:"Keybinding configuration object.",name:"keybindings",required:!1,type:{name:"false | KeyBinding"}},reactiveData:{defaultValue:null,description:`The reactivity systems allow Tabulator to watch arrays and objects passed into the table for changes and then automatically update the table.

This approach means you no longer need to worry about calling a number of different functions on the table to make changes, you simply update the array or object you originally passed into the table and Tabulator will take care of the rest.

You can enable reactive data by setting the reactiveData option to true in the table constructor, and then passing your data array to the data option.

Once the table is built any changes to the array will automatically be replicated to the table without needing to call any functions on the table itself`,name:"reactiveData",required:!1,type:{name:"boolean"}},autoResize:{defaultValue:null,description:"Tabulator will automatically attempt to redraw the data contained in the table if the containing element for the table is resized. To disable this functionality, set the autoResize property to false.",name:"autoResize",required:!1,type:{name:"boolean"}},invalidOptionWarnings:{defaultValue:null,description:"Setting the invalidOptionWarnings option to false will disable console warning messages for invalid properties in the table constructor and column definition object.",name:"invalidOptionWarnings",required:!1,type:{name:"boolean"}},validationMode:{defaultValue:null,description:`There are now three different validation modes available to customize the validation experience:

blocking - if a user enters an invalid value while editing, they are blocked from leaving the cell until a valid value is entered (default)

highlight - if a user enters an invalid value, then the edit will complete as usual and they are allowed to exit the cell but a highlight is applied to the cell using the tabulator-validation-fail class

manual - no validation is automatically performed on edit, but it can be triggered by calling the validate function on the table or any Component Object`,name:"validationMode",required:!1,type:{name:"enum",value:[{value:'"blocking"'},{value:'"highlight"'},{value:'"manual"'}]}},textDirection:{defaultValue:null,description:"",name:"textDirection",required:!1,type:{name:"enum",value:[{value:'"ltr"'},{value:'"rtl"'},{value:'"auto"'}]}},rowHeader:{defaultValue:null,description:`Sometimes it can be useful to add a visual header to the start of a row.
The \`rowHeader\` option allows you to define a column definition for a stylized header column at the start of the row.

This can be great for adding row number, movable row handles or row selections, and keeps the controls visually separated from the table data.`,name:"rowHeader",required:!1,type:{name:"boolean | { formatter?: string; field?: string; headerSort?: boolean | undefined; hozAlign?: ColumnDefinitionAlign | undefined; ... 7 more ...; rowHandle?: boolean | undefined; } | undefined"}},editorEmptyValue:{defaultValue:null,description:"The value to set in the cell after the user has finished editing the cell.",name:"editorEmptyValue",required:!1,type:{name:"any"}},editorEmptyValueFunc:{defaultValue:null,description:"The function to determine if the value is empty.",name:"editorEmptyValueFunc",required:!1,type:{name:"((value: unknown) => boolean)"}},rowContextMenu:{defaultValue:null,description:"",name:"rowContextMenu",required:!1,type:{name:"RowContextMenuSignature"}},rowClickMenu:{defaultValue:null,description:"",name:"rowClickMenu",required:!1,type:{name:"RowContextMenuSignature"}},rowDblClickMenu:{defaultValue:null,description:"",name:"rowDblClickMenu",required:!1,type:{name:"RowContextMenuSignature"}},groupClickMenu:{defaultValue:null,description:"",name:"groupClickMenu",required:!1,type:{name:"GroupContextMenuSignature"}},groupDblClickMenu:{defaultValue:null,description:"",name:"groupDblClickMenu",required:!1,type:{name:"GroupContextMenuSignature"}},groupContextMenu:{defaultValue:null,description:"",name:"groupContextMenu",required:!1,type:{name:"MenuObject<GroupComponent>[]"}},popupContainer:{defaultValue:null,description:"",name:"popupContainer",required:!1,type:{name:"string | boolean | HTMLElement"}},groupClickPopup:{defaultValue:null,description:"",name:"groupClickPopup",required:!1,type:{name:"string"}},groupContextPopup:{defaultValue:null,description:"",name:"groupContextPopup",required:!1,type:{name:"string"}},groupDblPopup:{defaultValue:null,description:"",name:"groupDblPopup",required:!1,type:{name:"string"}},groupDblClickPopup:{defaultValue:null,description:"",name:"groupDblClickPopup",required:!1,type:{name:"string"}},rowClickPopup:{defaultValue:null,description:"",name:"rowClickPopup",required:!1,type:{name:"string"}},rowContextPopup:{defaultValue:null,description:"",name:"rowContextPopup",required:!1,type:{name:"string"}},rowDblClickPopup:{defaultValue:null,description:"",name:"rowDblClickPopup",required:!1,type:{name:"string"}},history:{defaultValue:null,description:"Enable user interaction history functionality",name:"history",required:!1,type:{name:"boolean"}},locale:{defaultValue:null,description:"You can set the current local in one of two ways. If you want to set it when the table is created, simply include the locale option in your Tabulator constructor. You can either pass in a string matching one of the language options you have defined, or pass in the boolean true which will cause Tabulator to auto-detect the browsers language settings from the navigator.language object.",name:"locale",required:!1,type:{name:"string | boolean"}},langs:{defaultValue:null,description:`You can store as many languages as you like, creating an object inside the langs object with a property of the locale code for that language. A list of locale codes can be found here.

At present there are three parts of the table that can be localized, the column headers, the header filter placeholder text and the pagination buttons. To localize the pagination buttons, create a pagination property inside your language object and give it the properties outlined below.

If you wish you can also localize column titles by adding a columns property to your language object. You should store a property of the field name of the column you wish to change, with a value of its title. Any fields that match this will use this title instead of the one provided by the column definition array.`,name:"langs",required:!1,type:{name:"any"}},downloadEncoder:{defaultValue:null,description:`The downloadEncoder callback allows you to intercept the download file data before the users is prompted to save the file.

The first argument of the function is the file contents returned from the downloader, the second argument is the suggested mime type for the output. The function is should return a blob of the file to be downloaded.`,name:"downloadEncoder",required:!1,type:{name:"((fileContents: any, mimeType: string) => false | Blob)"}},downloadConfig:{defaultValue:null,description:`By default Tabulator includes column headers, row groups and column calculations in the download output.

You can choose to remove column headers groups, row groups or column calculations from the output data by setting the values in the downloadConfig option in the table definition:`,name:"downloadConfig",required:!1,type:{name:"AdditionalExportOptions"}},downloadRowRange:{defaultValue:null,description:"By default, only the active rows (rows that have passed filtering) will be included in the download the downloadRowRange option takes a Row Range Lookup value and allows you to choose which rows are included in the download output.",name:"downloadRowRange",required:!1,type:{name:"enum",value:[{value:'"visible"'},{value:'"all"'},{value:'"selected"'},{value:'"active"'},{value:'"range"'}]}},downloadDataFormatter:{defaultValue:null,description:"If you want to make any changes to the table data before it is parsed into the download file you can pass a mutator function to the downloadDataFormatter callback.",name:"downloadDataFormatter",required:!1,type:{name:"((data: any) => any)"}},downloadReady:{defaultValue:null,description:`The downloadReady callback allows you to intercept the download file data before the users is prompted to save the file.

In order for the download to proceed the downloadReady callback is expected to return a blob of file to be downloaded.

If you would prefer to abort the download you can return false from this callback. This could be useful for example if you want to send the created file to a server via ajax rather than allowing the user to download the file.`,name:"downloadReady",required:!1,type:{name:"((fileContents: any, blob: Blob) => false | Blob)"}},autoColumns:{defaultValue:null,description:"If you set the autoColumns option to true, every time data is loaded into the table through the data option or through the setData function, Tabulator will examine the first row of the data and build columns to match that data.",name:"autoColumns",required:!1,type:{name:'boolean | "full"'}},autoColumnsDefinitions:{defaultValue:null,description:"",name:"autoColumnsDefinitions",required:!1,type:{name:"((columnDefinitions?: ColumnDefinition[]) => ColumnDefinition[]) | ColumnDefinition[] | Record<string, Partial<ColumnDefinition>>"}},layout:{defaultValue:null,description:"By default Tabulator will use the fitData layout mode, which will resize the tables columns to fit the data held in each column, unless you specify a width or minWidth in the column constructor. If the width of all columns exceeds the width of the containing element, a scroll bar will appear.",name:"layout",required:!1,type:{name:"enum",value:[{value:'"fitData"'},{value:'"fitColumns"'},{value:'"fitDataFill"'},{value:'"fitDataStretch"'},{value:'"fitDataTable"'}]}},layoutColumnsOnNewData:{defaultValue:null,description:`To keep the layout of the columns consistent, once the column widths have been set on the first data load (either from the data property in the constructor or the setData function) they will not be changed when new data is loaded.

If you would prefer that the column widths adjust to the data each time you load it into the table you can set the layoutColumnsOnNewData property to true.`,name:"layoutColumnsOnNewData",required:!1,type:{name:"boolean"}},responsiveLayout:{defaultValue:null,description:`Responsive layout will automatically hide/show columns to fit the width of the Tabulator element. This allows for clean rendering of tables on smaller mobile devices, showing important data while avoiding horizontal scroll bars. You can enable responsive layouts using the responsiveLayout option.

There are two responsive layout modes available:

hide - hide columns that no longer fit in the table
collapse - collapse columns that no longer fit on the table into a list under the row

Hide Extra Columns
By default, columns will be hidden from right to left as the width of the table decreases. You can choose exactly how columns are hidden using the responsive property in the column definition object.

When responsive layout is enabled, all columns are given a default responsive value of 1. The higher you set this value the sooner that column will be hidden as the table width decreases. If two columns have the same responsive value then they are hidden from right to left (as defined in the column definition array, ignoring user moving of the columns). If you set the value to 0 then the column will never be hidden regardless of how narrow the table gets.`,name:"responsiveLayout",required:!1,type:{name:'boolean | "hide" | "collapse"'}},responsiveLayoutCollapseStartOpen:{defaultValue:null,description:"Collapsed lists are displayed to the user by default, if you would prefer they start closed so the user can open them you can use the responsiveLayoutCollapseStartOpen option.",name:"responsiveLayoutCollapseStartOpen",required:!1,type:{name:"boolean"}},responsiveLayoutCollapseUseFormatters:{defaultValue:null,description:`By default any formatter set on the column is applied to the value that will appear in the list. while this works for most formatters it can cause issues with the progress formatter which relies on being inside a cell.

If you would like to disable column formatting in the collapsed list, you can use the responsiveLayoutCollapseUseFormatters option:`,name:"responsiveLayoutCollapseUseFormatters",required:!1,type:{name:"boolean"}},responsiveLayoutCollapseFormatter:{defaultValue:null,description:`If you set the responsiveLayout option to collapse the values from hidden columns will be displayed in a title/value list under the row.

In this mode an object containing the title of each hidden column and its value is generated and then used to generate a list displayed in a div .tabulator-responsive-collapse under the row data.

The inbuilt collapse formatter creates a table to neatly display the hidden columns. If you would like to format the data in your own way you can use the responsiveLayoutCollapseFormatter, it take an object of the column values as an argument and must return the HTML content of the div.

This function should return an empty string if there is no data to display.`,name:"responsiveLayoutCollapseFormatter",required:!1,type:{name:"((data: any[]) => any)"}},movableColumns:{defaultValue:null,description:"To allow the user to move columns along the table, set the movableColumns parameter in the options:",name:"movableColumns",required:!1,type:{name:"boolean"}},columnHeaderVertAlign:{defaultValue:null,description:"You can use the columnHeaderVertAlign option to set how the text in your column headers should be vertically.",name:"columnHeaderVertAlign",required:!1,type:{name:"enum",value:[{value:'"middle"'},{value:'"top"'},{value:'"bottom"'}]}},scrollToColumnPosition:{defaultValue:null,description:`The default ScrollTo position can be set using the scrollToColumnPosition option. It can take one of three possible values:

left - position column with its left edge at the left of the table (default)
center - position column with its left edge in the center of the table
right - position column with its right edge at the right of the table`,name:"scrollToColumnPosition",required:!1,type:{name:"enum",value:[{value:'"center"'},{value:'"left"'},{value:'"right"'},{value:'"middle"'}]}},scrollToColumnIfVisible:{defaultValue:null,description:`The default option for triggering a ScrollTo on a visible element can be set using the scrollToColumnIfVisible option. It can take a boolean value:

true - scroll to column, even if it is visible (default)
false - scroll to column, unless it is currently visible, then don't move`,name:"scrollToColumnIfVisible",required:!1,type:{name:"boolean"}},columnCalcs:{defaultValue:null,description:`By default column calculations are shown at the top and bottom of the table, unless row grouping is enabled, in which case they are shown at the top and bottom of each group.

The columnCalcs option lets you decided where the calculations should be displayed, it can take one of four values:

true - show calcs at top and bottom of the table, unless grouped, then show in groups (boolean, default)
both - show calcs at top and bottom of the table and show in groups
table - show calcs at top and bottom of the table only
group - show calcs in groups only`,name:"columnCalcs",required:!1,type:{name:'boolean | "both" | "table" | "group"'}},nestedFieldSeparator:{defaultValue:null,description:`If you need to use the . character as part of your field name, you can change the separator to any other character using the nestedFieldSeparator option
Set to false to disable nested data parsing`,name:"nestedFieldSeparator",required:!1,type:{name:"string | boolean"}},columnHeaderSortMulti:{defaultValue:null,description:"multiple or single column sorting",name:"columnHeaderSortMulti",required:!1,type:{name:"boolean"}},headerVisible:{defaultValue:null,description:"By setting the headerVisible option to false you can hide the column headers and present the table as a simple list if needed.",name:"headerVisible",required:!1,type:{name:"boolean"}},headerSort:{defaultValue:null,description:"The headerSort option can now be set in the table options to affect all columns as well as in column definitions.",name:"headerSort",required:!1,type:{name:"boolean"}},headerSortElement:{defaultValue:null,description:"",name:"headerSortElement",required:!1,type:{name:'string | ((column: ColumnComponent, dir: "none" | "asc" | "desc") => any)'}},columnDefaults:{defaultValue:null,description:"",name:"columnDefaults",required:!1,type:{name:"Partial<ColumnDefinition>"}},resizableColumnFit:{defaultValue:null,description:"If set to true, then when you resize a column its neighbouring column has the opposite resize applied to keep to total width of columns the same",name:"resizableColumnFit",required:!1,type:{name:"boolean"}},rowFormatter:{defaultValue:null,description:`Tabulator also allows you to define a row level formatter using the rowFormatter option. this lets you alter each row of the table based on the data it contains.
The function accepts one argument, the RowComponent for the row being formatted.`,name:"rowFormatter",required:!1,type:{name:"((row: RowComponent) => any)"}},rowFormatterPrint:{defaultValue:null,description:"When printing you may want to apply a different formatter may want to apply a different formatter from the one usually used to format the row.",name:"rowFormatterPrint",required:!1,type:{name:"false | ((row: RowComponent) => any)"}},rowFormatterHtmlOutput:{defaultValue:null,description:"When the getHtml function is called you may want to apply a different formatter may want to apply a different formatter from the one usually used to format the row",name:"rowFormatterHtmlOutput",required:!1,type:{name:"false | ((row: RowComponent) => any)"}},rowFormatterClipboard:{defaultValue:null,description:"When copying to the clipboard you may want to apply a different formatter may want to apply a different formatter from the one usually used to format the row. You can now do this using the rowFormatterClipboard table option, which takes the same inputs as the standard rowFormatter property. Passing a value of false into the formatter prevent the default row formatter from being run when the table is copied to the clipboard.",name:"rowFormatterClipboard",required:!1,type:{name:"false | ((row: RowComponent) => any)"}},addRowPos:{defaultValue:null,description:'The position in the table for new rows to be added, "bottom" or "top".',name:"addRowPos",required:!1,type:{name:"enum",value:[{value:'"top"'},{value:'"bottom"'}]}},selectable:{defaultValue:null,description:`The selectable option can take one of a several values:
false - selectable rows are disabled
true - selectable rows are enabled, and you can select as many as you want
integer - any integer value, this sets the maximum number of rows that can be selected (when the maximum number of selected rows is exceeded, the first selected row will be deselected to allow the next row to be selected).
"highlight" (default) - rows have the same hover stylings as selectable rows but do not change state when clicked. This is great for when you want to show that a row is clickable but don't want it to be selectable.
@deprecated Use selectableRows instead`,name:"selectable",required:!1,type:{name:'number | boolean | "highlight"'}},selectableRows:{defaultValue:null,description:`The selectableRows option can take one of a several values:

- false - selectable rows are disabled
- true - selectable rows are enabled, and you can select as many as you want
- integer - any integer value, this sets the maximum number of rows that can be selected (when the maximum number of selected rows is exceeded, the first selected row will be deselected to allow the next row to be selected).
- "highlight" (default) - rows have the same hover stylings as selectable rows but do not change state when clicked. This is great for when you want to show that a row is clickable but don't want it to be selectable.`,name:"selectableRows",required:!1,type:{name:'number | boolean | "highlight"'}},selectableRange:{defaultValue:null,description:`The selectableRange option can take one of a several values:

- false - range selection is disabled
- true - range selection is enabled, and you can add as many ranges as you want
- integer - any integer value, this sets the maximum number of ranges that can be selected (when the maximum
          number of ranges is exceeded, the first selected range will be deselected to allow the next range to be selected).`,name:"selectableRange",required:!1,type:{name:"number | boolean"}},selectableRangeColumns:{defaultValue:null,description:`By default you can only select ranges by selecting cells on the table. If you would like to allow the user to
select all cells in a column by clicking on the column header, then you can set the selectableRangeColumns option to true`,name:"selectableRangeColumns",required:!1,type:{name:"boolean"}},selectableRangeRows:{defaultValue:null,description:`By default you can only select ranges by selecting cells on the table. If you would like to allow the user to
select all cells in row by clicking on the row header, then you can set the selectableRangeColumns option to true`,name:"selectableRangeRows",required:!1,type:{name:"boolean"}},selectableRangeClearCells:{defaultValue:null,description:`If you want the user to be able to clear the values for all cells in the active range by pressing the backspace
or delete keys, then you can enable this behavior using the selectableRangeClearCells option:
@example var table = new Tabulator("#example-table", {
    selectableRangeClearCells:true,
});`,name:"selectableRangeClearCells",required:!1,type:{name:"boolean"}},selectableRangeClearCellsValue:{defaultValue:null,description:`By default the value of each cell in the range is set to undefined when this option is enabled and the user
presses the backspace or delete keys. You can change the value the cells are set to using the
selectableRangeClearCellsValue option
@example var table = new Tabulator("#example-table", {
    selectableRangeClearCellsValue: "", //clear cells by setting value to an empty string
});`,name:"selectableRangeClearCellsValue",required:!1,type:{name:"unknown"}},selectableRangeMode:{defaultValue:null,description:`By default you can select a range of rows by holding down the shift key and click dragging over a number of rows to toggle the selected state state of all rows the cursor passes over.

If you would prefer to select a range of row by clicking on the first row then holding down shift and clicking on the end row then you can achieve this by setting the selectableRangeMode to click
@deprecated Use selectableRowsRangeMode instead`,name:"selectableRangeMode",required:!1,type:{name:"enum",value:[{value:'"click"'}]}},selectableRowsRangeMode:{defaultValue:null,description:`By default you can select a range of rows by holding down the shift key and click dragging over a number of rows
to toggle the selected state state of all rows the cursor passes over.

If you would prefer to select a range of row by clicking on the first row then holding down shift and clicking
on the end row then you can achieve this by setting the selectableRowsRangeMode to click.
@example var table = new Tabulator("#example-table", {
    selectableRowsRangeMode:"click",
});`,name:"selectableRowsRangeMode",required:!1,type:{name:"enum",value:[{value:'"click"'}]}},selectableRollingSelection:{defaultValue:null,description:`By default, row selection works on a rolling basis, if you set the selectable option to a numeric value then when you select past this number of rows, the first row to be selected will be deselected. If you want to disable this behavior and instead prevent selection of new rows once the limit is reached you can set the selectableRollingSelection option to false.
@deprecated Use selectableRowsRollingSelection instead`,name:"selectableRollingSelection",required:!1,type:{name:"boolean"}},selectableRowsRollingSelection:{defaultValue:null,description:`By default, row selection works on a rolling basis, if you set the selectableRows option to a numeric value then
when you select past this number of rows, the first row to be selected will be deselected. If you want to
disable this behavior and instead prevent selection of new rows once the limit is reached you can set the
selectableRowsRollingSelection option to false.
@example var table = new Tabulator("#example-table", {
    selectableRows: 5,
    selectableRowsRollingSelection:false, // disable rolling selection
});`,name:"selectableRowsRollingSelection",required:!1,type:{name:"boolean"}},selectablePersistence:{defaultValue:null,description:`By default Tabulator will maintain selected rows when the table is filtered, sorted or paginated (but NOT when the setData function is used). If you want the selected rows to be cleared whenever the table view is updated then set the selectablePersistence option to false.
@deprecated Use selectableRowsPersistence instead`,name:"selectablePersistence",required:!1,type:{name:"boolean"}},selectableRowsPersistence:{defaultValue:null,description:`By default Tabulator will maintain selected rows when the table is filtered, sorted or paginated (but NOT when
the setData function is used). If you want the selected rows to be cleared whenever the table view is updated
then set the selectableRowsPersistence option to false.
@example var table = new Tabulator("#example-table", {
    selectableRows: true,
    selectableRowsPersistence: false, // disable selection persistence
});`,name:"selectableRowsPersistence",required:!1,type:{name:"boolean"}},selectableCheck:{defaultValue:null,description:"You many want to exclude certain rows from being selected. The selectableCheck options allows you to pass a function to check if the current row should be selectable, returning true will allow row selection, false will result in nothing happening. The function should accept a RowComponent as its first argument.",name:"selectableCheck",required:!1,type:{name:"((row: RowComponent) => boolean)"}},movableRows:{defaultValue:null,description:"To allow the user to move rows up and down the table, set the movableRows parameter in the options:",name:"movableRows",required:!1,type:{name:"boolean"}},movableRowsConnectedTables:{defaultValue:null,description:"Tabulator also allows you to move rows between tables. To enable this you should supply either a valid CSS selector string a DOM node for the table or the Tabulator object for the table to the movableRowsConnectedTables option. if you want to connect to multiple tables then you can pass in an array of values to this option.",name:"movableRowsConnectedTables",required:!1,type:{name:"string | string[] | HTMLElement | HTMLElement[]"}},movableRowsSender:{defaultValue:null,description:`The movableRowsSender option should be set on the sending table, and sets the action that should be taken after the row has been successfully dropped into the receiving table.
There are several inbuilt sender functions:

- false - do nothing(default)
- delete - deletes the row from the table
You can also pass a callback to the movableRowsSender option for custom sender functionality`,name:"movableRowsSender",required:!1,type:{name:'false | "delete" | ((fromRow: RowComponent, toRow: RowComponent, toTable: Tabulator) => any)'}},movableRowsReceiver:{defaultValue:null,description:`The movableRowsReceiver option should be set on the receiving tables, and sets the action that should be taken when the row is dropped into the table.
There are several inbuilt receiver functions:

- insert - inserts row next to the row it was dropped on, if not dropped on a row it is added to the table (default)
- add - adds row to the table
- update - updates the row it is dropped on with the sent rows data
- replace - replaces the row it is dropped on with the sent row`,name:"movableRowsReceiver",required:!1,type:{name:'"update" | "insert" | "add" | "replace" | ((fromRow: RowComponent, toRow: RowComponent, fromTable: Tabulator) => any)'}},movableRowsConnectedElements:{defaultValue:null,description:"",name:"movableRowsConnectedElements",required:!1,type:{name:"string | HTMLElement"}},resizableRowGuide:{defaultValue:null,description:"Allows the user to control the height of rows in the table by dragging the bottom border of the row.\nThese guides will only appear on columns with the `resizable` option enabled in their column definition.",name:"resizableRowGuide",required:!1,type:{name:"boolean"}},resizableColumnGuide:{defaultValue:null,description:"Allows the user to control the height of columns in the table by dragging the border of the column.\nThese guides will only appear if the `resizableRows` option is enabled.",name:"resizableColumnGuide",required:!1,type:{name:"boolean"}},scrollToRowPosition:{defaultValue:null,description:`The default ScrollTo position can be set using the scrollToRowPosition option. It can take one of four possible values:

top - position row with its top edge at the top of the table (default)
center - position row with its top edge in the center of the table
bottom - position row with its bottom edge at the bottom of the table
nearest - position row on the edge of the table it is closest to`,name:"scrollToRowPosition",required:!1,type:{name:"enum",value:[{value:'"center"'},{value:'"top"'},{value:'"bottom"'},{value:'"nearest"'}]}},scrollToRowIfVisible:{defaultValue:null,description:`The default option for triggering a ScrollTo on a visible element can be set using the scrollToRowIfVisible option. It can take a boolean value:

true - scroll to row, even if it is visible (default)
false - scroll to row, unless it is currently visible, then don't move`,name:"scrollToRowIfVisible",required:!1,type:{name:"boolean"}},tabEndNewRow:{defaultValue:null,description:"Allows you to specify the behavior when the user tabs from the last editable cell on the last row of the table.",name:"tabEndNewRow",required:!1,type:{name:"boolean | JSONRecord | ((row: RowComponent) => any)"}},frozenRowsField:{defaultValue:null,description:"",name:"frozenRowsField",required:!1,type:{name:"string"}},frozenRows:{defaultValue:null,description:"Freeze rows of data",name:"frozenRows",required:!1,type:{name:"number | string[] | ((row: RowComponent) => boolean)"}},editTriggerEvent:{defaultValue:null,description:`The editTriggerEvent option lets you choose which type of interaction event will trigger an edit on a cell.
@example var table = new Tabulator("#example-table", {
    editTriggerEvent:"dblclick", // trigger edit on double click
});

This option can take one of three values:

- focus - trigger edit when the cell has focus (default)
- click - trigger edit on single click on cell
- dblclick - trigger edit on double click on cell

This option does not affect navigation behavior, cells edits will still be triggered when they are navigated to
through arrow keys or tabs.`,name:"editTriggerEvent",required:!1,type:{name:"enum",value:[{value:'"focus"'},{value:'"click"'},{value:'"dblclick"'}]}},index:{defaultValue:null,description:"A unique index value should be present for each row of data if you want to be able to programmatically alter that data at a later point, this should be either numeric or a string. By default Tabulator will look for this value in the id field for the data. If you wish to use a different field as the index, set this using the index option parameter.",name:"index",required:!1,type:{name:"string | number"}},importFormat:{defaultValue:null,description:"",name:"importFormat",required:!1,type:{name:'"array" | "csv" | "json" | ((fileContents: string) => unknown[])'}},importReader:{defaultValue:null,description:"By default Tabulator will read in the file as plain text, which is the format used by all the built in importers. If you need to read the file data in a different format then you can use the importReader option to instruct the file reader to read in the file in a different format.",name:"importReader",required:!1,type:{name:"enum",value:[{value:'"text"'},{value:'"binary"'},{value:'"buffer"'},{value:'"url"'}]}},autoTables:{defaultValue:null,description:"",name:"autoTables",required:!1,type:{name:"boolean"}},ajaxParams:{defaultValue:null,description:"Parameters to be passed to remote Ajax data loading request.",name:"ajaxParams",required:!1,type:{name:"{}"}},ajaxConfig:{defaultValue:null,description:"The HTTP request type for Ajax requests or config object for the request.",name:"ajaxConfig",required:!1,type:{name:"HttpMethod | AjaxConfig"}},ajaxContentType:{defaultValue:null,description:`When using a request method other than "GET" Tabulator will send any parameters with a content type of form data. You can change the content type with the ajaxContentType option. This will ensure parameters are sent in the format you expect, with the correct headers. * * The ajaxContentType option can take one of two values:
"form" - send parameters as form data (default option)
"json" - send parameters as JSON encoded string
If you want to use a custom content type then you can pass a content type formatter object into the ajaxContentType option. this object must have two properties, the headers property should contain all headers that should be sent with the request and the body property should contain a function that returns the body content of the request`,name:"ajaxContentType",required:!1,type:{name:'"form" | "json" | AjaxContentType'}},ajaxURLGenerator:{defaultValue:null,description:`If you need more control over the url of the request that you can get from the ajaxURL and ajaxParams properties, the you can use the ajaxURLGenerator property to pass in a callback that will generate the URL for you.

The callback should return a string representing the URL to be requested.`,name:"ajaxURLGenerator",required:!1,type:{name:"((url: string, config: any, params: any) => string)"}},ajaxFiltering:{defaultValue:null,description:"Send filter config to server instead of processing locally",name:"ajaxFiltering",required:!1,type:{name:"boolean"}},ajaxSorting:{defaultValue:null,description:"Send sorter config to server instead of processing locally",name:"ajaxSorting",required:!1,type:{name:"boolean"}},progressiveLoad:{defaultValue:null,description:`If you are loading a lot of data from a remote source into your table in one go, it can sometimes take a long time for the server to return the request, which can slow down the user experience.

To speed things up in this situation Tabulator has a progressive load mode, this uses the pagination module to make a series of requests for part of the data set, one at a time, appending it to the table as the data arrives. This mode can be enable using the ajaxProgressiveLoad option. No pagination controls will be visible on screen, it just reuses the functionality of the pagination module to sequentially load the data.

With this mode enabled, all of the settings outlined in the Ajax Documentation are still available

There are two different progressive loading modes, to give you a choice of how data is loaded into the table.`,name:"progressiveLoad",required:!1,type:{name:"enum",value:[{value:'"load"'},{value:'"scroll"'}]}},progressiveLoadDelay:{defaultValue:null,description:"By default tabulator will make the requests to fill the table as quickly as possible. On some servers these repeats requests from the same client may trigger rate limiting or security systems. In this case you can use the ajaxProgressiveLoadDelay option to add a delay in milliseconds between each page request.",name:"progressiveLoadDelay",required:!1,type:{name:"number"}},progressiveLoadScrollMargin:{defaultValue:null,description:"The ajaxProgressiveLoadScrollMargin property determines how close to the bottom of the table in pixels, the scroll bar must be before the next page worth of data is loaded, by default it is set to twice the height of the table.",name:"progressiveLoadScrollMargin",required:!1,type:{name:"number"}},ajaxLoader:{defaultValue:null,description:"Show loader while data is loading, can also take a function that must return a boolean.",name:"ajaxLoader",required:!1,type:{name:"boolean | (() => boolean)"}},ajaxLoaderLoading:{defaultValue:null,description:"html for loader element.",name:"ajaxLoaderLoading",required:!1,type:{name:"string"}},ajaxLoaderError:{defaultValue:null,description:"html for the loader element in the event of an error.",name:"ajaxLoaderError",required:!1,type:{name:"string"}},ajaxRequesting:{defaultValue:null,description:"The ajaxRequesting callback is triggered when ever an ajax request is made.",name:"ajaxRequesting",required:!1,type:{name:"((url: string, params: any) => boolean)"}},dataLoader:{defaultValue:null,description:"",name:"dataLoader",required:!1,type:{name:"boolean"}},dataLoaderLoading:{defaultValue:null,description:"",name:"dataLoaderLoading",required:!1,type:{name:"string | HTMLElement"}},dataLoaderError:{defaultValue:null,description:"",name:"dataLoaderError",required:!1,type:{name:"string"}},dataLoaderErrorTimeout:{defaultValue:null,description:"",name:"dataLoaderErrorTimeout",required:!1,type:{name:"number"}},sortMode:{defaultValue:null,description:"",name:"sortMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},filterMode:{defaultValue:null,description:"",name:"filterMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},initialSort:{defaultValue:null,description:"Array of sorters to be applied on load.",name:"initialSort",required:!1,type:{name:"Sorter[]"}},sortOrderReverse:{defaultValue:null,description:"reverse the order that multiple sorters are applied to the table.",name:"sortOrderReverse",required:!1,type:{name:"boolean"}},headerSortClickElement:{defaultValue:null,description:"",name:"headerSortClickElement",required:!1,type:{name:"enum",value:[{value:'"icon"'},{value:'"header"'}]}},initialFilter:{defaultValue:null,description:"Array of filters to be applied on load.",name:"initialFilter",required:!1,type:{name:"Filter[]"}},initialHeaderFilter:{defaultValue:null,description:"array of initial values for header filters.",name:"initialHeaderFilter",required:!1,type:{name:'Pick<Filter, "value" | "field">[]'}},headerFilterLiveFilterDelay:{defaultValue:null,description:"When using real time header filtering, Tabulator will wait 300 milliseconds after a keystroke before triggering the filter. You can customize this delay by using the headerFilterLiveFilterDelay table setup option.",name:"headerFilterLiveFilterDelay",required:!1,type:{name:"number"}},groupBy:{defaultValue:null,description:"String/function to select field to group rows by",name:"groupBy",required:!1,type:{name:"GroupArg"}},groupValues:{defaultValue:null,description:`By default Tabulator will create groups for rows based on the values contained in the row data. if you want to explicitly define which field values groups should be created for at each level, you can use the groupValues option.

This option takes an array of value arrays, each item in the first array should be a list of acceptable field values for groups at that level`,name:"groupValues",required:!1,type:{name:"GroupValuesArg"}},groupHeader:{defaultValue:null,description:"You can use the setGroupHeader function to change the header generation function for each group. This function has one argument and takes the same values as passed to the groupHeader setup option.",name:"groupHeader",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},groupHeaderPrint:{defaultValue:null,description:"When printing you may want to apply a different group header from the one usually used in the table. You can now do this using the groupHeaderPrint table option, which takes the same inputs as the standard groupHeader property.",name:"groupHeaderPrint",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},groupStartOpen:{defaultValue:null,description:`You can set the default open state of groups using the groupStartOpen property* * This can take one of three possible values:

true - all groups start open (default value)
false - all groups start closed
function() - a callback to decide if a group should start open or closed
Group Open Function
If you want to decide on a group by group basis which should start open or closed then you can pass a function to the groupStartOpen property. This should return true if the group should start open or false if the group should start closed.`,name:"groupStartOpen",required:!1,type:{name:"boolean | boolean[] | ((value: any, count: number, data: any, group: GroupComponent) => boolean) | (boolean | ((value: any, count: number, data: any, group: GroupComponent) => boolean))[]"}},groupToggleElement:{defaultValue:null,description:`By default Tabulator allows users to toggle a group open or closed by clicking on the arrow icon in the left of the group header. If you would prefer a different behavior you can use the groupToggleElement option to choose a different option:* * The option can take one of three values:
arrow - toggle group on arrow element click
header - toggle group on click anywhere on the group header element
false - prevent clicking anywhere in the group toggling the group`,name:"groupToggleElement",required:!1,type:{name:'false | "header" | "arrow"'}},groupClosedShowCalcs:{defaultValue:null,description:"show/hide column calculations when group is closed.",name:"groupClosedShowCalcs",required:!1,type:{name:"boolean"}},groupUpdateOnCellEdit:{defaultValue:null,description:"",name:"groupUpdateOnCellEdit",required:!1,type:{name:"boolean"}},pagination:{defaultValue:null,description:"",name:"pagination",required:!1,type:{name:"boolean"}},paginationMode:{defaultValue:null,description:"",name:"paginationMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},paginationSize:{defaultValue:null,description:"Set the number of rows in each page.",name:"paginationSize",required:!1,type:{name:"number"}},paginationSizeSelector:{defaultValue:null,description:`Setting this option to true will cause Tabulator to create a list of page size options, that are multiples of the current page size. In the example below, the list will have the values of 5, 10, 15 and 20.

 When using the page size selector like this, if you use the setPageSize function to set the page size to a value not in the list, the list will be regenerated using the new page size as the starting valuer`,name:"paginationSizeSelector",required:!1,type:{name:"true | any[] | number[]"}},paginationElement:{defaultValue:null,description:"By default the pagination controls are added to the footer of the table. If you wish the controls to be created in another element pass a DOM node or a CSS selector for that element to the paginationElement option.",name:"paginationElement",required:!1,type:{name:"string | HTMLElement"}},dataReceiveParams:{defaultValue:null,description:`Lookup list to link expected data fields from the server to their function
\`\`\`typescript
default: {
  "current_page": "current_page",
  "last_page": "last_page",
  "data": "data",
  }
\`\`\``,name:"dataReceiveParams",required:!1,type:{name:"Record<string, string>"}},dataSendParams:{defaultValue:null,description:`Lookup list to link fields expected by the server to their function
\`\`\`typescript
default: {
  "page": "page",
  "size": "size",
  "sorters": "sorters",
  "filters": "filters",
}
\`\`\``,name:"dataSendParams",required:!1,type:{name:"Record<string, string>"}},paginationAddRow:{defaultValue:null,description:`When using the addRow function on a paginated table, rows will be added relative to the current page (ie to the top or bottom of the current page), with overflowing rows being shifted onto the next page.

If you would prefer rows to be added relative to the table (firs/last page) then you can use the paginationAddRow option. it can take one of two values:

page - add rows relative to current page (default)
table - add rows relative to the table`,name:"paginationAddRow",required:!1,type:{name:"enum",value:[{value:'"page"'},{value:'"table"'}]}},paginationCounter:{defaultValue:null,description:`You can choose to display a pagination counter in the bottom left of the footer that shows a summary of the current number of rows shown out of the total.
If you want to have a fully customized counter, then you can pass a function to the paginationCounter option

The formatter function accepts 5 arguments:

pageSize - Number of rows shown per page
currentRow - First visible row position
currentPage - Current page
totalRows - Total rows in table
totalPages - Total pages in table
The function must return the contents of the counter, either the text value of the counter, valid HTML or a DOM node`,name:"paginationCounter",required:!1,type:{name:'"rows" | "pages" | ((pageSize: number, currentRow: number, currentPage: number, totalRows: number, totalPages: number) => string | HTMLElement)'}},paginationCounterElement:{defaultValue:null,description:"By default the counter will be displayed in the left of the table footer. If you would like it displayed in another element pass a DOM node or a CSS selector for that element.",name:"paginationCounterElement",required:!1,type:{name:"string | HTMLElement"}},paginationButtonCount:{defaultValue:null,description:"The number of pagination page buttons shown in the footer using the paginationButtonCount option. By default this has a value of 5.",name:"paginationButtonCount",required:!1,type:{name:"number"}},paginationInitialPage:{defaultValue:null,description:"Specify that a specific page should be loaded when the table first load.",name:"paginationInitialPage",required:!1,type:{name:"number"}},persistenceID:{defaultValue:null,description:"ID tag used to identify persistent storage information.",name:"persistenceID",required:!1,type:{name:"string"}},persistenceMode:{defaultValue:null,description:`Persistence information can either be stored in a cookie or in the localStorage object, you can use the persistenceMode to choose which. It can take three possible values:

 local - (string) Store the persistence information in the localStorage object
 cookie - (string) Store the persistence information in a cookie
 true - (boolean) check if localStorage is available and store persistence information, otherwise store in cookie (Default option)`,name:"persistenceMode",required:!1,type:{name:'true | "local" | "cookie"'}},persistentLayout:{defaultValue:null,description:"Enable persistent storage of column layout information.",name:"persistentLayout",required:!1,type:{name:"boolean"}},persistentSort:{defaultValue:null,description:"You can ensure the data sorting is stored for the next page load by setting the persistentSort option to true.",name:"persistentSort",required:!1,type:{name:"boolean"}},persistentFilter:{defaultValue:null,description:"You can ensure the data filtering is stored for the next page load by setting the persistentFilter option to true.",name:"persistentFilter",required:!1,type:{name:"boolean"}},persistence:{defaultValue:null,description:"By setting the persistence property to true the table will persist the sort, filter, group (groupBy, groupStartOpen, groupHeader), pagination (paginationSize), and column (title, width, visibility, order) configuration of the table.",name:"persistence",required:!1,type:{name:"true | PersistenceOptions"}},persistenceWriterFunc:{defaultValue:null,description:"The persistenceWriterFunc function will receive three arguments, the persistance id of the table, the type of data to be written and an object or array representing the data",name:"persistenceWriterFunc",required:!1,type:{name:"((id: string, type: keyof PersistenceOptions, data: any) => any)"}},persistenceReaderFunc:{defaultValue:null,description:"The persistenceReaderFunc function will receive two arguments, the persistance id of the table, and the type of data to be written. This function must synchronously return the data in the format in which it was passed to the persistenceWriterFunc function. It should return a value of false if no data was present.",name:"persistenceReaderFunc",required:!1,type:{name:"((id: string, type: keyof PersistenceOptions) => any)"}},clipboard:{defaultValue:null,description:`You can enable clipboard functionality using the clipboard config option. It can take one of four possible values:
    true - enable clipboard copy and paste
    "copy" - enable only copy functionality
    "paste" - enable only paste functionality
    false - disable all clipboard functionality (default)`,name:"clipboard",required:!1,type:{name:'boolean | "copy" | "paste"'}},clipboardCopyRowRange:{defaultValue:null,description:"The clipboardCopyRowRange option takes a Row Range Lookup value and allows you to choose which rows are included in the clipboard output:",name:"clipboardCopyRowRange",required:!1,type:{name:"enum",value:[{value:'"visible"'},{value:'"all"'},{value:'"selected"'},{value:'"active"'},{value:'"range"'}]}},clipboardCopyFormatter:{defaultValue:null,description:'You can alter the finished output to the clipboard using the clipboardCopyFormatter callback. The callback function receives two arguments, the first is a string representing the type of content to be formatted (either "plain" or "html" depending on the type of data entering the clipboard). The second argument is the string that is about to be inserted into the clipboard. The function and should return a string that will be inserted into the clipboard.',name:"clipboardCopyFormatter",required:!1,type:{name:'"table" | ((type: "plain" | "html", output: string) => string)'}},clipboardCopyHeader:{defaultValue:null,description:"By default Tabulator will include the column header titles in any clipboard data, this can be turned off by passing a value of false to the clipboardCopyHeader property:",name:"clipboardCopyHeader",required:!1,type:{name:"boolean"}},clipboardPasteParser:{defaultValue:null,description:`Tabulator has one built in paste parser, that is designed to take a table formatted text string from the clipboard and turn it into row data. it breaks the data into rows on a newline character \\n and breaks the rows down to columns on a tab character \\t.
It will then attempt to work out which columns in the data correspond to columns in the table. It tries three different ways to achieve this. First it checks the values of all columns in the first row of data to see if they match the titles of columns in the table. If any of the columns don't match it then tries the same approach but with the column fields. If either of those options match, Tabulator will map those columns to the incoming data and import it into rows. If there is no match then Tabulator will assume the columns in the data are in the same order as the visible columns in the table and import them that way.

The inbuilt parser will reject any clipboard data that does not contain at least one row and two columns, in that case the clipboardPasteError will be triggered.

If you extend the clipboard module to add your own parser, you can set it to be used as default with the clipboardPasteParser property.
Built-in parsers are "table" and "range".`,name:"clipboardPasteParser",required:!1,type:{name:"string | ((clipboard: any) => any[])"}},clipboardPasteAction:{defaultValue:null,description:`Once the data has been parsed into row data, it will be passed to a paste action to be added to the table. There are three inbuilt paste actions:

insert - Inserts data into the table using the addRows function (default)
update - Updates data in the table using the updateOrAddData function
replace - replaces all data in the table using the setData function`,name:"clipboardPasteAction",required:!1,type:{name:"enum",value:[{value:'"update"'},{value:'"range"'},{value:'"insert"'},{value:'"replace"'}]}},clipboardCopyStyled:{defaultValue:null,description:`By default Tabulator will copy some of the tables styling along with the data to give a better visual appearance when pasted into other documents.

If you want to only copy the un-styled data then you should set the clipboardCopyStyled option to false in the table options object:`,name:"clipboardCopyStyled",required:!1,type:{name:"boolean"}},clipboardCopyConfig:{defaultValue:null,description:`By default Tabulator includes column headers, row groups and column calculations in the clipboard output.

You can choose to remove column headers groups, row groups or column calculations from the output data by setting the values in the clipboardCopyConfig option in the table definition:`,name:"clipboardCopyConfig",required:!1,type:{name:"boolean | AdditionalExportOptions"}},groupHeaderClipboard:{defaultValue:null,description:"When copying to clipboard you may want to apply a different group header from the one usually used in the table. You can now do this using the groupHeaderClipboard table option, which takes the same inputs as the standard groupHeader property.",name:"groupHeaderClipboard",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},groupHeaderHtmlOutput:{defaultValue:null,description:"When the getHtml function is called you may want to apply a different group header from the one usually used in the table. You can now do this using the groupHeaderHtmlOutput table option, which takes the same inputs as the standard groupHeader property.",name:"groupHeaderHtmlOutput",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},dataTree:{defaultValue:null,description:"To enable data trees in your table, set the dataTree property to true in your table constructor:",name:"dataTree",required:!1,type:{name:"boolean"}},dataTreeElementColumn:{defaultValue:null,description:"By default the toggle element will be inserted into the first column on the table. If you want the toggle element to be inserted in a different column you can pass the field name of the column to the dataTreeElementColumn setup option.",name:"dataTreeElementColumn",required:!1,type:{name:"string | boolean"}},dataTreeBranchElement:{defaultValue:null,description:"Show tree branch icon.",name:"dataTreeBranchElement",required:!1,type:{name:"string | boolean"}},dataTreeChildIndent:{defaultValue:null,description:"Tree level indent in pixels",name:"dataTreeChildIndent",required:!1,type:{name:"number"}},dataTreeChildField:{defaultValue:null,description:"By default Tabulator will look for child rows in the _children field of a row data object. You can change this to look in a different field using the dataTreeChildField property in your table constructor:",name:"dataTreeChildField",required:!1,type:{name:"string"}},dataTreeCollapseElement:{defaultValue:null,description:`The toggle button that allows users to collapse and expand the column can be customized to meet your needs. There are two options, dataTreeExpandElement and dataTreeCollapseElement, that can be set to replace the default toggle elements with your own.

Both options can take either an html string representing the contents of the toggle element`,name:"dataTreeCollapseElement",required:!1,type:{name:"string | boolean | HTMLElement"}},dataTreeExpandElement:{defaultValue:null,description:"The toggle button that allows users to expand the column.",name:"dataTreeExpandElement",required:!1,type:{name:"string | boolean | HTMLElement"}},dataTreeStartExpanded:{defaultValue:null,description:`By default all nodes on the tree will start collapsed, you can customize the initial expansion state of the tree using the dataTreeStartExpanded option.*
This option can take one of three possible value types, either a boolean to indicate whether all nodes should start expanded or collapsed:`,name:"dataTreeStartExpanded",required:!1,type:{name:"boolean | boolean[] | ((row: RowComponent, level: number) => boolean)"}},dataTreeSelectPropagate:{defaultValue:null,description:"Propagate selection events from parent rows to children.",name:"dataTreeSelectPropagate",required:!1,type:{name:"boolean"}},dataTreeFilter:{defaultValue:null,description:"",name:"dataTreeFilter",required:!1,type:{name:"boolean"}},dataTreeSort:{defaultValue:null,description:"",name:"dataTreeSort",required:!1,type:{name:"boolean"}},dataTreeChildColumnCalcs:{defaultValue:null,description:`When you are using the dataTree option with your table, the column calculations will by default only use the data for the top level rows and will ignore any children.
To include child rows in the column calculations set the dataTreeChildColumnCalcs option to true in the table constructor.`,name:"dataTreeChildColumnCalcs",required:!1,type:{name:"boolean"}},invalidOptionWarning:{defaultValue:null,description:"",name:"invalidOptionWarning",required:!1,type:{name:"boolean"}},debugInvalidOptions:{defaultValue:null,description:"Enabled by default this will provide a console warning if you are trying to set an option on the table that does not exist. With the new optional modular structure this is particularly valuable as it will prompt you if you are trying to use an option for a module that has not been installed",name:"debugInvalidOptions",required:!1,type:{name:"boolean"}},debugInitialization:{defaultValue:null,description:"Enabled by default this will provide a console warning if you try and call a function on the table before it has been initialized.",name:"debugInitialization",required:!1,type:{name:"boolean"}},debugEventsExternal:{defaultValue:null,description:"The debugEventsExternal option will create a console log for every external event that is fired so you can gain an understanding of which events you should be binding to.",name:"debugEventsExternal",required:!1,type:{name:"boolean"}},debugEventsInternal:{defaultValue:null,description:"The debugEventsInternal option will create a console log for every internal event that is fired so you can gain an understanding of which events you should be subscribing to in your modules.",name:"debugEventsInternal",required:!1,type:{name:"boolean"}},debugInvalidComponentFuncs:{defaultValue:null,description:"Disable component function warnings",name:"debugInvalidComponentFuncs",required:!1,type:{name:"boolean"}},debugDeprecation:{defaultValue:null,description:"Disable deprecation warnings",name:"debugDeprecation",required:!1,type:{name:"boolean"}},htmlOutputConfig:{defaultValue:null,description:"",name:"htmlOutputConfig",required:!1,type:{name:"AdditionalExportOptions"}},printAsHtml:{defaultValue:null,description:`By Default when a page is printed that includes a Tabulator it will be rendered on the page exactly as the table is drawn. While this ise useful in most cases, some users prefer to have more control over the print output, for example showing all rows of the table, instead of just those visible with the current position of the scroll bar.

Tabulator provides a print styling mode that will replace the Tabulator with an HTML table for the printout giving you much more control over the look and feel of the table for the print out., to enable this mode, set the printAsHtml option to true in the table constructor.

This will replace the table (in print outs only) with a simple HTML table with the class tabulator-print-table that you can use to style the table in any way you like.

It also has the benefit that because it is an HTML table, if it causes a page break your browser will automatically add the column headers in at the top of the next page.`,name:"printAsHtml",required:!1,type:{name:"boolean"}},printConfig:{defaultValue:null,description:`The HTML table will contain column header groups, row groups, and column calculations.

You can choose to remove any of these from the output data by setting the values in the printConfig option in the table definition`,name:"printConfig",required:!1,type:{name:"AdditionalExportOptions"}},printStyled:{defaultValue:null,description:"If you want your printed table to be styled to match your Tabulator you can set the printCopyStyle to true, this will copy key layout styling to the printed table.",name:"printStyled",required:!1,type:{name:"boolean"}},printRowRange:{defaultValue:null,description:"By default, only the rows currently visible in the Tabulator will be added to the HTML table. For custom row ranges it is also possible to pass a function into the printRowRange option that should return an array of Row Components",name:"printRowRange",required:!1,type:{name:"RowRangeLookup | (() => RowComponent[])"}},printHeader:{defaultValue:null,description:"You can use the printHeader table setup option to define a header to be displayed when the table is printed.",name:"printHeader",required:!1,type:{name:"StandardStringParam"}},printFooter:{defaultValue:null,description:"You can use the printFooter table setup option to define a footer to be displayed when the table is printed.",name:"printFooter",required:!1,type:{name:"StandardStringParam"}},printFormatter:{defaultValue:null,description:"The printFormatter table setup option allows you to carry out any manipulation of the print output before it is displayed to the user for printing.",name:"printFormatter",required:!1,type:{name:"((tableHolderElement: any, tableElement: any) => any)"}},groupHeaderDownload:{defaultValue:null,description:"",name:"groupHeaderDownload",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},spreadsheet:{defaultValue:null,description:`Enables the spreadsheet mode on the table.

The SpreadsheetModule must be installed to use this functionality.`,name:"spreadsheet",required:!1,type:{name:"boolean"}},spreadsheetRows:{defaultValue:null,description:"",name:"spreadsheetRows",required:!1,type:{name:"number"}},spreadsheetColumns:{defaultValue:null,description:"",name:"spreadsheetColumns",required:!1,type:{name:"number"}},spreadsheetColumnDefinition:{defaultValue:null,description:"",name:"spreadsheetColumnDefinition",required:!1,type:{name:"{ editor: string; resizable: string; }"}},spreadsheetSheets:{defaultValue:null,description:"",name:"spreadsheetSheets",required:!1,type:{name:"SpreadsheetSheet[]"}},spreadsheetSheetTabs:{defaultValue:null,description:"",name:"spreadsheetSheetTabs",required:!1,type:{name:"boolean"}},spreadsheetOutputFull:{defaultValue:null,description:"",name:"spreadsheetOutputFull",required:!1,type:{name:"boolean"}},dataTreeParentField:{defaultValue:null,description:"The parent key field name",name:"dataTreeParentField",required:!1,type:{name:"string | number"}},showHeaderFilter:{defaultValue:null,description:"Hide HeaderFilter when grid is initialized",name:"showHeaderFilter",required:!1,type:{name:"boolean"}},selectionMode:{defaultValue:null,description:"if true, use native tabulator selections rules without using active selection module",name:"selectionMode",required:!1,type:{name:"boolean"}},multiSelect:{defaultValue:null,description:"Allow multi select rows (default true)",name:"multiSelect",required:!1,type:{name:"boolean"}},onTableRef:{defaultValue:null,description:"On the tableRef ready callback",name:"onTableRef",required:!1,type:{name:"((ref: MutableRefObject<ITabulator>) => void)"}},events:{defaultValue:null,description:"Grid events",name:"events",required:!1,type:{name:"(Partial<EventCallBackMethods> & IActiveSelectionModuleTableEvents)"}},minWidth:{defaultValue:null,description:"Grid container max width",name:"minWidth",required:!1,type:{name:"string | number"}},maxWidth:{defaultValue:null,description:"Grid container max width",name:"maxWidth",required:!1,type:{name:"string | number"}},allowTextSelection:{defaultValue:null,description:"by default user text selection is disabled (CSS user-select='none')",name:"allowTextSelection",required:!1,type:{name:"boolean"}},updateColumnDefinition:{defaultValue:null,description:"",name:"updateColumnDefinition",required:!1,type:{name:"((column: ColumnLookup, definition: Partial<ColumnDefinition>) => Promise<void>)"}}}}}catch{}export{be as T};
