useState
1. state получает значение при вызове useState и больше не изменяется на всем пути выполнения функции (рендера компонента).
Даже если будет вызван setState, переменная state будет хранить то значение, которое она получила из useState до следующего ререндера (вызова функции компонента).
const [state, setState] = useState(false)
setState(true)
console.log(state) //выведет false

Если нужно получить актуальное значение до ререндера, то нужно использовать функцию в setState
setState((prevVal=>prevVal++))

2. вопреки расхожему мнению setState всегда вызывает ререндер, даже если устанавливаемое значение не изменилось.
const [state, setState] = useState(false)
setState(true) вызовет бесконечный цикл

3.
setState вызывать в момент рендера компонента можно только в том компоненте, в котором выполнен хук useState.
Если передать setState в другой компонент, то вызывать из него setState базового компонента можно только из useEffect или setTimeout(..., 0)/
Иначе react модет ругаться, что вызывается установка состояния до полного рендера базового компонента.

useCallback
Единственная ситуация когда его нужно использовать - когда необходима неизменяемая ссылка на функцию. 
Например, если функция используется как зависимость в useEffect или для подписки/отписки на события.
И то, возможно в данном случае лучше подойдет реализация useEvent от Dan Abramov.
В остальных случаях избегать.
Производительность не повышает. Функция в любом случае каждый раз создается, только будет еще постоянно проверять, не изменились ли зависимости хука
Плюс сложнее писать тесты. Если функция не использует хуки React, то ее можно вызывать везде. С хуками React можно вызывать только в React компонентах

useEvent от Дэна Абрамова
Всегда хранит неизменную ссылку на функцию.
Но использовать эту функцию можно только посли рендеринга (например, в useEffect или в пользовательских событиях).
В момент рендера может не иметь актуальной версии возвращаемой функции, если она тспользует другие хуки.

useMemo
нет смысла использовать, если возвращает просто статический объект.
Есть смысл использовать для сложных вычислений. Для простых смысла нет, накладные расходы на useMemo существенно больше.