import{j as d}from"./useToken-268f632d.js";import{B as M,e as I,D as P}from"./treeSelectFieldRender-af3d34ee.js";import"./index-092ccb3f.js";import"./dayjs.min-bd65d405.js";import{T as x,a as H}from"./tabulator-1212b158.js";import"./index-5819ae2c.js";import"./_commonjsHelpers-de833af9.js";import"./updateModalTheme-ee4dea50.js";import"./draggableRender-ff3f45b2.js";import"./index-e0a25a8d.js";import"./InfoCircleOutlined-14b312e0.js";import"./isNativeReflectConstruct-2f1897fe.js";import"./compact-item-e0eb0d02.js";import"./button-83f0aeae.js";import"./button-a395f6e7.js";import"./helpersString-59da762c.js";import"./v4-4a60fe23.js";import"./index-ba109c1e.js";import"./ExclamationCircleFilled-8e2dacf4.js";import"./context-acf775e7.js";import"./motion-3729e44c.js";import"./useClosable-7a147c6b.js";import"./useZIndex-9f7c196b.js";import"./KeyCode-6413d982.js";import"./pickAttrs-f49ef707.js";import"./zoom-f1d5320d.js";import"./PurePanel-a66be90d.js";import"./index-53e6b65f.js";import"./buttonsRow-300bee12.js";import"./Sider-f270e7a7.js";import"./row-353874ab.js";import"./roundedArrow-cf08b32b.js";import"./colors-dae18b42.js";import"./DownOutlined-7d62f4d3.js";import"./index-9d475cdf.js";import"./QuestionCircleOutlined-3fb4f056.js";import"./index-15561246.js";import"./index-762b8d87.js";import"./index-47c1009a.js";import"./statusUtils-8e8708fb.js";import"./SearchOutlined-826801c4.js";import"./select-15b31404.js";import"./tabulatorBase-35fae480.js";import"./client-36d50ed5.js";import"./styled-components.browser.esm-11e59584.js";import"./datePicker-93fadb6a.js";import"./quillEditor-99baaa8f.js";import"./_baseIsEqual-93bb5583.js";import"./iframe-b96babd3.js";import"../sb-preview/runtime.js";import"./MenuOutlined-207c5478.js";import"./_commonjs-dynamic-modules-302442b1.js";class L extends M{render(){return d.jsx(I,{field:this})}}const u=a=>d.jsx(P,{buttons:null,fieldsProps:{field1:{...a,component:L}}}),G=u;try{u.displayName="TabulatorGridComponent",u.__docgenInfo={description:"DForm TabulatorGrid field",displayName:"TabulatorGridComponent",props:{value:{defaultValue:null,description:"Default value",name:"value",required:!1,type:{name:"IGridRowData[]"}},resizeHeightWithForm:{defaultValue:null,description:"Auto resize height on form resize",name:"resizeHeightWithForm",required:!1,type:{name:"boolean"}},fetchInCreateMode:{defaultValue:null,description:"By default, when a form is in Create mode, it does not load data even if onDataFetch callback is provided. This option changes this behavior",name:"fetchInCreateMode",required:!1,type:{name:"boolean"}},component:{defaultValue:null,description:"Field React component",name:"component",required:!0,type:{name:"new (fieldName: string, fieldProps: any, model: DModel, parent?: IBaseField | undefined) => TabulatorGridField"}},helpClass:{defaultValue:null,description:"Help class",name:"helpClass",required:!1,type:{name:"string"}},label:{defaultValue:null,description:"Field label",name:"label",required:!1,type:{name:"ReactNode"}},placeholder:{defaultValue:null,description:`Field placeholder
No rows placeholder
placeholder element to display on empty table.`,name:"placeholder",required:!1,type:{name:"string | (string & HTMLElement) | (string & ((this: TabulatorFull | Tabulator) => string))"}},inlineGroup:{defaultValue:null,description:"inline group name",name:"inlineGroup",required:!1,type:{name:"string"}},hidden:{defaultValue:null,description:"If field default state is hidden",name:"hidden",required:!1,type:{name:"boolean"}},disabled:{defaultValue:null,description:"If field default state is disabled",name:"disabled",required:!1,type:{name:"boolean"}},readOnly:{defaultValue:null,description:`If field default state is readonly
Table can't be edited`,name:"readOnly",required:!1,type:{name:"boolean"}},dependsOn:{defaultValue:null,description:"List of fields that must be filled in order to display this field",name:"dependsOn",required:!1,type:{name:"string[]"}},width:{defaultValue:null,description:`Field width
Grid container width`,name:"width",required:!1,type:{name:"string | number"}},autoHeightResize:{defaultValue:null,description:"Field container height auto resize",name:"autoHeightResize",required:!1,type:{name:"boolean"}},autoFocus:{defaultValue:null,description:"Get focus by default",name:"autoFocus",required:!1,type:{name:"boolean"}},requiredMark:{defaultValue:null,description:"Mark Field Label as Required",name:"requiredMark",required:!1,type:{name:"boolean"}},tooltip:{defaultValue:null,description:"Config tooltip info",name:"tooltip",required:!1,type:{name:"LabelTooltipType"}},style:{defaultValue:null,description:"Field CSS style",name:"style",required:!1,type:{name:"CSSProperties"}},rowStyle:{defaultValue:null,description:"Row field container CSS style",name:"rowStyle",required:!1,type:{name:"CSSProperties"}},rules:{defaultValue:null,description:"Field validation rules",name:"rules",required:!1,type:{name:"IRuleType[]"}},onValueChanged:{defaultValue:null,description:"fires when the value of a field changed",name:"onValueChanged",required:!1,type:{name:"((value: unknown, prevValue: unknown, field: TabulatorGridField) => void)"}},onTouchedStateChanged:{defaultValue:null,description:"fires when the touched state of a field changed",name:"onTouchedStateChanged",required:!1,type:{name:"((state: boolean, field: TabulatorGridField) => void)"}},onDirtyStateChanged:{defaultValue:null,description:"fires when the dirty state of a field changed",name:"onDirtyStateChanged",required:!1,type:{name:"((state: boolean, field: TabulatorGridField) => void)"}},onErrorChanged:{defaultValue:null,description:"fires when the error of a field changed",name:"onErrorChanged",required:!1,type:{name:"((error: string, field: TabulatorGridField) => void)"}},onHiddenStateChanged:{defaultValue:null,description:"fires when the hidden state of a field changed",name:"onHiddenStateChanged",required:!1,type:{name:"((state: boolean, field: TabulatorGridField) => void)"}},onReadOnlyStateChanged:{defaultValue:null,description:"fires when read only state of a field changed",name:"onReadOnlyStateChanged",required:!1,type:{name:"((state: boolean, field: TabulatorGridField) => void)"}},onLabelChanged:{defaultValue:null,description:"fires when label of a field changed",name:"onLabelChanged",required:!1,type:{name:"((label: ReactNode, prevLabel: ReactNode, field: TabulatorGridField) => void)"}},onDisabledStateChanged:{defaultValue:null,description:"fires when the disable state of a field changes",name:"onDisabledStateChanged",required:!1,type:{name:"((state: boolean, field: TabulatorGridField) => void)"}},onReadyStateChanged:{defaultValue:null,description:"fires when a field is completely initialized, its data is loaded",name:"onReadyStateChanged",required:!1,type:{name:"((state: boolean, field: TabulatorGridField) => void)"}},onValidated:{defaultValue:null,description:"fires when a field validated",name:"onValidated",required:!1,type:{name:"((value: unknown, error: string, isSubmit: boolean, field: TabulatorGridField) => void)"}},onMenuVisibilityChanged:{defaultValue:null,description:"Fires when menu visibility status changed",name:"onMenuVisibilityChanged",required:!1,type:{name:"((isVisible: boolean, gridApi: IGridApi, field: TabulatorGridField) => void)"}},onDataLoading:{defaultValue:null,description:"Fires when dataSet loading starts (regardless of whether it is an ajax request or a ready-made dataSet is passed)",name:"onDataLoading",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi, field: TabulatorGridField) => void)"}},onDataLoaded:{defaultValue:null,description:"callback is triggered when a new set of data is loaded into the table (regardless of whether it is an ajax request or a ready-made dataSet is passed)",name:"onDataLoaded",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi, field: TabulatorGridField) => void)"}},onDataProcessed:{defaultValue:null,description:"The callback is triggered  after data has been processed and the table has been rendered.",name:"onDataProcessed",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi, field: TabulatorGridField) => void)"}},onDataLoadError:{defaultValue:null,description:"fires when the grid data loading failed",name:"onDataLoadError",required:!1,type:{name:"((message: string, code: number, gridApi: IGridApi, field: TabulatorGridField) => void)"}},onDataChanged:{defaultValue:null,description:"Fires before the data change (the data set updated, rows added/deleted, etc.)",name:"onDataChanged",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi, field: TabulatorGridField) => void)"}},onDataFetch:{defaultValue:null,description:"special callback used to fetch remote data. If not specified, the request will not be processed",name:"onDataFetch",required:!1,type:{name:"((params: IRequestProps, gridApi: IGridApi, field: TabulatorGridField) => IGridDataSourcePromise)"}},onDataFetching:{defaultValue:null,description:"Called before a data fetching begins. If it returns false, then the fetch is canceled",name:"onDataFetching",required:!1,type:{name:"((url: string, params: IRequestProps, gridApi: IGridApi, field: TabulatorGridField) => boolean)"}},onDataFetchResponse:{defaultValue:null,description:"Fires when a successful remote fetch request has been made. This callback can also be used to modify the received data before it is parsed by the table. If you use this callback it must return the data to be parsed by Tabulator, otherwise no data will be rendered.",name:"onDataFetchResponse",required:!1,type:{name:"((dataSet: IGridRowData[], params: IRequestProps, gridApi: IGridApi, field: TabulatorGridField) => IGridRowData[])"}},onSelectionChange:{defaultValue:null,description:"Callback executed when selected rows change",name:"onSelectionChange",required:!1,type:{name:"((data: IGridRowData[], rows: RowComponent[], selectedRows: RowComponent[], deselectedRows: RowComponent[], gridApi: IGridApi, field: TabulatorGridField) => void)"}},onDelete:{defaultValue:null,description:"Callback executed when selected rows delete",name:"onDelete",required:!1,type:{name:"((selectedRows: IGridRowData[], gridApi: IGridApi, field: TabulatorGridField) => void | IGridDeletePromise)"}},className:{defaultValue:null,description:"Grid class name",name:"className",required:!1,type:{name:"string"}},minWidth:{defaultValue:null,description:"Grid container max width",name:"minWidth",required:!1,type:{name:"string | number"}},maxWidth:{defaultValue:null,description:"Grid container max width",name:"maxWidth",required:!1,type:{name:"string | number"}},id:{defaultValue:null,description:`Grid Id
Grid ID`,name:"id",required:!1,type:{name:"string"}},height:{defaultValue:null,description:"Sets the height of the containing element, can be set to any valid height css value. If set to false (the default), the height of the table will resize to fit the table data.",name:"height",required:!1,type:{name:"string | number | false"}},footerElement:{defaultValue:null,description:"Grid footer element",name:"footerElement",required:!1,type:{name:"ReactNode"}},columns:{defaultValue:null,description:"Grid columns",name:"columns",required:!0,type:{name:"ITabulatorColumn[]"}},maxHeight:{defaultValue:null,description:"Can be set to any valid CSS value. By setting this you can allow your table to expand to fit the data, but not overflow its parent element. When there are too many rows to fit in the available space, the vertical scroll bar will be shown. This has the added benefit of improving load times on larger tables",name:"maxHeight",required:!1,type:{name:"string | number"}},minHeight:{defaultValue:null,description:"With a variable table height you can set the minimum height of the table either defined in the min-height CSS property for the element or set it using the minHeight option in the table constructor, this can be set to any valid CSS value.",name:"minHeight",required:!1,type:{name:"string | number"}},renderVertical:{defaultValue:null,description:"",name:"renderVertical",required:!1,type:{name:"RenderMode"}},renderHorizontal:{defaultValue:null,description:"",name:"renderHorizontal",required:!1,type:{name:"RenderMode"}},rowHeight:{defaultValue:null,description:"",name:"rowHeight",required:!1,type:{name:"number"}},renderVerticalBuffer:{defaultValue:null,description:"Manually set the size of the virtual DOM buffer.",name:"renderVerticalBuffer",required:!1,type:{name:"number | boolean"}},placeholderHeaderFilter:{defaultValue:null,description:"",name:"placeholderHeaderFilter",required:!1,type:{name:"string | HTMLElement | ((this: TabulatorFull | Tabulator) => string)"}},keybindings:{defaultValue:null,description:"Keybinding configuration object.",name:"keybindings",required:!1,type:{name:"false | KeyBinding"}},reactiveData:{defaultValue:null,description:`The reactivity systems allow Tabulator to watch arrays and objects passed into the table for changes and then automatically update the table.

This approach means you no longer need to worry about calling a number of different functions on the table to make changes, you simply update the array or object you originally passed into the table and Tabulator will take care of the rest.

You can enable reactive data by setting the reactiveData option to true in the table constructor, and then passing your data array to the data option.

Once the table is built any changes to the array will automatically be replicated to the table without needing to call any functions on the table itself`,name:"reactiveData",required:!1,type:{name:"boolean"}},autoResize:{defaultValue:null,description:"Tabulator will automatically attempt to redraw the data contained in the table if the containing element for the table is resized. To disable this functionality, set the autoResize property to false.",name:"autoResize",required:!1,type:{name:"boolean"}},tableBuilding:{defaultValue:null,description:"When a the tabulator constructor is called, the tableBuilding callback will triggered.",name:"tableBuilding",required:!1,type:{name:"(() => void)"}},tableBuilt:{defaultValue:null,description:"When a the tabulator constructor is called and the table has finished being rendered, the tableBuilt callback will triggered:",name:"tableBuilt",required:!1,type:{name:"(() => void)"}},renderStarted:{defaultValue:null,description:`The renderStarted callback is triggered whenever all the rows in the table are about to be rendered. This can include:
- Data is loaded into the table when setData is called
- A page is loaded through any form of pagination
- Rows are added to the table during progressive rendering
- Columns are changed by setColumns
- The data is filtered
- The data is sorted
- The redraw function is called`,name:"renderStarted",required:!1,type:{name:"(() => void)"}},renderComplete:{defaultValue:null,description:"The renderComplete callback is triggered after the table has been rendered.",name:"renderComplete",required:!1,type:{name:"(() => void)"}},htmlImporting:{defaultValue:null,description:"The htmlImporting callback is triggered when Tabulator starts importing data from an HTML table.",name:"htmlImporting",required:!1,type:{name:"EmptyCallback"}},htmlImported:{defaultValue:null,description:"The htmlImported callback is triggered when Tabulator finishes importing data from an HTML table.",name:"htmlImported",required:!1,type:{name:"EmptyCallback"}},dataChanged:{defaultValue:null,description:"The dataChanged callback is triggered whenever the table data is changed by the user. Triggers for this include editing any cell in the table, adding a row and deleting a row.",name:"dataChanged",required:!1,type:{name:"((data: any) => void)"}},pageLoaded:{defaultValue:null,description:"Whenever a page has been loaded, the pageLoaded callback is called, passing the current page number as an argument.",name:"pageLoaded",required:!1,type:{name:"((pageno: number) => void)"}},dataSorting:{defaultValue:null,description:"The dataSorting callback is triggered whenever a sort event occurs, before sorting happens.",name:"dataSorting",required:!1,type:{name:"((sorters: SorterFromTable[]) => void)"}},dataSorted:{defaultValue:null,description:"The dataSorted callback is triggered after the table dataset is sorted.",name:"dataSorted",required:!1,type:{name:"((sorters: SorterFromTable[], rows: RowComponent[]) => void)"}},invalidOptionWarnings:{defaultValue:null,description:"Setting the invalidOptionWarnings option to false will disable console warning messages for invalid properties in the table constructor and column definition object.",name:"invalidOptionWarnings",required:!1,type:{name:"boolean"}},scrollVertical:{defaultValue:null,description:"Callback is triggered when the table is vertically scrolled.",name:"scrollVertical",required:!1,type:{name:"((top: any) => void)"}},scrollHorizontal:{defaultValue:null,description:"Callback is triggered when the table is horizontally scrolled.",name:"scrollHorizontal",required:!1,type:{name:"((left: any) => void)"}},validationMode:{defaultValue:null,description:`There are now three different validation modes available to customize the validation experience:

blocking - if a user enters an invalid value while editing, they are blocked from leaving the cell until a valid value is entered (default)

highlight - if a user enters an invalid value, then the edit will complete as usual and they are allowed to exit the cell but a highlight is applied to the cell using the tabulator-validation-fail class

manual - no validation is automatically performed on edit, but it can be triggered by calling the validate function on the table or any Component Object`,name:"validationMode",required:!1,type:{name:"enum",value:[{value:'"blocking"'},{value:'"highlight"'},{value:'"manual"'}]}},textDirection:{defaultValue:null,description:"",name:"textDirection",required:!1,type:{name:"enum",value:[{value:'"auto"'},{value:'"ltr"'},{value:'"rtl"'}]}},rowContextMenu:{defaultValue:null,description:"",name:"rowContextMenu",required:!1,type:{name:"RowContextMenuSignature"}},rowClickMenu:{defaultValue:null,description:"",name:"rowClickMenu",required:!1,type:{name:"RowContextMenuSignature"}},rowDblClickMenu:{defaultValue:null,description:"",name:"rowDblClickMenu",required:!1,type:{name:"RowContextMenuSignature"}},groupClickMenu:{defaultValue:null,description:"",name:"groupClickMenu",required:!1,type:{name:"GroupContextMenuSignature"}},groupDblClickMenu:{defaultValue:null,description:"",name:"groupDblClickMenu",required:!1,type:{name:"GroupContextMenuSignature"}},groupContextMenu:{defaultValue:null,description:"",name:"groupContextMenu",required:!1,type:{name:"MenuObject<GroupComponent>[]"}},popupContainer:{defaultValue:null,description:"",name:"popupContainer",required:!1,type:{name:"string | boolean | HTMLElement"}},groupClickPopup:{defaultValue:null,description:"",name:"groupClickPopup",required:!1,type:{name:"string"}},groupContextPopup:{defaultValue:null,description:"",name:"groupContextPopup",required:!1,type:{name:"string"}},groupDblPopup:{defaultValue:null,description:"",name:"groupDblPopup",required:!1,type:{name:"string"}},groupDblClickPopup:{defaultValue:null,description:"",name:"groupDblClickPopup",required:!1,type:{name:"string"}},rowClickPopup:{defaultValue:null,description:"",name:"rowClickPopup",required:!1,type:{name:"string"}},rowContextPopup:{defaultValue:null,description:"",name:"rowContextPopup",required:!1,type:{name:"string"}},rowDblClickPopup:{defaultValue:null,description:"",name:"rowDblClickPopup",required:!1,type:{name:"string"}},history:{defaultValue:null,description:"Enable user interaction history functionality",name:"history",required:!1,type:{name:"boolean"}},historyUndo:{defaultValue:null,description:"The historyUndo event is triggered when the undo action is triggered.",name:"historyUndo",required:!1,type:{name:"((action: HistoryAction, component: RowComponent | CellComponent, data: any) => void)"}},historyRedo:{defaultValue:null,description:"The historyRedo event is triggered when the redo action is triggered.",name:"historyRedo",required:!1,type:{name:"((action: HistoryAction, component: RowComponent | CellComponent, data: any) => void)"}},locale:{defaultValue:null,description:"You can set the current local in one of two ways. If you want to set it when the table is created, simply include the locale option in your Tabulator constructor. You can either pass in a string matching one of the language options you have defined, or pass in the boolean true which will cause Tabulator to auto-detect the browsers language settings from the navigator.language object.",name:"locale",required:!1,type:{name:"string | boolean"}},langs:{defaultValue:null,description:`You can store as many languages as you like, creating an object inside the langs object with a property of the locale code for that language. A list of locale codes can be found here.

At present there are three parts of the table that can be localized, the column headers, the header filter placeholder text and the pagination buttons. To localize the pagination buttons, create a pagination property inside your language object and give it the properties outlined below.

If you wish you can also localize column titles by adding a columns property to your language object. You should store a property of the field name of the column you wish to change, with a value of its title. Any fields that match this will use this title instead of the one provided by the column definition array.`,name:"langs",required:!1,type:{name:"any"}},localized:{defaultValue:null,description:"When a localization event has occurred , the localized callback will triggered, passing the current locale code and language object:",name:"localized",required:!1,type:{name:"((locale: string, lang: any) => void)"}},downloadEncoder:{defaultValue:null,description:`Allows you to intercept the download file data before the users is prompted to save the file.

In order for the download to proceed the downloadReady callback is expected to return a blob of file to be downloaded.

If you would prefer to abort the download you can return false from this callback. This could be useful for example if you want to send the created file to a server via ajax rather than allowing the user to download the file.`,name:"downloadEncoder",required:!1,type:{name:"((fileContents: any, mimeType: string) => false | Blob)"}},downloadComplete:{defaultValue:null,description:"The downloadComplete callback is triggered when the user has been prompted to download the file.",name:"downloadComplete",required:!1,type:{name:"(() => void)"}},downloadConfig:{defaultValue:null,description:`By default Tabulator includes column headers, row groups and column calculations in the download output.

You can choose to remove column headers groups, row groups or column calculations from the output data by setting the values in the downloadConfig option in the table definition:`,name:"downloadConfig",required:!1,type:{name:"AdditionalExportOptions"}},downloadRowRange:{defaultValue:null,description:"By default, only the active rows (rows that have passed filtering) will be included in the download the downloadRowRange option takes a Row Range Lookup value and allows you to choose which rows are included in the download output.",name:"downloadRowRange",required:!1,type:{name:"enum",value:[{value:'"visible"'},{value:'"active"'},{value:'"selected"'},{value:'"all"'}]}},autoColumns:{defaultValue:null,description:"If you set the autoColumns option to true, every time data is loaded into the table through the data option or through the setData function, Tabulator will examine the first row of the data and build columns to match that data.",name:"autoColumns",required:!1,type:{name:"boolean"}},autoColumnsDefinitions:{defaultValue:null,description:"",name:"autoColumnsDefinitions",required:!1,type:{name:"((columnDefinitions?: ColumnDefinition[]) => ColumnDefinition[]) | ColumnDefinition[] | Record<string, Partial<ColumnDefinition>>"}},layout:{defaultValue:null,description:"By default Tabulator will use the fitData layout mode, which will resize the tables columns to fit the data held in each column, unless you specify a width or minWidth in the column constructor. If the width of all columns exceeds the width of the containing element, a scroll bar will appear.",name:"layout",required:!1,type:{name:"enum",value:[{value:'"fitData"'},{value:'"fitColumns"'},{value:'"fitDataFill"'},{value:'"fitDataStretch"'},{value:'"fitDataTable"'}]}},layoutColumnsOnNewData:{defaultValue:null,description:`To keep the layout of the columns consistent, once the column widths have been set on the first data load (either from the data property in the constructor or the setData function) they will not be changed when new data is loaded.

If you would prefer that the column widths adjust to the data each time you load it into the table you can set the layoutColumnsOnNewData property to true.`,name:"layoutColumnsOnNewData",required:!1,type:{name:"boolean"}},responsiveLayout:{defaultValue:null,description:`Responsive layout will automatically hide/show columns to fit the width of the Tabulator element. This allows for clean rendering of tables on smaller mobile devices, showing important data while avoiding horizontal scroll bars. You can enable responsive layouts using the responsiveLayout option.

There are two responsive layout modes available:

hide - hide columns that no longer fit in the table
collapse - collapse columns that no longer fit on the table into a list under the row

Hide Extra Columns
By default, columns will be hidden from right to left as the width of the table decreases. You can choose exactly how columns are hidden using the responsive property in the column definition object.

When responsive layout is enabled, all columns are given a default responsive value of 1. The higher you set this value the sooner that column will be hidden as the table width decreases. If two columns have the same responsive value then they are hidden from right to left (as defined in the column definition array, ignoring user moving of the columns). If you set the value to 0 then the column will never be hidden regardless of how narrow the table gets.`,name:"responsiveLayout",required:!1,type:{name:'boolean | "hide" | "collapse"'}},responsiveLayoutCollapseStartOpen:{defaultValue:null,description:"Collapsed lists are displayed to the user by default, if you would prefer they start closed so the user can open them you can use the responsiveLayoutCollapseStartOpen option.",name:"responsiveLayoutCollapseStartOpen",required:!1,type:{name:"boolean"}},responsiveLayoutCollapseUseFormatters:{defaultValue:null,description:`By default any formatter set on the column is applied to the value that will appear in the list. while this works for most formatters it can cause issues with the progress formatter which relies on being inside a cell.

If you would like to disable column formatting in the collapsed list, you can use the responsiveLayoutCollapseUseFormatters option:`,name:"responsiveLayoutCollapseUseFormatters",required:!1,type:{name:"boolean"}},responsiveLayoutCollapseFormatter:{defaultValue:null,description:`If you set the responsiveLayout option to collapse the values from hidden columns will be displayed in a title/value list under the row.

In this mode an object containing the title of each hidden column and its value is generated and then used to generate a list displayed in a div .tabulator-responsive-collapse under the row data.

The inbuilt collapse formatter creates a table to neatly display the hidden columns. If you would like to format the data in your own way you can use the responsiveLayoutCollapseFormatter, it take an object of the column values as an argument and must return the HTML content of the div.

This function should return an empty string if there is no data to display.`,name:"responsiveLayoutCollapseFormatter",required:!1,type:{name:"((data: any[]) => any)"}},movableColumns:{defaultValue:null,description:"To allow the user to move columns along the table, set the movableColumns parameter in the options:",name:"movableColumns",required:!1,type:{name:"boolean"}},columnHeaderVertAlign:{defaultValue:null,description:"You can use the columnHeaderVertAlign option to set how the text in your column headers should be vertically.",name:"columnHeaderVertAlign",required:!1,type:{name:"enum",value:[{value:'"top"'},{value:'"middle"'},{value:'"bottom"'}]}},scrollToColumnPosition:{defaultValue:null,description:`The default ScrollTo position can be set using the scrollToColumnPosition option. It can take one of three possible values:

left - position column with its left edge at the left of the table (default)
center - position column with its left edge in the center of the table
right - position column with its right edge at the right of the table`,name:"scrollToColumnPosition",required:!1,type:{name:"enum",value:[{value:'"middle"'},{value:'"left"'},{value:'"center"'},{value:'"right"'}]}},scrollToColumnIfVisible:{defaultValue:null,description:`The default option for triggering a ScrollTo on a visible element can be set using the scrollToColumnIfVisible option. It can take a boolean value:

true - scroll to column, even if it is visible (default)
false - scroll to column, unless it is currently visible, then don't move`,name:"scrollToColumnIfVisible",required:!1,type:{name:"boolean"}},columnCalcs:{defaultValue:null,description:`By default column calculations are shown at the top and bottom of the table, unless row grouping is enabled, in which case they are shown at the top and bottom of each group.

The columnCalcs option lets you decided where the calculations should be displayed, it can take one of four values:

true - show calcs at top and bottom of the table, unless grouped, then show in groups (boolean, default)
both - show calcs at top and bottom of the table and show in groups
table - show calcs at top and bottom of the table only
group - show calcs in groups only`,name:"columnCalcs",required:!1,type:{name:'boolean | "both" | "table" | "group"'}},nestedFieldSeparator:{defaultValue:null,description:`If you need to use the . character as part of your field name, you can change the separator to any other character using the nestedFieldSeparator option
Set to false to disable nested data parsing`,name:"nestedFieldSeparator",required:!1,type:{name:"string | boolean"}},columnHeaderSortMulti:{defaultValue:null,description:"multiple or single column sorting",name:"columnHeaderSortMulti",required:!1,type:{name:"boolean"}},columnMoved:{defaultValue:null,description:"The columnMoved callback will be triggered when a column has been successfully moved.",name:"columnMoved",required:!1,type:{name:"((column: ColumnComponent, columns: any[]) => void)"}},columnResized:{defaultValue:null,description:"",name:"columnResized",required:!1,type:{name:"((column: ColumnComponent) => void)"}},columnVisibilityChanged:{defaultValue:null,description:"The columnVisibilityChanged callback is triggered whenever a column changes between hidden and visible states.",name:"columnVisibilityChanged",required:!1,type:{name:"((column: ColumnComponent, visible: boolean) => void)"}},columnTitleChanged:{defaultValue:null,description:"The columnTitleChanged callback is triggered whenever a user edits a column title when the editableTitle parameter has been enabled in the column definition array.",name:"columnTitleChanged",required:!1,type:{name:"((column: ColumnComponent) => void)"}},headerVisible:{defaultValue:null,description:"By setting the headerVisible option to false you can hide the column headers and present the table as a simple list if needed.",name:"headerVisible",required:!1,type:{name:"boolean"}},headerSort:{defaultValue:null,description:"The headerSort option can now be set in the table options to affect all columns as well as in column definitions.",name:"headerSort",required:!1,type:{name:"boolean"}},headerSortElement:{defaultValue:null,description:"",name:"headerSortElement",required:!1,type:{name:'string | ((column: ColumnComponent, dir: "asc" | "desc" | "none") => any)'}},columnDefaults:{defaultValue:null,description:"",name:"columnDefaults",required:!1,type:{name:"Partial<ColumnDefinition>"}},resizableColumnFit:{defaultValue:null,description:"If set to true, then when you resize a column its neighbouring column has the opposite resize applied to keep to total width of columns the same",name:"resizableColumnFit",required:!1,type:{name:"boolean"}},rowFormatter:{defaultValue:null,description:`Tabulator also allows you to define a row level formatter using the rowFormatter option. this lets you alter each row of the table based on the data it contains.
The function accepts one argument, the RowComponent for the row being formatted.`,name:"rowFormatter",required:!1,type:{name:"((row: RowComponent) => any)"}},rowFormatterPrint:{defaultValue:null,description:"When printing you may want to apply a different formatter may want to apply a different formatter from the one usually used to format the row.",name:"rowFormatterPrint",required:!1,type:{name:"false | ((row: RowComponent) => any)"}},rowFormatterHtmlOutput:{defaultValue:null,description:"When the getHtml function is called you may want to apply a different formatter may want to apply a different formatter from the one usually used to format the row",name:"rowFormatterHtmlOutput",required:!1,type:{name:"false | ((row: RowComponent) => any)"}},rowFormatterClipboard:{defaultValue:null,description:"When copying to the clipboard you may want to apply a different formatter may want to apply a different formatter from the one usually used to format the row. You can now do this using the rowFormatterClipboard table option, which takes the same inputs as the standard rowFormatter property. Passing a value of false into the formatter prevent the default row formatter from being run when the table is copied to the clipboard.",name:"rowFormatterClipboard",required:!1,type:{name:"false | ((row: RowComponent) => any)"}},addRowPos:{defaultValue:null,description:'The position in the table for new rows to be added, "bottom" or "top".',name:"addRowPos",required:!1,type:{name:"enum",value:[{value:'"top"'},{value:'"bottom"'}]}},selectable:{defaultValue:null,description:`The selectable option can take one of a several values:
false - selectable rows are disabled
true - selectable rows are enabled, and you can select as many as you want
integer - any integer value, this sets the maximum number of rows that can be selected (when the maximum number of selected rows is exceeded, the first selected row will be deselected to allow the next row to be selected).
"highlight" (default) - rows have the same hover stylings as selectable rows but do not change state when clicked. This is great for when you want to show that a row is clickable but don't want it to be selectable.`,name:"selectable",required:!1,type:{name:'number | boolean | "highlight"'}},selectableRangeMode:{defaultValue:null,description:`By default you can select a range of rows by holding down the shift key and click dragging over a number of rows to toggle the selected state state of all rows the cursor passes over.

If you would prefer to select a range of row by clicking on the first row then holding down shift and clicking on the end row then you can achieve this by setting the selectableRangeMode to click`,name:"selectableRangeMode",required:!1,type:{name:"enum",value:[{value:'"click"'}]}},selectableRollingSelection:{defaultValue:null,description:"By default, row selection works on a rolling basis, if you set the selectable option to a numeric value then when you select past this number of rows, the first row to be selected will be deselected. If you want to disable this behavior and instead prevent selection of new rows once the limit is reached you can set the selectableRollingSelection option to false.",name:"selectableRollingSelection",required:!1,type:{name:"boolean"}},selectablePersistence:{defaultValue:null,description:"By default Tabulator will maintain selected rows when the table is filtered, sorted or paginated (but NOT when the setData function is used). If you want the selected rows to be cleared whenever the table view is updated then set the selectablePersistence option to false.",name:"selectablePersistence",required:!1,type:{name:"boolean"}},selectableCheck:{defaultValue:null,description:"You many want to exclude certain rows from being selected. The selectableCheck options allows you to pass a function to check if the current row should be selectable, returning true will allow row selection, false will result in nothing happening. The function should accept a RowComponent as its first argument.",name:"selectableCheck",required:!1,type:{name:"((row: RowComponent) => boolean)"}},movableRows:{defaultValue:null,description:"To allow the user to move rows up and down the table, set the movableRows parameter in the options:",name:"movableRows",required:!1,type:{name:"boolean"}},movableRowsConnectedTables:{defaultValue:null,description:"Tabulator also allows you to move rows between tables. To enable this you should supply either a valid CSS selector string a DOM node for the table or the Tabulator object for the table to the movableRowsConnectedTables option. if you want to connect to multiple tables then you can pass in an array of values to this option.",name:"movableRowsConnectedTables",required:!1,type:{name:"string | HTMLElement | string[] | HTMLElement[]"}},movableRowsSender:{defaultValue:null,description:`The movableRowsSender option should be set on the sending table, and sets the action that should be taken after the row has been successfully dropped into the receiving table.
There are several inbuilt sender functions:

- false - do nothing(default)
- delete - deletes the row from the table
You can also pass a callback to the movableRowsSender option for custom sender functionality`,name:"movableRowsSender",required:!1,type:{name:'false | "delete" | ((fromRow: RowComponent, toRow: RowComponent, toTable: Tabulator) => any)'}},movableRowsReceiver:{defaultValue:null,description:`The movableRowsReceiver option should be set on the receiving tables, and sets the action that should be taken when the row is dropped into the table.
There are several inbuilt receiver functions:

- insert - inserts row next to the row it was dropped on, if not dropped on a row it is added to the table (default)
- add - adds row to the table
- update - updates the row it is dropped on with the sent rows data
- replace - replaces the row it is dropped on with the sent row`,name:"movableRowsReceiver",required:!1,type:{name:'"insert" | "add" | "update" | "replace" | ((fromRow: RowComponent, toRow: RowComponent, fromTable: Tabulator) => any)'}},movableRowsConnectedElements:{defaultValue:null,description:"",name:"movableRowsConnectedElements",required:!1,type:{name:"string | HTMLElement"}},movableRowsElementDrop:{defaultValue:null,description:"When a row is dropped on element from from the movableRowsConnectedElements option the movableRowsElementDrop callback will be triggered. You can use this callback to trigger any changes as a result of the drop",name:"movableRowsElementDrop",required:!1,type:{name:"((e: MouseEvent, element: HTMLElement, row: RowComponent) => any)"}},scrollToRowPosition:{defaultValue:null,description:`The default ScrollTo position can be set using the scrollToRowPosition option. It can take one of four possible values:

top - position row with its top edge at the top of the table (default)
center - position row with its top edge in the center of the table
bottom - position row with its bottom edge at the bottom of the table
nearest - position row on the edge of the table it is closest to`,name:"scrollToRowPosition",required:!1,type:{name:"enum",value:[{value:'"top"'},{value:'"bottom"'},{value:'"center"'},{value:'"nearest"'}]}},scrollToRowIfVisible:{defaultValue:null,description:`The default option for triggering a ScrollTo on a visible element can be set using the scrollToRowIfVisible option. It can take a boolean value:

true - scroll to row, even if it is visible (default)
false - scroll to row, unless it is currently visible, then don't move`,name:"scrollToRowIfVisible",required:!1,type:{name:"boolean"}},dataTreeRowExpanded:{defaultValue:null,description:"The dataTreeRowExpanded callback is triggered when a row with child rows is expanded to reveal the children.",name:"dataTreeRowExpanded",required:!1,type:{name:"((row: RowComponent, level: number) => void)"}},dataTreeRowCollapsed:{defaultValue:null,description:"The dataTreeRowCollapsed callback is triggered when a row with child rows is collapsed to hide its children.",name:"dataTreeRowCollapsed",required:!1,type:{name:"((row: RowComponent, level: number) => void)"}},movableRowsSendingStart:{defaultValue:null,description:"The movableRowsSendingStart callback is triggered on the sending table when a row is picked up from a sending table.",name:"movableRowsSendingStart",required:!1,type:{name:"((toTables: any[]) => void)"}},movableRowsSent:{defaultValue:null,description:"The movableRowsSent callback is triggered on the sending table when a row has been successfully received by a receiving table.",name:"movableRowsSent",required:!1,type:{name:"((fromRow: RowComponent, toRow: RowComponent, toTable: Tabulator) => void)"}},movableRowsSentFailed:{defaultValue:null,description:"The movableRowsSentFailed callback is triggered on the sending table when a row has failed to be received by the receiving table.",name:"movableRowsSentFailed",required:!1,type:{name:"((fromRow: RowComponent, toRow: RowComponent, toTable: Tabulator) => void)"}},movableRowsSendingStop:{defaultValue:null,description:"The movableRowsSendingStop callback is triggered on the sending table after a row has been dropped and any senders and receivers have been handled.",name:"movableRowsSendingStop",required:!1,type:{name:"((toTables: any[]) => void)"}},movableRowsReceivingStart:{defaultValue:null,description:"The movableRowsReceivingStart callback is triggered on a receiving table when a connection is established with a sending table.",name:"movableRowsReceivingStart",required:!1,type:{name:"((fromRow: RowComponent, toTable: Tabulator) => void)"}},movableRowsReceived:{defaultValue:null,description:"The movableRowsReceived callback is triggered on a receiving table when a row has been successfully received.",name:"movableRowsReceived",required:!1,type:{name:"((fromRow: RowComponent, toRow: RowComponent, fromTable: Tabulator) => void)"}},movableRowsReceivedFailed:{defaultValue:null,description:"The movableRowsReceivedFailed callback is triggered on a receiving table when a row receiver has returned false.",name:"movableRowsReceivedFailed",required:!1,type:{name:"((fromRow: RowComponent, toRow: RowComponent, fromTable: Tabulator) => void)"}},movableRowsReceivingStop:{defaultValue:null,description:"The movableRowsReceivingStop callback is triggered on a receiving table after a row has been dropped and any senders and receivers have been handled.",name:"movableRowsReceivingStop",required:!1,type:{name:"((fromTable: Tabulator) => void)"}},rowClick:{defaultValue:null,description:"The rowClick callback is triggered when a user clicks on a row.",name:"rowClick",required:!1,type:{name:"RowEventCallback"}},rowDblClick:{defaultValue:null,description:"The rowDblClick callback is triggered when a user double clicks on a row.",name:"rowDblClick",required:!1,type:{name:"RowEventCallback"}},rowContext:{defaultValue:null,description:`The rowContext callback is triggered when a user right clicks on a row.
If you want to prevent the browsers context menu being triggered in this event you will need to include the preventDefault() function in your callback.`,name:"rowContext",required:!1,type:{name:"RowEventCallback"}},rowTap:{defaultValue:null,description:"The rowTap callback is triggered when a user taps on a row on a touch display.",name:"rowTap",required:!1,type:{name:"RowEventCallback"}},rowDblTap:{defaultValue:null,description:"The rowDblTap callback is triggered when a user taps on a row on a touch display twice in under 300ms.",name:"rowDblTap",required:!1,type:{name:"RowEventCallback"}},rowTapHold:{defaultValue:null,description:"The rowTapHold callback is triggered when a user taps on a row on a touch display and holds their finger down for over 1 second.",name:"rowTapHold",required:!1,type:{name:"RowEventCallback"}},rowMouseEnter:{defaultValue:null,description:"The rowMouseEnter callback is triggered when the mouse pointer enters a row.",name:"rowMouseEnter",required:!1,type:{name:"RowEventCallback"}},rowMouseLeave:{defaultValue:null,description:"The rowMouseLeave callback is triggered when the mouse pointer leaves a row.",name:"rowMouseLeave",required:!1,type:{name:"RowEventCallback"}},rowMouseOver:{defaultValue:null,description:"The rowMouseOver callback is triggered when the mouse pointer enters a row or any of its child elements.",name:"rowMouseOver",required:!1,type:{name:"RowEventCallback"}},rowMouseOut:{defaultValue:null,description:"The rowMouseOut callback is triggered when the mouse pointer leaves a row or any of its child elements.",name:"rowMouseOut",required:!1,type:{name:"RowEventCallback"}},rowMouseMove:{defaultValue:null,description:"The rowMouseMove callback is triggered when the mouse pointer moves over a row.",name:"rowMouseMove",required:!1,type:{name:"RowEventCallback"}},rowAdded:{defaultValue:null,description:"The rowAdded callback is triggered when a row is added to the table by the addRow and updateOrAddRow functions.",name:"rowAdded",required:!1,type:{name:"RowChangedCallback"}},rowUpdated:{defaultValue:null,description:"The rowUpdated callback is triggered when a row is updated by the updateRow, updateOrAddRow, updateData or updateOrAddData, functions.",name:"rowUpdated",required:!1,type:{name:"RowChangedCallback"}},rowDeleted:{defaultValue:null,description:"The rowDeleted callback is triggered when a row is deleted from the table by the deleteRow function.",name:"rowDeleted",required:!1,type:{name:"RowChangedCallback"}},rowMoved:{defaultValue:null,description:"The rowMoved callback will be triggered when a row has been successfully moved.",name:"rowMoved",required:!1,type:{name:"RowChangedCallback"}},rowResized:{defaultValue:null,description:"The rowResized callback will be triggered when a row has been resized by the user.",name:"rowResized",required:!1,type:{name:"RowChangedCallback"}},rowSelectionChanged:{defaultValue:null,description:"Whenever the number of selected rows changes, through selection or deselection, the rowSelectionChanged event is triggered. This passes an array of the data objects for each row in the order they were selected as the first argument, and an array of row components for each of the rows in order of selection as the second argument.",name:"rowSelectionChanged",required:!1,type:{name:"((data: any[], rows: RowComponent[]) => void)"}},rowSelected:{defaultValue:null,description:"The rowSelected event is triggered when a row is selected, either by the user or programmatically.",name:"rowSelected",required:!1,type:{name:"RowChangedCallback"}},rowDeselected:{defaultValue:null,description:"The rowDeselected event is triggered when a row is deselected, either by the user or programmatically.",name:"rowDeselected",required:!1,type:{name:"RowChangedCallback"}},tabEndNewRow:{defaultValue:null,description:"Allows you to specify the behavior when the user tabs from the last editable cell on the last row of the table.",name:"tabEndNewRow",required:!1,type:{name:"boolean | JSONRecord | ((row: RowComponent) => any)"}},frozenRowsField:{defaultValue:null,description:"",name:"frozenRowsField",required:!1,type:{name:"string"}},frozenRows:{defaultValue:null,description:"Freeze rows of data",name:"frozenRows",required:!1,type:{name:"number | string[] | ((row: RowComponent) => boolean)"}},index:{defaultValue:null,description:"A unique index value should be present for each row of data if you want to be able to programmatically alter that data at a later point, this should be either numeric or a string. By default Tabulator will look for this value in the id field for the data. If you wish to use a different field as the index, set this using the index option parameter.",name:"index",required:!1,type:{name:"string | number"}},importFormat:{defaultValue:null,description:"",name:"importFormat",required:!1,type:{name:'"array" | "csv" | "json" | ((fileContents: string) => unknown[])'}},importReader:{defaultValue:null,description:"By default Tabulator will read in the file as plain text, which is the format used by all the built in importers. If you need to read the file data in a different format then you can use the importReader option to instruct the file reader to read in the file in a different format.",name:"importReader",required:!1,type:{name:"enum",value:[{value:'"binary"'},{value:'"buffer"'},{value:'"text"'},{value:'"url"'}]}},autoTables:{defaultValue:null,description:"",name:"autoTables",required:!1,type:{name:"boolean"}},ajaxParams:{defaultValue:null,description:"Parameters to be passed to remote Ajax data loading request.",name:"ajaxParams",required:!1,type:{name:"{}"}},ajaxConfig:{defaultValue:null,description:"The HTTP request type for Ajax requests or config object for the request.",name:"ajaxConfig",required:!1,type:{name:"HttpMethod | AjaxConfig"}},ajaxContentType:{defaultValue:null,description:`When using a request method other than "GET" Tabulator will send any parameters with a content type of form data. You can change the content type with the ajaxContentType option. This will ensure parameters are sent in the format you expect, with the correct headers. * * The ajaxContentType option can take one of two values:
"form" - send parameters as form data (default option)
"json" - send parameters as JSON encoded string
If you want to use a custom content type then you can pass a content type formatter object into the ajaxContentType option. this object must have two properties, the headers property should contain all headers that should be sent with the request and the body property should contain a function that returns the body content of the request`,name:"ajaxContentType",required:!1,type:{name:'"form" | "json" | AjaxContentType'}},ajaxURLGenerator:{defaultValue:null,description:`If you need more control over the url of the request that you can get from the ajaxURL and ajaxParams properties, the you can use the ajaxURLGenerator property to pass in a callback that will generate the URL for you.

The callback should return a string representing the URL to be requested.`,name:"ajaxURLGenerator",required:!1,type:{name:"((url: string, config: any, params: any) => string)"}},ajaxFiltering:{defaultValue:null,description:"Send filter config to server instead of processing locally",name:"ajaxFiltering",required:!1,type:{name:"boolean"}},ajaxSorting:{defaultValue:null,description:"Send sorter config to server instead of processing locally",name:"ajaxSorting",required:!1,type:{name:"boolean"}},progressiveLoad:{defaultValue:null,description:`If you are loading a lot of data from a remote source into your table in one go, it can sometimes take a long time for the server to return the request, which can slow down the user experience.

To speed things up in this situation Tabulator has a progressive load mode, this uses the pagination module to make a series of requests for part of the data set, one at a time, appending it to the table as the data arrives. This mode can be enable using the ajaxProgressiveLoad option. No pagination controls will be visible on screen, it just reuses the functionality of the pagination module to sequentially load the data.

With this mode enabled, all of the settings outlined in the Ajax Documentation are still available

There are two different progressive loading modes, to give you a choice of how data is loaded into the table.`,name:"progressiveLoad",required:!1,type:{name:"enum",value:[{value:'"load"'},{value:'"scroll"'}]}},progressiveLoadDelay:{defaultValue:null,description:"By default tabulator will make the requests to fill the table as quickly as possible. On some servers these repeats requests from the same client may trigger rate limiting or security systems. In this case you can use the ajaxProgressiveLoadDelay option to add a delay in milliseconds between each page request.",name:"progressiveLoadDelay",required:!1,type:{name:"number"}},progressiveLoadScrollMargin:{defaultValue:null,description:"The ajaxProgressiveLoadScrollMargin property determines how close to the bottom of the table in pixels, the scroll bar must be before the next page worth of data is loaded, by default it is set to twice the height of the table.",name:"progressiveLoadScrollMargin",required:!1,type:{name:"number"}},ajaxLoader:{defaultValue:null,description:"Show loader while data is loading, can also take a function that must return a boolean.",name:"ajaxLoader",required:!1,type:{name:"boolean | (() => boolean)"}},ajaxLoaderLoading:{defaultValue:null,description:"html for loader element.",name:"ajaxLoaderLoading",required:!1,type:{name:"string"}},ajaxLoaderError:{defaultValue:null,description:"html for the loader element in the event of an error.",name:"ajaxLoaderError",required:!1,type:{name:"string"}},ajaxRequesting:{defaultValue:null,description:"The ajaxRequesting callback is triggered when ever an ajax request is made.",name:"ajaxRequesting",required:!1,type:{name:"((url: string, params: any) => boolean)"}},ajaxError:{defaultValue:null,description:"The ajaxError callback is triggered there is an error response to an ajax request.",name:"ajaxError",required:!1,type:{name:"((xhr: any, textStatus: any, errorThrown: any) => void)"}},dataLoader:{defaultValue:null,description:"",name:"dataLoader",required:!1,type:{name:"boolean"}},dataLoaderLoading:{defaultValue:null,description:"",name:"dataLoaderLoading",required:!1,type:{name:"string | HTMLElement"}},dataLoaderError:{defaultValue:null,description:"",name:"dataLoaderError",required:!1,type:{name:"string"}},dataLoaderErrorTimeout:{defaultValue:null,description:"",name:"dataLoaderErrorTimeout",required:!1,type:{name:"number"}},sortMode:{defaultValue:null,description:"",name:"sortMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},filterMode:{defaultValue:null,description:"",name:"filterMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},initialSort:{defaultValue:null,description:"Array of sorters to be applied on load.",name:"initialSort",required:!1,type:{name:"Sorter[]"}},sortOrderReverse:{defaultValue:null,description:"reverse the order that multiple sorters are applied to the table.",name:"sortOrderReverse",required:!1,type:{name:"boolean"}},headerSortClickElement:{defaultValue:null,description:"",name:"headerSortClickElement",required:!1,type:{name:"enum",value:[{value:'"header"'},{value:'"icon"'}]}},initialFilter:{defaultValue:null,description:"Array of filters to be applied on load.",name:"initialFilter",required:!1,type:{name:"Filter[]"}},initialHeaderFilter:{defaultValue:null,description:"array of initial values for header filters.",name:"initialHeaderFilter",required:!1,type:{name:'Pick<Filter, "value" | "field">[]'}},dataFiltering:{defaultValue:null,description:"The dataFiltering callback is triggered whenever a filter event occurs, before the filter happens.",name:"dataFiltering",required:!1,type:{name:"((filters: Filter[]) => void)"}},dataFiltered:{defaultValue:null,description:"The dataFiltered callback is triggered after the table dataset is filtered.",name:"dataFiltered",required:!1,type:{name:"((filters: Filter[], rows: RowComponent[]) => void)"}},headerFilterLiveFilterDelay:{defaultValue:null,description:"When using real time header filtering, Tabulator will wait 300 milliseconds after a keystroke before triggering the filter. You can customize this delay by using the headerFilterLiveFilterDelay table setup option.",name:"headerFilterLiveFilterDelay",required:!1,type:{name:"number"}},groupBy:{defaultValue:null,description:"String/function to select field to group rows by",name:"groupBy",required:!1,type:{name:"GroupArg"}},groupValues:{defaultValue:null,description:`By default Tabulator will create groups for rows based on the values contained in the row data. if you want to explicitly define which field values groups should be created for at each level, you can use the groupValues option.

This option takes an array of value arrays, each item in the first array should be a list of acceptable field values for groups at that level`,name:"groupValues",required:!1,type:{name:"GroupValuesArg"}},groupHeader:{defaultValue:null,description:"You can use the setGroupHeader function to change the header generation function for each group. This function has one argument and takes the same values as passed to the groupHeader setup option.",name:"groupHeader",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},groupHeaderPrint:{defaultValue:null,description:"When printing you may want to apply a different group header from the one usually used in the table. You can now do this using the groupHeaderPrint table option, which takes the same inputs as the standard groupHeader property.",name:"groupHeaderPrint",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},groupStartOpen:{defaultValue:null,description:`You can set the default open state of groups using the groupStartOpen property* * This can take one of three possible values:

true - all groups start open (default value)
false - all groups start closed
function() - a callback to decide if a group should start open or closed
Group Open Function
If you want to decide on a group by group basis which should start open or closed then you can pass a function to the groupStartOpen property. This should return true if the group should start open or false if the group should start closed.`,name:"groupStartOpen",required:!1,type:{name:"boolean | ((value: any, count: number, data: any, group: GroupComponent) => boolean)"}},groupToggleElement:{defaultValue:null,description:`By default Tabulator allows users to toggle a group open or closed by clicking on the arrow icon in the left of the group header. If you would prefer a different behavior you can use the groupToggleElement option to choose a different option:* * The option can take one of three values:
arrow - toggle group on arrow element click
header - toggle group on click anywhere on the group header element
false - prevent clicking anywhere in the group toggling the group`,name:"groupToggleElement",required:!1,type:{name:'false | "header" | "arrow"'}},groupClosedShowCalcs:{defaultValue:null,description:"show/hide column calculations when group is closed.",name:"groupClosedShowCalcs",required:!1,type:{name:"boolean"}},dataGrouping:{defaultValue:null,description:"The dataGrouping callback is triggered whenever a data grouping event occurs, before grouping happens.",name:"dataGrouping",required:!1,type:{name:"(() => void)"}},dataGrouped:{defaultValue:null,description:"The dataGrouping callback is triggered whenever a data grouping event occurs, after grouping happens.",name:"dataGrouped",required:!1,type:{name:"(() => void)"}},groupVisibilityChanged:{defaultValue:null,description:"The groupVisibilityChanged callback is triggered whenever a group changes between hidden and visible states.",name:"groupVisibilityChanged",required:!1,type:{name:"((group: GroupComponent, visible: boolean) => void)"}},groupClick:{defaultValue:null,description:"The groupClick callback is triggered when a user clicks on a group header.",name:"groupClick",required:!1,type:{name:"GroupEventCallback"}},groupDblClick:{defaultValue:null,description:"The groupDblClick callback is triggered when a user double clicks on a group header.",name:"groupDblClick",required:!1,type:{name:"GroupEventCallback"}},groupContext:{defaultValue:null,description:`The groupContext callback is triggered when a user right clicks on a group header.

If you want to prevent the browsers context menu being triggered in this event you will need to include the preventDefault() function in your callback.`,name:"groupContext",required:!1,type:{name:"GroupEventCallback"}},groupTap:{defaultValue:null,description:"The groupTap callback is triggered when a user taps on a group header on a touch display.",name:"groupTap",required:!1,type:{name:"GroupEventCallback"}},groupDblTap:{defaultValue:null,description:"The groupDblTap callback is triggered when a user taps on a group header on a touch display twice in under 300ms.",name:"groupDblTap",required:!1,type:{name:"GroupEventCallback"}},groupTapHold:{defaultValue:null,description:"The groupTapHold callback is triggered when a user taps on a group header on a touch display and holds their finger down for over 1 second.",name:"groupTapHold",required:!1,type:{name:"GroupEventCallback"}},groupUpdateOnCellEdit:{defaultValue:null,description:"",name:"groupUpdateOnCellEdit",required:!1,type:{name:"boolean"}},pagination:{defaultValue:null,description:"",name:"pagination",required:!1,type:{name:"boolean"}},paginationMode:{defaultValue:null,description:"",name:"paginationMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},paginationSize:{defaultValue:null,description:"Set the number of rows in each page.",name:"paginationSize",required:!1,type:{name:"number"}},paginationSizeSelector:{defaultValue:null,description:`Setting this option to true will cause Tabulator to create a list of page size options, that are multiples of the current page size. In the example below, the list will have the values of 5, 10, 15 and 20.

 When using the page size selector like this, if you use the setPageSize function to set the page size to a value not in the list, the list will be regenerated using the new page size as the starting valuer`,name:"paginationSizeSelector",required:!1,type:{name:"true | any[] | number[]"}},paginationElement:{defaultValue:null,description:"By default the pagination controls are added to the footer of the table. If you wish the controls to be created in another element pass a DOM node or a CSS selector for that element to the paginationElement option.",name:"paginationElement",required:!1,type:{name:"string | HTMLElement"}},dataReceiveParams:{defaultValue:null,description:`Lookup list to link expected data fields from the server to their function
\`\`\`typescript
default: {
  "current_page": "current_page",
  "last_page": "last_page",
  "data": "data",
  }
\`\`\``,name:"dataReceiveParams",required:!1,type:{name:"Record<string, string>"}},dataSendParams:{defaultValue:null,description:`Lookup list to link fields expected by the server to their function
\`\`\`typescript
default: {
  "page": "page",
  "size": "size",
  "sorters": "sorters",
  "filters": "filters",
}
\`\`\``,name:"dataSendParams",required:!1,type:{name:"Record<string, string>"}},paginationAddRow:{defaultValue:null,description:`When using the addRow function on a paginated table, rows will be added relative to the current page (ie to the top or bottom of the current page), with overflowing rows being shifted onto the next page.

If you would prefer rows to be added relative to the table (firs/last page) then you can use the paginationAddRow option. it can take one of two values:

page - add rows relative to current page (default)
table - add rows relative to the table`,name:"paginationAddRow",required:!1,type:{name:"enum",value:[{value:'"table"'},{value:'"page"'}]}},paginationCounter:{defaultValue:null,description:`You can choose to display a pagination counter in the bottom left of the footer that shows a summary of the current number of rows shown out of the total.
If you want to have a fully customized counter, then you can pass a function to the paginationCounter option

The formatter function accepts 5 arguments:

pageSize - Number of rows shown per page
currentRow - First visible row position
currentPage - Current page
totalRows - Total rows in table
totalPages - Total pages in table
The function must return the contents of the counter, either the text value of the counter, valid HTML or a DOM node`,name:"paginationCounter",required:!1,type:{name:'"rows" | "pages" | ((pageSize: number, currentRow: number, currentPage: number, totalRows: number, totalPages: number) => string | HTMLElement)'}},paginationCounterElement:{defaultValue:null,description:"By default the counter will be displayed in the left of the table footer. If you would like it displayed in another element pass a DOM node or a CSS selector for that element.",name:"paginationCounterElement",required:!1,type:{name:"string | HTMLElement"}},paginationButtonCount:{defaultValue:null,description:"The number of pagination page buttons shown in the footer using the paginationButtonCount option. By default this has a value of 5.",name:"paginationButtonCount",required:!1,type:{name:"number"}},paginationInitialPage:{defaultValue:null,description:"Specify that a specific page should be loaded when the table first load.",name:"paginationInitialPage",required:!1,type:{name:"number"}},persistenceID:{defaultValue:null,description:"ID tag used to identify persistent storage information.",name:"persistenceID",required:!1,type:{name:"string"}},persistenceMode:{defaultValue:null,description:`Persistence information can either be stored in a cookie or in the localStorage object, you can use the persistenceMode to choose which. It can take three possible values:

 local - (string) Store the persistence information in the localStorage object
 cookie - (string) Store the persistence information in a cookie
 true - (boolean) check if localStorage is available and store persistence information, otherwise store in cookie (Default option)`,name:"persistenceMode",required:!1,type:{name:'true | "local" | "cookie"'}},persistentLayout:{defaultValue:null,description:"Enable persistent storage of column layout information.",name:"persistentLayout",required:!1,type:{name:"boolean"}},persistentSort:{defaultValue:null,description:"You can ensure the data sorting is stored for the next page load by setting the persistentSort option to true.",name:"persistentSort",required:!1,type:{name:"boolean"}},persistentFilter:{defaultValue:null,description:"You can ensure the data filtering is stored for the next page load by setting the persistentFilter option to true.",name:"persistentFilter",required:!1,type:{name:"boolean"}},persistence:{defaultValue:null,description:"By setting the persistence property to true the table will persist the sort, filter, group (groupBy, groupStartOpen, groupHeader), pagination (paginationSize), and column (title, width, visibility, order) configuration of the table.",name:"persistence",required:!1,type:{name:"true | PersistenceOptions"}},persistenceWriterFunc:{defaultValue:null,description:"The persistenceWriterFunc function will receive three arguments, the persistance id of the table, the type of data to be written and an object or array representing the data",name:"persistenceWriterFunc",required:!1,type:{name:"((id: string, type: keyof PersistenceOptions, data: any) => any)"}},persistenceReaderFunc:{defaultValue:null,description:"The persistenceReaderFunc function will receive two arguments, the persistance id of the table, and the type of data to be written. This function must synchronously return the data in the format in which it was passed to the persistenceWriterFunc function. It should return a value of false if no data was present.",name:"persistenceReaderFunc",required:!1,type:{name:"((id: string, type: keyof PersistenceOptions) => any)"}},clipboard:{defaultValue:null,description:`You can enable clipboard functionality using the clipboard config option. It can take one of four possible values:
    true - enable clipboard copy and paste
    "copy" - enable only copy functionality
    "paste" - enable only paste functionality
    false - disable all clipboard functionality (default)`,name:"clipboard",required:!1,type:{name:'boolean | "copy" | "paste"'}},clipboardCopyRowRange:{defaultValue:null,description:"The clipboardCopyRowRange option takes a Row Range Lookup value and allows you to choose which rows are included in the clipboard output:",name:"clipboardCopyRowRange",required:!1,type:{name:"enum",value:[{value:'"visible"'},{value:'"active"'},{value:'"selected"'},{value:'"all"'}]}},clipboardCopyFormatter:{defaultValue:null,description:'You can alter the finished output to the clipboard using the clipboardCopyFormatter callback. The callback function receives two arguments, the first is a string representing the type of content to be formatted (either "plain" or "html" depending on the type of data entering the clipboard). The second argument is the string that is about to be inserted into the clipboard. The function and should return a string that will be inserted into the clipboard.',name:"clipboardCopyFormatter",required:!1,type:{name:'"table" | ((type: "plain" | "html", output: string) => string)'}},clipboardCopyHeader:{defaultValue:null,description:"By default Tabulator will include the column header titles in any clipboard data, this can be turned off by passing a value of false to the clipboardCopyHeader property:",name:"clipboardCopyHeader",required:!1,type:{name:"boolean"}},clipboardPasteParser:{defaultValue:null,description:`Tabulator has one built in paste parser, that is designed to take a table formatted text string from the clipboard and turn it into row data. it breaks the data into rows on a newline character \\n and breaks the rows down to columns on a tab character \\t.
It will then attempt to work out which columns in the data correspond to columns in the table. It tries three different ways to achieve this. First it checks the values of all columns in the first row of data to see if they match the titles of columns in the table. If any of the columns don't match it then tries the same approach but with the column fields. If either of those options match, Tabulator will map those columns to the incoming data and import it into rows. If there is no match then Tabulator will assume the columns in the data are in the same order as the visible columns in the table and import them that way.

The inbuilt parser will reject any clipboard data that does not contain at least one row and two columns, in that case the clipboardPasteError will be triggered.

If you extend the clipboard module to add your own parser, you can set it to be used as default with the clipboardPasteParser property.`,name:"clipboardPasteParser",required:!1,type:{name:"string | ((clipboard: any) => any[])"}},clipboardPasteAction:{defaultValue:null,description:`Once the data has been parsed into row data, it will be passed to a paste action to be added to the table. There are three inbuilt paste actions:

insert - Inserts data into the table using the addRows function (default)
update - Updates data in the table using the updateOrAddData function
replace - replaces all data in the table using the setData function`,name:"clipboardPasteAction",required:!1,type:{name:"enum",value:[{value:'"insert"'},{value:'"update"'},{value:'"replace"'}]}},clipboardCopyStyled:{defaultValue:null,description:`By default Tabulator will copy some of the tables styling along with the data to give a better visual appearance when pasted into other documents.

If you want to only copy the un-styled data then you should set the clipboardCopyStyled option to false in the table options object:`,name:"clipboardCopyStyled",required:!1,type:{name:"boolean"}},clipboardCopyConfig:{defaultValue:null,description:`By default Tabulator includes column headers, row groups and column calculations in the clipboard output.

You can choose to remove column headers groups, row groups or column calculations from the output data by setting the values in the clipboardCopyConfig option in the table definition:`,name:"clipboardCopyConfig",required:!1,type:{name:"boolean | AdditionalExportOptions"}},clipboardCopied:{defaultValue:null,description:"The clipboardCopied event is triggered whenever data is copied to the clipboard.",name:"clipboardCopied",required:!1,type:{name:"(() => void)"}},clipboardPasted:{defaultValue:null,description:"The clipboardPasted event is triggered whenever data is successfully pasted into the table.",name:"clipboardPasted",required:!1,type:{name:"(() => void)"}},clipboardPasteError:{defaultValue:null,description:"The clipboardPasteError event is triggered whenever an attempt to paste data into the table has failed because it was rejected by the paste parser.",name:"clipboardPasteError",required:!1,type:{name:"(() => void)"}},groupHeaderClipboard:{defaultValue:null,description:"When copying to clipboard you may want to apply a different group header from the one usually used in the table. You can now do this using the groupHeaderClipboard table option, which takes the same inputs as the standard groupHeader property.",name:"groupHeaderClipboard",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},groupHeaderHtmlOutput:{defaultValue:null,description:"When the getHtml function is called you may want to apply a different group header from the one usually used in the table. You can now do this using the groupHeaderHtmlOutput table option, which takes the same inputs as the standard groupHeader property.",name:"groupHeaderHtmlOutput",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},dataTree:{defaultValue:null,description:"To enable data trees in your table, set the dataTree property to true in your table constructor:",name:"dataTree",required:!1,type:{name:"boolean"}},dataTreeElementColumn:{defaultValue:null,description:"By default the toggle element will be inserted into the first column on the table. If you want the toggle element to be inserted in a different column you can pass the field name of the column to the dataTreeElementColumn setup option.",name:"dataTreeElementColumn",required:!1,type:{name:"string | boolean"}},dataTreeBranchElement:{defaultValue:null,description:"Show tree branch icon.",name:"dataTreeBranchElement",required:!1,type:{name:"string | boolean"}},dataTreeChildIndent:{defaultValue:null,description:"Tree level indent in pixels",name:"dataTreeChildIndent",required:!1,type:{name:"number"}},dataTreeChildField:{defaultValue:null,description:"By default Tabulator will look for child rows in the _children field of a row data object. You can change this to look in a different field using the dataTreeChildField property in your table constructor:",name:"dataTreeChildField",required:!1,type:{name:"string"}},dataTreeCollapseElement:{defaultValue:null,description:`The toggle button that allows users to collapse and expand the column can be customized to meet your needs. There are two options, dataTreeExpandElement and dataTreeCollapseElement, that can be set to replace the default toggle elements with your own.

Both options can take either an html string representing the contents of the toggle element`,name:"dataTreeCollapseElement",required:!1,type:{name:"string | boolean | HTMLElement"}},dataTreeExpandElement:{defaultValue:null,description:"The toggle button that allows users to expand the column.",name:"dataTreeExpandElement",required:!1,type:{name:"string | boolean | HTMLElement"}},dataTreeStartExpanded:{defaultValue:null,description:`By default all nodes on the tree will start collapsed, you can customize the initial expansion state of the tree using the dataTreeStartExpanded option.*
This option can take one of three possible value types, either a boolean to indicate whether all nodes should start expanded or collapsed:`,name:"dataTreeStartExpanded",required:!1,type:{name:"boolean | boolean[] | ((row: RowComponent, level: number) => boolean)"}},dataTreeSelectPropagate:{defaultValue:null,description:"Propagate selection events from parent rows to children.",name:"dataTreeSelectPropagate",required:!1,type:{name:"boolean"}},dataTreeFilter:{defaultValue:null,description:"",name:"dataTreeFilter",required:!1,type:{name:"boolean"}},dataTreeSort:{defaultValue:null,description:"",name:"dataTreeSort",required:!1,type:{name:"boolean"}},dataTreeChildColumnCalcs:{defaultValue:null,description:`When you are using the dataTree option with your table, the column calculations will by default only use the data for the top level rows and will ignore any children.
To include child rows in the column calculations set the dataTreeChildColumnCalcs option to true in the table constructor.`,name:"dataTreeChildColumnCalcs",required:!1,type:{name:"boolean"}},cellClick:{defaultValue:null,description:"The cellClick callback is triggered when a user left clicks on a cell, it can be set on a per column basis using the option in the columns definition object.",name:"cellClick",required:!1,type:{name:"CellEventCallback"}},cellDblClick:{defaultValue:null,description:"",name:"cellDblClick",required:!1,type:{name:"CellEventCallback"}},cellContext:{defaultValue:null,description:"",name:"cellContext",required:!1,type:{name:"CellEventCallback"}},cellTap:{defaultValue:null,description:"",name:"cellTap",required:!1,type:{name:"CellEventCallback"}},cellDblTap:{defaultValue:null,description:"",name:"cellDblTap",required:!1,type:{name:"CellEventCallback"}},cellTapHold:{defaultValue:null,description:"",name:"cellTapHold",required:!1,type:{name:"CellEventCallback"}},cellMouseEnter:{defaultValue:null,description:"",name:"cellMouseEnter",required:!1,type:{name:"CellEventCallback"}},cellMouseLeave:{defaultValue:null,description:"",name:"cellMouseLeave",required:!1,type:{name:"CellEventCallback"}},cellMouseOver:{defaultValue:null,description:"",name:"cellMouseOver",required:!1,type:{name:"CellEventCallback"}},cellMouseOut:{defaultValue:null,description:"",name:"cellMouseOut",required:!1,type:{name:"CellEventCallback"}},cellMouseMove:{defaultValue:null,description:"",name:"cellMouseMove",required:!1,type:{name:"CellEventCallback"}},cellEditing:{defaultValue:null,description:"",name:"cellEditing",required:!1,type:{name:"CellEditEventCallback"}},cellEdited:{defaultValue:null,description:"",name:"cellEdited",required:!1,type:{name:"CellEditEventCallback"}},cellEditCancelled:{defaultValue:null,description:"",name:"cellEditCancelled",required:!1,type:{name:"CellEditEventCallback"}},validationFailed:{defaultValue:null,description:"The validationFailed event is triggered when the value entered into a cell during an edit fails to pass validation.",name:"validationFailed",required:!1,type:{name:"((cell: CellComponent, value: any, validators: Validator[] | StandardValidatorType[]) => void)"}},cellMouseDown:{defaultValue:null,description:"",name:"cellMouseDown",required:!1,type:{name:"CellEventCallback"}},cellMouseUp:{defaultValue:null,description:"",name:"cellMouseUp",required:!1,type:{name:"CellEventCallback"}},invalidOptionWarning:{defaultValue:null,description:"",name:"invalidOptionWarning",required:!1,type:{name:"boolean"}},debugInvalidOptions:{defaultValue:null,description:"Enabled by default this will provide a console warning if you are trying to set an option on the table that does not exist. With the new optional modular structure this is particularly valuable as it will prompt you if you are trying to use an option for a module that has not been installed",name:"debugInvalidOptions",required:!1,type:{name:"boolean"}},debugInitialization:{defaultValue:null,description:"Enabled by default this will provide a console warning if you try and call a function on the table before it has been initialized.",name:"debugInitialization",required:!1,type:{name:"boolean"}},debugEventsExternal:{defaultValue:null,description:"The debugEventsExternal option will create a console log for every external event that is fired so you can gain an understanding of which events you should be binding to.",name:"debugEventsExternal",required:!1,type:{name:"boolean"}},debugEventsInternal:{defaultValue:null,description:"The debugEventsInternal option will create a console log for every internal event that is fired so you can gain an understanding of which events you should be subscribing to in your modules.",name:"debugEventsInternal",required:!1,type:{name:"boolean"}},debugInvalidComponentFuncs:{defaultValue:null,description:"Disable component function warnings",name:"debugInvalidComponentFuncs",required:!1,type:{name:"boolean"}},debugDeprecation:{defaultValue:null,description:"Disable deprecation warnings",name:"debugDeprecation",required:!1,type:{name:"boolean"}},htmlOutputConfig:{defaultValue:null,description:"",name:"htmlOutputConfig",required:!1,type:{name:"AdditionalExportOptions"}},printAsHtml:{defaultValue:null,description:`By Default when a page is printed that includes a Tabulator it will be rendered on the page exactly as the table is drawn. While this ise useful in most cases, some users prefer to have more control over the print output, for example showing all rows of the table, instead of just those visible with the current position of the scroll bar.

Tabulator provides a print styling mode that will replace the Tabulator with an HTML table for the printout giving you much more control over the look and feel of the table for the print out., to enable this mode, set the printAsHtml option to true in the table constructor.

This will replace the table (in print outs only) with a simple HTML table with the class tabulator-print-table that you can use to style the table in any way you like.

It also has the benefit that because it is an HTML table, if it causes a page break your browser will automatically add the column headers in at the top of the next page.`,name:"printAsHtml",required:!1,type:{name:"boolean"}},printConfig:{defaultValue:null,description:`The HTML table will contain column header groups, row groups, and column calculations.

You can choose to remove any of these from the output data by setting the values in the printConfig option in the table definition`,name:"printConfig",required:!1,type:{name:"AdditionalExportOptions"}},printStyled:{defaultValue:null,description:"If you want your printed table to be styled to match your Tabulator you can set the printCopyStyle to true, this will copy key layout styling to the printed table.",name:"printStyled",required:!1,type:{name:"boolean"}},printRowRange:{defaultValue:null,description:"By default, only the rows currently visible in the Tabulator will be added to the HTML table. For custom row ranges it is also possible to pass a function into the printRowRange option that should return an array of Row Components",name:"printRowRange",required:!1,type:{name:"RowRangeLookup | (() => RowComponent[])"}},printHeader:{defaultValue:null,description:"You can use the printHeader table setup option to define a header to be displayed when the table is printed.",name:"printHeader",required:!1,type:{name:"StandardStringParam"}},printFooter:{defaultValue:null,description:"You can use the printFooter table setup option to define a footer to be displayed when the table is printed.",name:"printFooter",required:!1,type:{name:"StandardStringParam"}},printFormatter:{defaultValue:null,description:"The printFormatter table setup option allows you to carry out any manipulation of the print output before it is displayed to the user for printing.",name:"printFormatter",required:!1,type:{name:"((tableHolderElement: any, tableElement: any) => any)"}},groupHeaderDownload:{defaultValue:null,description:"",name:"groupHeaderDownload",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},dataTreeParentField:{defaultValue:null,description:"The parent key field name",name:"dataTreeParentField",required:!1,type:{name:"string | number"}},showHeaderFilter:{defaultValue:null,description:"Hide HeaderFilter when grid is initialized",name:"showHeaderFilter",required:!1,type:{name:"boolean"}},selectionMode:{defaultValue:null,description:"if true, use native tabulator selections rules without using active selection module",name:"selectionMode",required:!1,type:{name:"boolean"}},multiSelect:{defaultValue:null,description:"Allow multi select rows (default true)",name:"multiSelect",required:!1,type:{name:"boolean"}},onTableRef:{defaultValue:null,description:"On the tableRef ready callback",name:"onTableRef",required:!1,type:{name:"((ref: MutableRefObject<ITabulator>) => void)"}},events:{defaultValue:null,description:"Grid events",name:"events",required:!1,type:{name:"(Partial<EventCallBackMethods> & IActiveSelectionModuleTableEvents)"}},containerClassName:{defaultValue:null,description:"Grid container class name",name:"containerClassName",required:!1,type:{name:"string"}},allowTextSelection:{defaultValue:null,description:"by default user text selection is disabled (CSS user-select='none')",name:"allowTextSelection",required:!1,type:{name:"boolean"}},updateColumnDefinition:{defaultValue:null,description:"",name:"updateColumnDefinition",required:!1,type:{name:"((column: ColumnLookup, definition: Partial<ColumnDefinition>) => Promise<void>)"}},apiRef:{defaultValue:null,description:"A mutable object to merge with these controls api",name:"apiRef",required:!1,type:{name:"unknown"}},gridMode:{defaultValue:null,description:"Grid mode: local or remote",name:"gridMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},dataSet:{defaultValue:null,description:"Grid data set",name:"dataSet",required:!1,type:{name:"IGridRowData[]"}},headerLabel:{defaultValue:null,description:"Grid label in header buttons row",name:"headerLabel",required:!1,type:{name:"ReactNode"}},buttons:{defaultValue:null,description:"Grid header buttons",name:"buttons",required:!1,type:{name:'Record<"delete" | "update" | "view" | "create" | "clone" | "select" | "filterToggle" | "system", IFormButton | null> | IFormButtons'}},buttonsSize:{defaultValue:null,description:"Grid header buttons size. Default: 'small'",name:"buttonsSize",required:!1,type:{name:"enum",value:[{value:'"middle"'},{value:'"large"'},{value:'"small"'}]}},buttonsIconsOnly:{defaultValue:null,description:"If true, only button icons will be displayed, without title",name:"buttonsIconsOnly",required:!1,type:{name:"boolean"}},buttonsPosition:{defaultValue:null,description:"Grid header buttons size. Default: 'right'",name:"buttonsPosition",required:!1,type:{name:"enum",value:[{value:'"left"'},{value:'"center"'},{value:'"right"'}]}},editFormProps:{defaultValue:null,description:"Edit DFormModal parameters",name:"editFormProps",required:!1,type:{name:"IDFormModalProps"}},selectionFormProps:{defaultValue:null,description:"Selection DFormModal parameters",name:"selectionFormProps",required:!1,type:{name:"IDFormModalProps"}},appendSelection:{defaultValue:null,description:"Append row selection when using selectionFormProps (by default, the dataSet is replaced with the selected rows. This option allows you to change this behavior)",name:"appendSelection",required:!1,type:{name:"boolean"}},noHover:{defaultValue:null,description:"Disable row hover effect",name:"noHover",required:!1,type:{name:"boolean"}},rowDeleteMessage:{defaultValue:null,description:"Confirm message before rows delete",name:"rowDeleteMessage",required:!1,type:{name:"ReactNode"}},confirmDelete:{defaultValue:null,description:"Should confirm before delete",name:"confirmDelete",required:!1,type:{name:"boolean"}},resizeHeightWithParent:{defaultValue:null,description:"Selector of parent container (.className or #id). Tabulator Grid will resize height on container height change",name:"resizeHeightWithParent",required:!1,type:{name:"string"}}}}}catch{}try{tabulatorGridComponent.displayName="tabulatorGridComponent",tabulatorGridComponent.__docgenInfo={description:"DForm TabulatorGrid field",displayName:"tabulatorGridComponent",props:{value:{defaultValue:null,description:"Default value",name:"value",required:!1,type:{name:"IGridRowData[]"}},resizeHeightWithForm:{defaultValue:null,description:"Auto resize height on form resize",name:"resizeHeightWithForm",required:!1,type:{name:"boolean"}},fetchInCreateMode:{defaultValue:null,description:"By default, when a form is in Create mode, it does not load data even if onDataFetch callback is provided. This option changes this behavior",name:"fetchInCreateMode",required:!1,type:{name:"boolean"}},component:{defaultValue:null,description:"Field React component",name:"component",required:!0,type:{name:"new (fieldName: string, fieldProps: any, model: DModel, parent?: IBaseField | undefined) => TabulatorGridField"}},helpClass:{defaultValue:null,description:"Help class",name:"helpClass",required:!1,type:{name:"string"}},label:{defaultValue:null,description:"Field label",name:"label",required:!1,type:{name:"ReactNode"}},placeholder:{defaultValue:null,description:`Field placeholder
No rows placeholder
placeholder element to display on empty table.`,name:"placeholder",required:!1,type:{name:"string | (string & HTMLElement) | (string & ((this: TabulatorFull | Tabulator) => string))"}},inlineGroup:{defaultValue:null,description:"inline group name",name:"inlineGroup",required:!1,type:{name:"string"}},hidden:{defaultValue:null,description:"If field default state is hidden",name:"hidden",required:!1,type:{name:"boolean"}},disabled:{defaultValue:null,description:"If field default state is disabled",name:"disabled",required:!1,type:{name:"boolean"}},readOnly:{defaultValue:null,description:`If field default state is readonly
Table can't be edited`,name:"readOnly",required:!1,type:{name:"boolean"}},dependsOn:{defaultValue:null,description:"List of fields that must be filled in order to display this field",name:"dependsOn",required:!1,type:{name:"string[]"}},width:{defaultValue:null,description:`Field width
Grid container width`,name:"width",required:!1,type:{name:"string | number"}},autoHeightResize:{defaultValue:null,description:"Field container height auto resize",name:"autoHeightResize",required:!1,type:{name:"boolean"}},autoFocus:{defaultValue:null,description:"Get focus by default",name:"autoFocus",required:!1,type:{name:"boolean"}},requiredMark:{defaultValue:null,description:"Mark Field Label as Required",name:"requiredMark",required:!1,type:{name:"boolean"}},tooltip:{defaultValue:null,description:"Config tooltip info",name:"tooltip",required:!1,type:{name:"LabelTooltipType"}},style:{defaultValue:null,description:"Field CSS style",name:"style",required:!1,type:{name:"CSSProperties"}},rowStyle:{defaultValue:null,description:"Row field container CSS style",name:"rowStyle",required:!1,type:{name:"CSSProperties"}},rules:{defaultValue:null,description:"Field validation rules",name:"rules",required:!1,type:{name:"IRuleType[]"}},onValueChanged:{defaultValue:null,description:"fires when the value of a field changed",name:"onValueChanged",required:!1,type:{name:"((value: unknown, prevValue: unknown, field: TabulatorGridField) => void)"}},onTouchedStateChanged:{defaultValue:null,description:"fires when the touched state of a field changed",name:"onTouchedStateChanged",required:!1,type:{name:"((state: boolean, field: TabulatorGridField) => void)"}},onDirtyStateChanged:{defaultValue:null,description:"fires when the dirty state of a field changed",name:"onDirtyStateChanged",required:!1,type:{name:"((state: boolean, field: TabulatorGridField) => void)"}},onErrorChanged:{defaultValue:null,description:"fires when the error of a field changed",name:"onErrorChanged",required:!1,type:{name:"((error: string, field: TabulatorGridField) => void)"}},onHiddenStateChanged:{defaultValue:null,description:"fires when the hidden state of a field changed",name:"onHiddenStateChanged",required:!1,type:{name:"((state: boolean, field: TabulatorGridField) => void)"}},onReadOnlyStateChanged:{defaultValue:null,description:"fires when read only state of a field changed",name:"onReadOnlyStateChanged",required:!1,type:{name:"((state: boolean, field: TabulatorGridField) => void)"}},onLabelChanged:{defaultValue:null,description:"fires when label of a field changed",name:"onLabelChanged",required:!1,type:{name:"((label: ReactNode, prevLabel: ReactNode, field: TabulatorGridField) => void)"}},onDisabledStateChanged:{defaultValue:null,description:"fires when the disable state of a field changes",name:"onDisabledStateChanged",required:!1,type:{name:"((state: boolean, field: TabulatorGridField) => void)"}},onReadyStateChanged:{defaultValue:null,description:"fires when a field is completely initialized, its data is loaded",name:"onReadyStateChanged",required:!1,type:{name:"((state: boolean, field: TabulatorGridField) => void)"}},onValidated:{defaultValue:null,description:"fires when a field validated",name:"onValidated",required:!1,type:{name:"((value: unknown, error: string, isSubmit: boolean, field: TabulatorGridField) => void)"}},onMenuVisibilityChanged:{defaultValue:null,description:"Fires when menu visibility status changed",name:"onMenuVisibilityChanged",required:!1,type:{name:"((isVisible: boolean, gridApi: IGridApi, field: TabulatorGridField) => void)"}},onDataLoading:{defaultValue:null,description:"Fires when dataSet loading starts (regardless of whether it is an ajax request or a ready-made dataSet is passed)",name:"onDataLoading",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi, field: TabulatorGridField) => void)"}},onDataLoaded:{defaultValue:null,description:"callback is triggered when a new set of data is loaded into the table (regardless of whether it is an ajax request or a ready-made dataSet is passed)",name:"onDataLoaded",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi, field: TabulatorGridField) => void)"}},onDataProcessed:{defaultValue:null,description:"The callback is triggered  after data has been processed and the table has been rendered.",name:"onDataProcessed",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi, field: TabulatorGridField) => void)"}},onDataLoadError:{defaultValue:null,description:"fires when the grid data loading failed",name:"onDataLoadError",required:!1,type:{name:"((message: string, code: number, gridApi: IGridApi, field: TabulatorGridField) => void)"}},onDataChanged:{defaultValue:null,description:"Fires before the data change (the data set updated, rows added/deleted, etc.)",name:"onDataChanged",required:!1,type:{name:"((dataSet: IGridRowData[], gridApi: IGridApi, field: TabulatorGridField) => void)"}},onDataFetch:{defaultValue:null,description:"special callback used to fetch remote data. If not specified, the request will not be processed",name:"onDataFetch",required:!1,type:{name:"((params: IRequestProps, gridApi: IGridApi, field: TabulatorGridField) => IGridDataSourcePromise)"}},onDataFetching:{defaultValue:null,description:"Called before a data fetching begins. If it returns false, then the fetch is canceled",name:"onDataFetching",required:!1,type:{name:"((url: string, params: IRequestProps, gridApi: IGridApi, field: TabulatorGridField) => boolean)"}},onDataFetchResponse:{defaultValue:null,description:"Fires when a successful remote fetch request has been made. This callback can also be used to modify the received data before it is parsed by the table. If you use this callback it must return the data to be parsed by Tabulator, otherwise no data will be rendered.",name:"onDataFetchResponse",required:!1,type:{name:"((dataSet: IGridRowData[], params: IRequestProps, gridApi: IGridApi, field: TabulatorGridField) => IGridRowData[])"}},onSelectionChange:{defaultValue:null,description:"Callback executed when selected rows change",name:"onSelectionChange",required:!1,type:{name:"((data: IGridRowData[], rows: RowComponent[], selectedRows: RowComponent[], deselectedRows: RowComponent[], gridApi: IGridApi, field: TabulatorGridField) => void)"}},onDelete:{defaultValue:null,description:"Callback executed when selected rows delete",name:"onDelete",required:!1,type:{name:"((selectedRows: IGridRowData[], gridApi: IGridApi, field: TabulatorGridField) => void | IGridDeletePromise)"}},className:{defaultValue:null,description:"Grid class name",name:"className",required:!1,type:{name:"string"}},minWidth:{defaultValue:null,description:"Grid container max width",name:"minWidth",required:!1,type:{name:"string | number"}},maxWidth:{defaultValue:null,description:"Grid container max width",name:"maxWidth",required:!1,type:{name:"string | number"}},id:{defaultValue:null,description:`Grid Id
Grid ID`,name:"id",required:!1,type:{name:"string"}},height:{defaultValue:null,description:"Sets the height of the containing element, can be set to any valid height css value. If set to false (the default), the height of the table will resize to fit the table data.",name:"height",required:!1,type:{name:"string | number | false"}},footerElement:{defaultValue:null,description:"Grid footer element",name:"footerElement",required:!1,type:{name:"ReactNode"}},columns:{defaultValue:null,description:"Grid columns",name:"columns",required:!0,type:{name:"ITabulatorColumn[]"}},maxHeight:{defaultValue:null,description:"Can be set to any valid CSS value. By setting this you can allow your table to expand to fit the data, but not overflow its parent element. When there are too many rows to fit in the available space, the vertical scroll bar will be shown. This has the added benefit of improving load times on larger tables",name:"maxHeight",required:!1,type:{name:"string | number"}},minHeight:{defaultValue:null,description:"With a variable table height you can set the minimum height of the table either defined in the min-height CSS property for the element or set it using the minHeight option in the table constructor, this can be set to any valid CSS value.",name:"minHeight",required:!1,type:{name:"string | number"}},renderVertical:{defaultValue:null,description:"",name:"renderVertical",required:!1,type:{name:"RenderMode"}},renderHorizontal:{defaultValue:null,description:"",name:"renderHorizontal",required:!1,type:{name:"RenderMode"}},rowHeight:{defaultValue:null,description:"",name:"rowHeight",required:!1,type:{name:"number"}},renderVerticalBuffer:{defaultValue:null,description:"Manually set the size of the virtual DOM buffer.",name:"renderVerticalBuffer",required:!1,type:{name:"number | boolean"}},placeholderHeaderFilter:{defaultValue:null,description:"",name:"placeholderHeaderFilter",required:!1,type:{name:"string | HTMLElement | ((this: TabulatorFull | Tabulator) => string)"}},keybindings:{defaultValue:null,description:"Keybinding configuration object.",name:"keybindings",required:!1,type:{name:"false | KeyBinding"}},reactiveData:{defaultValue:null,description:`The reactivity systems allow Tabulator to watch arrays and objects passed into the table for changes and then automatically update the table.

This approach means you no longer need to worry about calling a number of different functions on the table to make changes, you simply update the array or object you originally passed into the table and Tabulator will take care of the rest.

You can enable reactive data by setting the reactiveData option to true in the table constructor, and then passing your data array to the data option.

Once the table is built any changes to the array will automatically be replicated to the table without needing to call any functions on the table itself`,name:"reactiveData",required:!1,type:{name:"boolean"}},autoResize:{defaultValue:null,description:"Tabulator will automatically attempt to redraw the data contained in the table if the containing element for the table is resized. To disable this functionality, set the autoResize property to false.",name:"autoResize",required:!1,type:{name:"boolean"}},tableBuilding:{defaultValue:null,description:"When a the tabulator constructor is called, the tableBuilding callback will triggered.",name:"tableBuilding",required:!1,type:{name:"(() => void)"}},tableBuilt:{defaultValue:null,description:"When a the tabulator constructor is called and the table has finished being rendered, the tableBuilt callback will triggered:",name:"tableBuilt",required:!1,type:{name:"(() => void)"}},renderStarted:{defaultValue:null,description:`The renderStarted callback is triggered whenever all the rows in the table are about to be rendered. This can include:
- Data is loaded into the table when setData is called
- A page is loaded through any form of pagination
- Rows are added to the table during progressive rendering
- Columns are changed by setColumns
- The data is filtered
- The data is sorted
- The redraw function is called`,name:"renderStarted",required:!1,type:{name:"(() => void)"}},renderComplete:{defaultValue:null,description:"The renderComplete callback is triggered after the table has been rendered.",name:"renderComplete",required:!1,type:{name:"(() => void)"}},htmlImporting:{defaultValue:null,description:"The htmlImporting callback is triggered when Tabulator starts importing data from an HTML table.",name:"htmlImporting",required:!1,type:{name:"EmptyCallback"}},htmlImported:{defaultValue:null,description:"The htmlImported callback is triggered when Tabulator finishes importing data from an HTML table.",name:"htmlImported",required:!1,type:{name:"EmptyCallback"}},dataChanged:{defaultValue:null,description:"The dataChanged callback is triggered whenever the table data is changed by the user. Triggers for this include editing any cell in the table, adding a row and deleting a row.",name:"dataChanged",required:!1,type:{name:"((data: any) => void)"}},pageLoaded:{defaultValue:null,description:"Whenever a page has been loaded, the pageLoaded callback is called, passing the current page number as an argument.",name:"pageLoaded",required:!1,type:{name:"((pageno: number) => void)"}},dataSorting:{defaultValue:null,description:"The dataSorting callback is triggered whenever a sort event occurs, before sorting happens.",name:"dataSorting",required:!1,type:{name:"((sorters: SorterFromTable[]) => void)"}},dataSorted:{defaultValue:null,description:"The dataSorted callback is triggered after the table dataset is sorted.",name:"dataSorted",required:!1,type:{name:"((sorters: SorterFromTable[], rows: RowComponent[]) => void)"}},invalidOptionWarnings:{defaultValue:null,description:"Setting the invalidOptionWarnings option to false will disable console warning messages for invalid properties in the table constructor and column definition object.",name:"invalidOptionWarnings",required:!1,type:{name:"boolean"}},scrollVertical:{defaultValue:null,description:"Callback is triggered when the table is vertically scrolled.",name:"scrollVertical",required:!1,type:{name:"((top: any) => void)"}},scrollHorizontal:{defaultValue:null,description:"Callback is triggered when the table is horizontally scrolled.",name:"scrollHorizontal",required:!1,type:{name:"((left: any) => void)"}},validationMode:{defaultValue:null,description:`There are now three different validation modes available to customize the validation experience:

blocking - if a user enters an invalid value while editing, they are blocked from leaving the cell until a valid value is entered (default)

highlight - if a user enters an invalid value, then the edit will complete as usual and they are allowed to exit the cell but a highlight is applied to the cell using the tabulator-validation-fail class

manual - no validation is automatically performed on edit, but it can be triggered by calling the validate function on the table or any Component Object`,name:"validationMode",required:!1,type:{name:"enum",value:[{value:'"blocking"'},{value:'"highlight"'},{value:'"manual"'}]}},textDirection:{defaultValue:null,description:"",name:"textDirection",required:!1,type:{name:"enum",value:[{value:'"auto"'},{value:'"ltr"'},{value:'"rtl"'}]}},rowContextMenu:{defaultValue:null,description:"",name:"rowContextMenu",required:!1,type:{name:"RowContextMenuSignature"}},rowClickMenu:{defaultValue:null,description:"",name:"rowClickMenu",required:!1,type:{name:"RowContextMenuSignature"}},rowDblClickMenu:{defaultValue:null,description:"",name:"rowDblClickMenu",required:!1,type:{name:"RowContextMenuSignature"}},groupClickMenu:{defaultValue:null,description:"",name:"groupClickMenu",required:!1,type:{name:"GroupContextMenuSignature"}},groupDblClickMenu:{defaultValue:null,description:"",name:"groupDblClickMenu",required:!1,type:{name:"GroupContextMenuSignature"}},groupContextMenu:{defaultValue:null,description:"",name:"groupContextMenu",required:!1,type:{name:"MenuObject<GroupComponent>[]"}},popupContainer:{defaultValue:null,description:"",name:"popupContainer",required:!1,type:{name:"string | boolean | HTMLElement"}},groupClickPopup:{defaultValue:null,description:"",name:"groupClickPopup",required:!1,type:{name:"string"}},groupContextPopup:{defaultValue:null,description:"",name:"groupContextPopup",required:!1,type:{name:"string"}},groupDblPopup:{defaultValue:null,description:"",name:"groupDblPopup",required:!1,type:{name:"string"}},groupDblClickPopup:{defaultValue:null,description:"",name:"groupDblClickPopup",required:!1,type:{name:"string"}},rowClickPopup:{defaultValue:null,description:"",name:"rowClickPopup",required:!1,type:{name:"string"}},rowContextPopup:{defaultValue:null,description:"",name:"rowContextPopup",required:!1,type:{name:"string"}},rowDblClickPopup:{defaultValue:null,description:"",name:"rowDblClickPopup",required:!1,type:{name:"string"}},history:{defaultValue:null,description:"Enable user interaction history functionality",name:"history",required:!1,type:{name:"boolean"}},historyUndo:{defaultValue:null,description:"The historyUndo event is triggered when the undo action is triggered.",name:"historyUndo",required:!1,type:{name:"((action: HistoryAction, component: RowComponent | CellComponent, data: any) => void)"}},historyRedo:{defaultValue:null,description:"The historyRedo event is triggered when the redo action is triggered.",name:"historyRedo",required:!1,type:{name:"((action: HistoryAction, component: RowComponent | CellComponent, data: any) => void)"}},locale:{defaultValue:null,description:"You can set the current local in one of two ways. If you want to set it when the table is created, simply include the locale option in your Tabulator constructor. You can either pass in a string matching one of the language options you have defined, or pass in the boolean true which will cause Tabulator to auto-detect the browsers language settings from the navigator.language object.",name:"locale",required:!1,type:{name:"string | boolean"}},langs:{defaultValue:null,description:`You can store as many languages as you like, creating an object inside the langs object with a property of the locale code for that language. A list of locale codes can be found here.

At present there are three parts of the table that can be localized, the column headers, the header filter placeholder text and the pagination buttons. To localize the pagination buttons, create a pagination property inside your language object and give it the properties outlined below.

If you wish you can also localize column titles by adding a columns property to your language object. You should store a property of the field name of the column you wish to change, with a value of its title. Any fields that match this will use this title instead of the one provided by the column definition array.`,name:"langs",required:!1,type:{name:"any"}},localized:{defaultValue:null,description:"When a localization event has occurred , the localized callback will triggered, passing the current locale code and language object:",name:"localized",required:!1,type:{name:"((locale: string, lang: any) => void)"}},downloadEncoder:{defaultValue:null,description:`Allows you to intercept the download file data before the users is prompted to save the file.

In order for the download to proceed the downloadReady callback is expected to return a blob of file to be downloaded.

If you would prefer to abort the download you can return false from this callback. This could be useful for example if you want to send the created file to a server via ajax rather than allowing the user to download the file.`,name:"downloadEncoder",required:!1,type:{name:"((fileContents: any, mimeType: string) => false | Blob)"}},downloadComplete:{defaultValue:null,description:"The downloadComplete callback is triggered when the user has been prompted to download the file.",name:"downloadComplete",required:!1,type:{name:"(() => void)"}},downloadConfig:{defaultValue:null,description:`By default Tabulator includes column headers, row groups and column calculations in the download output.

You can choose to remove column headers groups, row groups or column calculations from the output data by setting the values in the downloadConfig option in the table definition:`,name:"downloadConfig",required:!1,type:{name:"AdditionalExportOptions"}},downloadRowRange:{defaultValue:null,description:"By default, only the active rows (rows that have passed filtering) will be included in the download the downloadRowRange option takes a Row Range Lookup value and allows you to choose which rows are included in the download output.",name:"downloadRowRange",required:!1,type:{name:"enum",value:[{value:'"visible"'},{value:'"active"'},{value:'"selected"'},{value:'"all"'}]}},autoColumns:{defaultValue:null,description:"If you set the autoColumns option to true, every time data is loaded into the table through the data option or through the setData function, Tabulator will examine the first row of the data and build columns to match that data.",name:"autoColumns",required:!1,type:{name:"boolean"}},autoColumnsDefinitions:{defaultValue:null,description:"",name:"autoColumnsDefinitions",required:!1,type:{name:"((columnDefinitions?: ColumnDefinition[]) => ColumnDefinition[]) | ColumnDefinition[] | Record<string, Partial<ColumnDefinition>>"}},layout:{defaultValue:null,description:"By default Tabulator will use the fitData layout mode, which will resize the tables columns to fit the data held in each column, unless you specify a width or minWidth in the column constructor. If the width of all columns exceeds the width of the containing element, a scroll bar will appear.",name:"layout",required:!1,type:{name:"enum",value:[{value:'"fitData"'},{value:'"fitColumns"'},{value:'"fitDataFill"'},{value:'"fitDataStretch"'},{value:'"fitDataTable"'}]}},layoutColumnsOnNewData:{defaultValue:null,description:`To keep the layout of the columns consistent, once the column widths have been set on the first data load (either from the data property in the constructor or the setData function) they will not be changed when new data is loaded.

If you would prefer that the column widths adjust to the data each time you load it into the table you can set the layoutColumnsOnNewData property to true.`,name:"layoutColumnsOnNewData",required:!1,type:{name:"boolean"}},responsiveLayout:{defaultValue:null,description:`Responsive layout will automatically hide/show columns to fit the width of the Tabulator element. This allows for clean rendering of tables on smaller mobile devices, showing important data while avoiding horizontal scroll bars. You can enable responsive layouts using the responsiveLayout option.

There are two responsive layout modes available:

hide - hide columns that no longer fit in the table
collapse - collapse columns that no longer fit on the table into a list under the row

Hide Extra Columns
By default, columns will be hidden from right to left as the width of the table decreases. You can choose exactly how columns are hidden using the responsive property in the column definition object.

When responsive layout is enabled, all columns are given a default responsive value of 1. The higher you set this value the sooner that column will be hidden as the table width decreases. If two columns have the same responsive value then they are hidden from right to left (as defined in the column definition array, ignoring user moving of the columns). If you set the value to 0 then the column will never be hidden regardless of how narrow the table gets.`,name:"responsiveLayout",required:!1,type:{name:'boolean | "hide" | "collapse"'}},responsiveLayoutCollapseStartOpen:{defaultValue:null,description:"Collapsed lists are displayed to the user by default, if you would prefer they start closed so the user can open them you can use the responsiveLayoutCollapseStartOpen option.",name:"responsiveLayoutCollapseStartOpen",required:!1,type:{name:"boolean"}},responsiveLayoutCollapseUseFormatters:{defaultValue:null,description:`By default any formatter set on the column is applied to the value that will appear in the list. while this works for most formatters it can cause issues with the progress formatter which relies on being inside a cell.

If you would like to disable column formatting in the collapsed list, you can use the responsiveLayoutCollapseUseFormatters option:`,name:"responsiveLayoutCollapseUseFormatters",required:!1,type:{name:"boolean"}},responsiveLayoutCollapseFormatter:{defaultValue:null,description:`If you set the responsiveLayout option to collapse the values from hidden columns will be displayed in a title/value list under the row.

In this mode an object containing the title of each hidden column and its value is generated and then used to generate a list displayed in a div .tabulator-responsive-collapse under the row data.

The inbuilt collapse formatter creates a table to neatly display the hidden columns. If you would like to format the data in your own way you can use the responsiveLayoutCollapseFormatter, it take an object of the column values as an argument and must return the HTML content of the div.

This function should return an empty string if there is no data to display.`,name:"responsiveLayoutCollapseFormatter",required:!1,type:{name:"((data: any[]) => any)"}},movableColumns:{defaultValue:null,description:"To allow the user to move columns along the table, set the movableColumns parameter in the options:",name:"movableColumns",required:!1,type:{name:"boolean"}},columnHeaderVertAlign:{defaultValue:null,description:"You can use the columnHeaderVertAlign option to set how the text in your column headers should be vertically.",name:"columnHeaderVertAlign",required:!1,type:{name:"enum",value:[{value:'"top"'},{value:'"middle"'},{value:'"bottom"'}]}},scrollToColumnPosition:{defaultValue:null,description:`The default ScrollTo position can be set using the scrollToColumnPosition option. It can take one of three possible values:

left - position column with its left edge at the left of the table (default)
center - position column with its left edge in the center of the table
right - position column with its right edge at the right of the table`,name:"scrollToColumnPosition",required:!1,type:{name:"enum",value:[{value:'"middle"'},{value:'"left"'},{value:'"center"'},{value:'"right"'}]}},scrollToColumnIfVisible:{defaultValue:null,description:`The default option for triggering a ScrollTo on a visible element can be set using the scrollToColumnIfVisible option. It can take a boolean value:

true - scroll to column, even if it is visible (default)
false - scroll to column, unless it is currently visible, then don't move`,name:"scrollToColumnIfVisible",required:!1,type:{name:"boolean"}},columnCalcs:{defaultValue:null,description:`By default column calculations are shown at the top and bottom of the table, unless row grouping is enabled, in which case they are shown at the top and bottom of each group.

The columnCalcs option lets you decided where the calculations should be displayed, it can take one of four values:

true - show calcs at top and bottom of the table, unless grouped, then show in groups (boolean, default)
both - show calcs at top and bottom of the table and show in groups
table - show calcs at top and bottom of the table only
group - show calcs in groups only`,name:"columnCalcs",required:!1,type:{name:'boolean | "both" | "table" | "group"'}},nestedFieldSeparator:{defaultValue:null,description:`If you need to use the . character as part of your field name, you can change the separator to any other character using the nestedFieldSeparator option
Set to false to disable nested data parsing`,name:"nestedFieldSeparator",required:!1,type:{name:"string | boolean"}},columnHeaderSortMulti:{defaultValue:null,description:"multiple or single column sorting",name:"columnHeaderSortMulti",required:!1,type:{name:"boolean"}},columnMoved:{defaultValue:null,description:"The columnMoved callback will be triggered when a column has been successfully moved.",name:"columnMoved",required:!1,type:{name:"((column: ColumnComponent, columns: any[]) => void)"}},columnResized:{defaultValue:null,description:"",name:"columnResized",required:!1,type:{name:"((column: ColumnComponent) => void)"}},columnVisibilityChanged:{defaultValue:null,description:"The columnVisibilityChanged callback is triggered whenever a column changes between hidden and visible states.",name:"columnVisibilityChanged",required:!1,type:{name:"((column: ColumnComponent, visible: boolean) => void)"}},columnTitleChanged:{defaultValue:null,description:"The columnTitleChanged callback is triggered whenever a user edits a column title when the editableTitle parameter has been enabled in the column definition array.",name:"columnTitleChanged",required:!1,type:{name:"((column: ColumnComponent) => void)"}},headerVisible:{defaultValue:null,description:"By setting the headerVisible option to false you can hide the column headers and present the table as a simple list if needed.",name:"headerVisible",required:!1,type:{name:"boolean"}},headerSort:{defaultValue:null,description:"The headerSort option can now be set in the table options to affect all columns as well as in column definitions.",name:"headerSort",required:!1,type:{name:"boolean"}},headerSortElement:{defaultValue:null,description:"",name:"headerSortElement",required:!1,type:{name:'string | ((column: ColumnComponent, dir: "asc" | "desc" | "none") => any)'}},columnDefaults:{defaultValue:null,description:"",name:"columnDefaults",required:!1,type:{name:"Partial<ColumnDefinition>"}},resizableColumnFit:{defaultValue:null,description:"If set to true, then when you resize a column its neighbouring column has the opposite resize applied to keep to total width of columns the same",name:"resizableColumnFit",required:!1,type:{name:"boolean"}},rowFormatter:{defaultValue:null,description:`Tabulator also allows you to define a row level formatter using the rowFormatter option. this lets you alter each row of the table based on the data it contains.
The function accepts one argument, the RowComponent for the row being formatted.`,name:"rowFormatter",required:!1,type:{name:"((row: RowComponent) => any)"}},rowFormatterPrint:{defaultValue:null,description:"When printing you may want to apply a different formatter may want to apply a different formatter from the one usually used to format the row.",name:"rowFormatterPrint",required:!1,type:{name:"false | ((row: RowComponent) => any)"}},rowFormatterHtmlOutput:{defaultValue:null,description:"When the getHtml function is called you may want to apply a different formatter may want to apply a different formatter from the one usually used to format the row",name:"rowFormatterHtmlOutput",required:!1,type:{name:"false | ((row: RowComponent) => any)"}},rowFormatterClipboard:{defaultValue:null,description:"When copying to the clipboard you may want to apply a different formatter may want to apply a different formatter from the one usually used to format the row. You can now do this using the rowFormatterClipboard table option, which takes the same inputs as the standard rowFormatter property. Passing a value of false into the formatter prevent the default row formatter from being run when the table is copied to the clipboard.",name:"rowFormatterClipboard",required:!1,type:{name:"false | ((row: RowComponent) => any)"}},addRowPos:{defaultValue:null,description:'The position in the table for new rows to be added, "bottom" or "top".',name:"addRowPos",required:!1,type:{name:"enum",value:[{value:'"top"'},{value:'"bottom"'}]}},selectable:{defaultValue:null,description:`The selectable option can take one of a several values:
false - selectable rows are disabled
true - selectable rows are enabled, and you can select as many as you want
integer - any integer value, this sets the maximum number of rows that can be selected (when the maximum number of selected rows is exceeded, the first selected row will be deselected to allow the next row to be selected).
"highlight" (default) - rows have the same hover stylings as selectable rows but do not change state when clicked. This is great for when you want to show that a row is clickable but don't want it to be selectable.`,name:"selectable",required:!1,type:{name:'number | boolean | "highlight"'}},selectableRangeMode:{defaultValue:null,description:`By default you can select a range of rows by holding down the shift key and click dragging over a number of rows to toggle the selected state state of all rows the cursor passes over.

If you would prefer to select a range of row by clicking on the first row then holding down shift and clicking on the end row then you can achieve this by setting the selectableRangeMode to click`,name:"selectableRangeMode",required:!1,type:{name:"enum",value:[{value:'"click"'}]}},selectableRollingSelection:{defaultValue:null,description:"By default, row selection works on a rolling basis, if you set the selectable option to a numeric value then when you select past this number of rows, the first row to be selected will be deselected. If you want to disable this behavior and instead prevent selection of new rows once the limit is reached you can set the selectableRollingSelection option to false.",name:"selectableRollingSelection",required:!1,type:{name:"boolean"}},selectablePersistence:{defaultValue:null,description:"By default Tabulator will maintain selected rows when the table is filtered, sorted or paginated (but NOT when the setData function is used). If you want the selected rows to be cleared whenever the table view is updated then set the selectablePersistence option to false.",name:"selectablePersistence",required:!1,type:{name:"boolean"}},selectableCheck:{defaultValue:null,description:"You many want to exclude certain rows from being selected. The selectableCheck options allows you to pass a function to check if the current row should be selectable, returning true will allow row selection, false will result in nothing happening. The function should accept a RowComponent as its first argument.",name:"selectableCheck",required:!1,type:{name:"((row: RowComponent) => boolean)"}},movableRows:{defaultValue:null,description:"To allow the user to move rows up and down the table, set the movableRows parameter in the options:",name:"movableRows",required:!1,type:{name:"boolean"}},movableRowsConnectedTables:{defaultValue:null,description:"Tabulator also allows you to move rows between tables. To enable this you should supply either a valid CSS selector string a DOM node for the table or the Tabulator object for the table to the movableRowsConnectedTables option. if you want to connect to multiple tables then you can pass in an array of values to this option.",name:"movableRowsConnectedTables",required:!1,type:{name:"string | HTMLElement | string[] | HTMLElement[]"}},movableRowsSender:{defaultValue:null,description:`The movableRowsSender option should be set on the sending table, and sets the action that should be taken after the row has been successfully dropped into the receiving table.
There are several inbuilt sender functions:

- false - do nothing(default)
- delete - deletes the row from the table
You can also pass a callback to the movableRowsSender option for custom sender functionality`,name:"movableRowsSender",required:!1,type:{name:'false | "delete" | ((fromRow: RowComponent, toRow: RowComponent, toTable: Tabulator) => any)'}},movableRowsReceiver:{defaultValue:null,description:`The movableRowsReceiver option should be set on the receiving tables, and sets the action that should be taken when the row is dropped into the table.
There are several inbuilt receiver functions:

- insert - inserts row next to the row it was dropped on, if not dropped on a row it is added to the table (default)
- add - adds row to the table
- update - updates the row it is dropped on with the sent rows data
- replace - replaces the row it is dropped on with the sent row`,name:"movableRowsReceiver",required:!1,type:{name:'"insert" | "add" | "update" | "replace" | ((fromRow: RowComponent, toRow: RowComponent, fromTable: Tabulator) => any)'}},movableRowsConnectedElements:{defaultValue:null,description:"",name:"movableRowsConnectedElements",required:!1,type:{name:"string | HTMLElement"}},movableRowsElementDrop:{defaultValue:null,description:"When a row is dropped on element from from the movableRowsConnectedElements option the movableRowsElementDrop callback will be triggered. You can use this callback to trigger any changes as a result of the drop",name:"movableRowsElementDrop",required:!1,type:{name:"((e: MouseEvent, element: HTMLElement, row: RowComponent) => any)"}},scrollToRowPosition:{defaultValue:null,description:`The default ScrollTo position can be set using the scrollToRowPosition option. It can take one of four possible values:

top - position row with its top edge at the top of the table (default)
center - position row with its top edge in the center of the table
bottom - position row with its bottom edge at the bottom of the table
nearest - position row on the edge of the table it is closest to`,name:"scrollToRowPosition",required:!1,type:{name:"enum",value:[{value:'"top"'},{value:'"bottom"'},{value:'"center"'},{value:'"nearest"'}]}},scrollToRowIfVisible:{defaultValue:null,description:`The default option for triggering a ScrollTo on a visible element can be set using the scrollToRowIfVisible option. It can take a boolean value:

true - scroll to row, even if it is visible (default)
false - scroll to row, unless it is currently visible, then don't move`,name:"scrollToRowIfVisible",required:!1,type:{name:"boolean"}},dataTreeRowExpanded:{defaultValue:null,description:"The dataTreeRowExpanded callback is triggered when a row with child rows is expanded to reveal the children.",name:"dataTreeRowExpanded",required:!1,type:{name:"((row: RowComponent, level: number) => void)"}},dataTreeRowCollapsed:{defaultValue:null,description:"The dataTreeRowCollapsed callback is triggered when a row with child rows is collapsed to hide its children.",name:"dataTreeRowCollapsed",required:!1,type:{name:"((row: RowComponent, level: number) => void)"}},movableRowsSendingStart:{defaultValue:null,description:"The movableRowsSendingStart callback is triggered on the sending table when a row is picked up from a sending table.",name:"movableRowsSendingStart",required:!1,type:{name:"((toTables: any[]) => void)"}},movableRowsSent:{defaultValue:null,description:"The movableRowsSent callback is triggered on the sending table when a row has been successfully received by a receiving table.",name:"movableRowsSent",required:!1,type:{name:"((fromRow: RowComponent, toRow: RowComponent, toTable: Tabulator) => void)"}},movableRowsSentFailed:{defaultValue:null,description:"The movableRowsSentFailed callback is triggered on the sending table when a row has failed to be received by the receiving table.",name:"movableRowsSentFailed",required:!1,type:{name:"((fromRow: RowComponent, toRow: RowComponent, toTable: Tabulator) => void)"}},movableRowsSendingStop:{defaultValue:null,description:"The movableRowsSendingStop callback is triggered on the sending table after a row has been dropped and any senders and receivers have been handled.",name:"movableRowsSendingStop",required:!1,type:{name:"((toTables: any[]) => void)"}},movableRowsReceivingStart:{defaultValue:null,description:"The movableRowsReceivingStart callback is triggered on a receiving table when a connection is established with a sending table.",name:"movableRowsReceivingStart",required:!1,type:{name:"((fromRow: RowComponent, toTable: Tabulator) => void)"}},movableRowsReceived:{defaultValue:null,description:"The movableRowsReceived callback is triggered on a receiving table when a row has been successfully received.",name:"movableRowsReceived",required:!1,type:{name:"((fromRow: RowComponent, toRow: RowComponent, fromTable: Tabulator) => void)"}},movableRowsReceivedFailed:{defaultValue:null,description:"The movableRowsReceivedFailed callback is triggered on a receiving table when a row receiver has returned false.",name:"movableRowsReceivedFailed",required:!1,type:{name:"((fromRow: RowComponent, toRow: RowComponent, fromTable: Tabulator) => void)"}},movableRowsReceivingStop:{defaultValue:null,description:"The movableRowsReceivingStop callback is triggered on a receiving table after a row has been dropped and any senders and receivers have been handled.",name:"movableRowsReceivingStop",required:!1,type:{name:"((fromTable: Tabulator) => void)"}},rowClick:{defaultValue:null,description:"The rowClick callback is triggered when a user clicks on a row.",name:"rowClick",required:!1,type:{name:"RowEventCallback"}},rowDblClick:{defaultValue:null,description:"The rowDblClick callback is triggered when a user double clicks on a row.",name:"rowDblClick",required:!1,type:{name:"RowEventCallback"}},rowContext:{defaultValue:null,description:`The rowContext callback is triggered when a user right clicks on a row.
If you want to prevent the browsers context menu being triggered in this event you will need to include the preventDefault() function in your callback.`,name:"rowContext",required:!1,type:{name:"RowEventCallback"}},rowTap:{defaultValue:null,description:"The rowTap callback is triggered when a user taps on a row on a touch display.",name:"rowTap",required:!1,type:{name:"RowEventCallback"}},rowDblTap:{defaultValue:null,description:"The rowDblTap callback is triggered when a user taps on a row on a touch display twice in under 300ms.",name:"rowDblTap",required:!1,type:{name:"RowEventCallback"}},rowTapHold:{defaultValue:null,description:"The rowTapHold callback is triggered when a user taps on a row on a touch display and holds their finger down for over 1 second.",name:"rowTapHold",required:!1,type:{name:"RowEventCallback"}},rowMouseEnter:{defaultValue:null,description:"The rowMouseEnter callback is triggered when the mouse pointer enters a row.",name:"rowMouseEnter",required:!1,type:{name:"RowEventCallback"}},rowMouseLeave:{defaultValue:null,description:"The rowMouseLeave callback is triggered when the mouse pointer leaves a row.",name:"rowMouseLeave",required:!1,type:{name:"RowEventCallback"}},rowMouseOver:{defaultValue:null,description:"The rowMouseOver callback is triggered when the mouse pointer enters a row or any of its child elements.",name:"rowMouseOver",required:!1,type:{name:"RowEventCallback"}},rowMouseOut:{defaultValue:null,description:"The rowMouseOut callback is triggered when the mouse pointer leaves a row or any of its child elements.",name:"rowMouseOut",required:!1,type:{name:"RowEventCallback"}},rowMouseMove:{defaultValue:null,description:"The rowMouseMove callback is triggered when the mouse pointer moves over a row.",name:"rowMouseMove",required:!1,type:{name:"RowEventCallback"}},rowAdded:{defaultValue:null,description:"The rowAdded callback is triggered when a row is added to the table by the addRow and updateOrAddRow functions.",name:"rowAdded",required:!1,type:{name:"RowChangedCallback"}},rowUpdated:{defaultValue:null,description:"The rowUpdated callback is triggered when a row is updated by the updateRow, updateOrAddRow, updateData or updateOrAddData, functions.",name:"rowUpdated",required:!1,type:{name:"RowChangedCallback"}},rowDeleted:{defaultValue:null,description:"The rowDeleted callback is triggered when a row is deleted from the table by the deleteRow function.",name:"rowDeleted",required:!1,type:{name:"RowChangedCallback"}},rowMoved:{defaultValue:null,description:"The rowMoved callback will be triggered when a row has been successfully moved.",name:"rowMoved",required:!1,type:{name:"RowChangedCallback"}},rowResized:{defaultValue:null,description:"The rowResized callback will be triggered when a row has been resized by the user.",name:"rowResized",required:!1,type:{name:"RowChangedCallback"}},rowSelectionChanged:{defaultValue:null,description:"Whenever the number of selected rows changes, through selection or deselection, the rowSelectionChanged event is triggered. This passes an array of the data objects for each row in the order they were selected as the first argument, and an array of row components for each of the rows in order of selection as the second argument.",name:"rowSelectionChanged",required:!1,type:{name:"((data: any[], rows: RowComponent[]) => void)"}},rowSelected:{defaultValue:null,description:"The rowSelected event is triggered when a row is selected, either by the user or programmatically.",name:"rowSelected",required:!1,type:{name:"RowChangedCallback"}},rowDeselected:{defaultValue:null,description:"The rowDeselected event is triggered when a row is deselected, either by the user or programmatically.",name:"rowDeselected",required:!1,type:{name:"RowChangedCallback"}},tabEndNewRow:{defaultValue:null,description:"Allows you to specify the behavior when the user tabs from the last editable cell on the last row of the table.",name:"tabEndNewRow",required:!1,type:{name:"boolean | JSONRecord | ((row: RowComponent) => any)"}},frozenRowsField:{defaultValue:null,description:"",name:"frozenRowsField",required:!1,type:{name:"string"}},frozenRows:{defaultValue:null,description:"Freeze rows of data",name:"frozenRows",required:!1,type:{name:"number | string[] | ((row: RowComponent) => boolean)"}},index:{defaultValue:null,description:"A unique index value should be present for each row of data if you want to be able to programmatically alter that data at a later point, this should be either numeric or a string. By default Tabulator will look for this value in the id field for the data. If you wish to use a different field as the index, set this using the index option parameter.",name:"index",required:!1,type:{name:"string | number"}},importFormat:{defaultValue:null,description:"",name:"importFormat",required:!1,type:{name:'"array" | "csv" | "json" | ((fileContents: string) => unknown[])'}},importReader:{defaultValue:null,description:"By default Tabulator will read in the file as plain text, which is the format used by all the built in importers. If you need to read the file data in a different format then you can use the importReader option to instruct the file reader to read in the file in a different format.",name:"importReader",required:!1,type:{name:"enum",value:[{value:'"binary"'},{value:'"buffer"'},{value:'"text"'},{value:'"url"'}]}},autoTables:{defaultValue:null,description:"",name:"autoTables",required:!1,type:{name:"boolean"}},ajaxParams:{defaultValue:null,description:"Parameters to be passed to remote Ajax data loading request.",name:"ajaxParams",required:!1,type:{name:"{}"}},ajaxConfig:{defaultValue:null,description:"The HTTP request type for Ajax requests or config object for the request.",name:"ajaxConfig",required:!1,type:{name:"HttpMethod | AjaxConfig"}},ajaxContentType:{defaultValue:null,description:`When using a request method other than "GET" Tabulator will send any parameters with a content type of form data. You can change the content type with the ajaxContentType option. This will ensure parameters are sent in the format you expect, with the correct headers. * * The ajaxContentType option can take one of two values:
"form" - send parameters as form data (default option)
"json" - send parameters as JSON encoded string
If you want to use a custom content type then you can pass a content type formatter object into the ajaxContentType option. this object must have two properties, the headers property should contain all headers that should be sent with the request and the body property should contain a function that returns the body content of the request`,name:"ajaxContentType",required:!1,type:{name:'"form" | "json" | AjaxContentType'}},ajaxURLGenerator:{defaultValue:null,description:`If you need more control over the url of the request that you can get from the ajaxURL and ajaxParams properties, the you can use the ajaxURLGenerator property to pass in a callback that will generate the URL for you.

The callback should return a string representing the URL to be requested.`,name:"ajaxURLGenerator",required:!1,type:{name:"((url: string, config: any, params: any) => string)"}},ajaxFiltering:{defaultValue:null,description:"Send filter config to server instead of processing locally",name:"ajaxFiltering",required:!1,type:{name:"boolean"}},ajaxSorting:{defaultValue:null,description:"Send sorter config to server instead of processing locally",name:"ajaxSorting",required:!1,type:{name:"boolean"}},progressiveLoad:{defaultValue:null,description:`If you are loading a lot of data from a remote source into your table in one go, it can sometimes take a long time for the server to return the request, which can slow down the user experience.

To speed things up in this situation Tabulator has a progressive load mode, this uses the pagination module to make a series of requests for part of the data set, one at a time, appending it to the table as the data arrives. This mode can be enable using the ajaxProgressiveLoad option. No pagination controls will be visible on screen, it just reuses the functionality of the pagination module to sequentially load the data.

With this mode enabled, all of the settings outlined in the Ajax Documentation are still available

There are two different progressive loading modes, to give you a choice of how data is loaded into the table.`,name:"progressiveLoad",required:!1,type:{name:"enum",value:[{value:'"load"'},{value:'"scroll"'}]}},progressiveLoadDelay:{defaultValue:null,description:"By default tabulator will make the requests to fill the table as quickly as possible. On some servers these repeats requests from the same client may trigger rate limiting or security systems. In this case you can use the ajaxProgressiveLoadDelay option to add a delay in milliseconds between each page request.",name:"progressiveLoadDelay",required:!1,type:{name:"number"}},progressiveLoadScrollMargin:{defaultValue:null,description:"The ajaxProgressiveLoadScrollMargin property determines how close to the bottom of the table in pixels, the scroll bar must be before the next page worth of data is loaded, by default it is set to twice the height of the table.",name:"progressiveLoadScrollMargin",required:!1,type:{name:"number"}},ajaxLoader:{defaultValue:null,description:"Show loader while data is loading, can also take a function that must return a boolean.",name:"ajaxLoader",required:!1,type:{name:"boolean | (() => boolean)"}},ajaxLoaderLoading:{defaultValue:null,description:"html for loader element.",name:"ajaxLoaderLoading",required:!1,type:{name:"string"}},ajaxLoaderError:{defaultValue:null,description:"html for the loader element in the event of an error.",name:"ajaxLoaderError",required:!1,type:{name:"string"}},ajaxRequesting:{defaultValue:null,description:"The ajaxRequesting callback is triggered when ever an ajax request is made.",name:"ajaxRequesting",required:!1,type:{name:"((url: string, params: any) => boolean)"}},ajaxError:{defaultValue:null,description:"The ajaxError callback is triggered there is an error response to an ajax request.",name:"ajaxError",required:!1,type:{name:"((xhr: any, textStatus: any, errorThrown: any) => void)"}},dataLoader:{defaultValue:null,description:"",name:"dataLoader",required:!1,type:{name:"boolean"}},dataLoaderLoading:{defaultValue:null,description:"",name:"dataLoaderLoading",required:!1,type:{name:"string | HTMLElement"}},dataLoaderError:{defaultValue:null,description:"",name:"dataLoaderError",required:!1,type:{name:"string"}},dataLoaderErrorTimeout:{defaultValue:null,description:"",name:"dataLoaderErrorTimeout",required:!1,type:{name:"number"}},sortMode:{defaultValue:null,description:"",name:"sortMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},filterMode:{defaultValue:null,description:"",name:"filterMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},initialSort:{defaultValue:null,description:"Array of sorters to be applied on load.",name:"initialSort",required:!1,type:{name:"Sorter[]"}},sortOrderReverse:{defaultValue:null,description:"reverse the order that multiple sorters are applied to the table.",name:"sortOrderReverse",required:!1,type:{name:"boolean"}},headerSortClickElement:{defaultValue:null,description:"",name:"headerSortClickElement",required:!1,type:{name:"enum",value:[{value:'"header"'},{value:'"icon"'}]}},initialFilter:{defaultValue:null,description:"Array of filters to be applied on load.",name:"initialFilter",required:!1,type:{name:"Filter[]"}},initialHeaderFilter:{defaultValue:null,description:"array of initial values for header filters.",name:"initialHeaderFilter",required:!1,type:{name:'Pick<Filter, "value" | "field">[]'}},dataFiltering:{defaultValue:null,description:"The dataFiltering callback is triggered whenever a filter event occurs, before the filter happens.",name:"dataFiltering",required:!1,type:{name:"((filters: Filter[]) => void)"}},dataFiltered:{defaultValue:null,description:"The dataFiltered callback is triggered after the table dataset is filtered.",name:"dataFiltered",required:!1,type:{name:"((filters: Filter[], rows: RowComponent[]) => void)"}},headerFilterLiveFilterDelay:{defaultValue:null,description:"When using real time header filtering, Tabulator will wait 300 milliseconds after a keystroke before triggering the filter. You can customize this delay by using the headerFilterLiveFilterDelay table setup option.",name:"headerFilterLiveFilterDelay",required:!1,type:{name:"number"}},groupBy:{defaultValue:null,description:"String/function to select field to group rows by",name:"groupBy",required:!1,type:{name:"GroupArg"}},groupValues:{defaultValue:null,description:`By default Tabulator will create groups for rows based on the values contained in the row data. if you want to explicitly define which field values groups should be created for at each level, you can use the groupValues option.

This option takes an array of value arrays, each item in the first array should be a list of acceptable field values for groups at that level`,name:"groupValues",required:!1,type:{name:"GroupValuesArg"}},groupHeader:{defaultValue:null,description:"You can use the setGroupHeader function to change the header generation function for each group. This function has one argument and takes the same values as passed to the groupHeader setup option.",name:"groupHeader",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},groupHeaderPrint:{defaultValue:null,description:"When printing you may want to apply a different group header from the one usually used in the table. You can now do this using the groupHeaderPrint table option, which takes the same inputs as the standard groupHeader property.",name:"groupHeaderPrint",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},groupStartOpen:{defaultValue:null,description:`You can set the default open state of groups using the groupStartOpen property* * This can take one of three possible values:

true - all groups start open (default value)
false - all groups start closed
function() - a callback to decide if a group should start open or closed
Group Open Function
If you want to decide on a group by group basis which should start open or closed then you can pass a function to the groupStartOpen property. This should return true if the group should start open or false if the group should start closed.`,name:"groupStartOpen",required:!1,type:{name:"boolean | ((value: any, count: number, data: any, group: GroupComponent) => boolean)"}},groupToggleElement:{defaultValue:null,description:`By default Tabulator allows users to toggle a group open or closed by clicking on the arrow icon in the left of the group header. If you would prefer a different behavior you can use the groupToggleElement option to choose a different option:* * The option can take one of three values:
arrow - toggle group on arrow element click
header - toggle group on click anywhere on the group header element
false - prevent clicking anywhere in the group toggling the group`,name:"groupToggleElement",required:!1,type:{name:'false | "header" | "arrow"'}},groupClosedShowCalcs:{defaultValue:null,description:"show/hide column calculations when group is closed.",name:"groupClosedShowCalcs",required:!1,type:{name:"boolean"}},dataGrouping:{defaultValue:null,description:"The dataGrouping callback is triggered whenever a data grouping event occurs, before grouping happens.",name:"dataGrouping",required:!1,type:{name:"(() => void)"}},dataGrouped:{defaultValue:null,description:"The dataGrouping callback is triggered whenever a data grouping event occurs, after grouping happens.",name:"dataGrouped",required:!1,type:{name:"(() => void)"}},groupVisibilityChanged:{defaultValue:null,description:"The groupVisibilityChanged callback is triggered whenever a group changes between hidden and visible states.",name:"groupVisibilityChanged",required:!1,type:{name:"((group: GroupComponent, visible: boolean) => void)"}},groupClick:{defaultValue:null,description:"The groupClick callback is triggered when a user clicks on a group header.",name:"groupClick",required:!1,type:{name:"GroupEventCallback"}},groupDblClick:{defaultValue:null,description:"The groupDblClick callback is triggered when a user double clicks on a group header.",name:"groupDblClick",required:!1,type:{name:"GroupEventCallback"}},groupContext:{defaultValue:null,description:`The groupContext callback is triggered when a user right clicks on a group header.

If you want to prevent the browsers context menu being triggered in this event you will need to include the preventDefault() function in your callback.`,name:"groupContext",required:!1,type:{name:"GroupEventCallback"}},groupTap:{defaultValue:null,description:"The groupTap callback is triggered when a user taps on a group header on a touch display.",name:"groupTap",required:!1,type:{name:"GroupEventCallback"}},groupDblTap:{defaultValue:null,description:"The groupDblTap callback is triggered when a user taps on a group header on a touch display twice in under 300ms.",name:"groupDblTap",required:!1,type:{name:"GroupEventCallback"}},groupTapHold:{defaultValue:null,description:"The groupTapHold callback is triggered when a user taps on a group header on a touch display and holds their finger down for over 1 second.",name:"groupTapHold",required:!1,type:{name:"GroupEventCallback"}},groupUpdateOnCellEdit:{defaultValue:null,description:"",name:"groupUpdateOnCellEdit",required:!1,type:{name:"boolean"}},pagination:{defaultValue:null,description:"",name:"pagination",required:!1,type:{name:"boolean"}},paginationMode:{defaultValue:null,description:"",name:"paginationMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},paginationSize:{defaultValue:null,description:"Set the number of rows in each page.",name:"paginationSize",required:!1,type:{name:"number"}},paginationSizeSelector:{defaultValue:null,description:`Setting this option to true will cause Tabulator to create a list of page size options, that are multiples of the current page size. In the example below, the list will have the values of 5, 10, 15 and 20.

 When using the page size selector like this, if you use the setPageSize function to set the page size to a value not in the list, the list will be regenerated using the new page size as the starting valuer`,name:"paginationSizeSelector",required:!1,type:{name:"true | any[] | number[]"}},paginationElement:{defaultValue:null,description:"By default the pagination controls are added to the footer of the table. If you wish the controls to be created in another element pass a DOM node or a CSS selector for that element to the paginationElement option.",name:"paginationElement",required:!1,type:{name:"string | HTMLElement"}},dataReceiveParams:{defaultValue:null,description:`Lookup list to link expected data fields from the server to their function
\`\`\`typescript
default: {
  "current_page": "current_page",
  "last_page": "last_page",
  "data": "data",
  }
\`\`\``,name:"dataReceiveParams",required:!1,type:{name:"Record<string, string>"}},dataSendParams:{defaultValue:null,description:`Lookup list to link fields expected by the server to their function
\`\`\`typescript
default: {
  "page": "page",
  "size": "size",
  "sorters": "sorters",
  "filters": "filters",
}
\`\`\``,name:"dataSendParams",required:!1,type:{name:"Record<string, string>"}},paginationAddRow:{defaultValue:null,description:`When using the addRow function on a paginated table, rows will be added relative to the current page (ie to the top or bottom of the current page), with overflowing rows being shifted onto the next page.

If you would prefer rows to be added relative to the table (firs/last page) then you can use the paginationAddRow option. it can take one of two values:

page - add rows relative to current page (default)
table - add rows relative to the table`,name:"paginationAddRow",required:!1,type:{name:"enum",value:[{value:'"table"'},{value:'"page"'}]}},paginationCounter:{defaultValue:null,description:`You can choose to display a pagination counter in the bottom left of the footer that shows a summary of the current number of rows shown out of the total.
If you want to have a fully customized counter, then you can pass a function to the paginationCounter option

The formatter function accepts 5 arguments:

pageSize - Number of rows shown per page
currentRow - First visible row position
currentPage - Current page
totalRows - Total rows in table
totalPages - Total pages in table
The function must return the contents of the counter, either the text value of the counter, valid HTML or a DOM node`,name:"paginationCounter",required:!1,type:{name:'"rows" | "pages" | ((pageSize: number, currentRow: number, currentPage: number, totalRows: number, totalPages: number) => string | HTMLElement)'}},paginationCounterElement:{defaultValue:null,description:"By default the counter will be displayed in the left of the table footer. If you would like it displayed in another element pass a DOM node or a CSS selector for that element.",name:"paginationCounterElement",required:!1,type:{name:"string | HTMLElement"}},paginationButtonCount:{defaultValue:null,description:"The number of pagination page buttons shown in the footer using the paginationButtonCount option. By default this has a value of 5.",name:"paginationButtonCount",required:!1,type:{name:"number"}},paginationInitialPage:{defaultValue:null,description:"Specify that a specific page should be loaded when the table first load.",name:"paginationInitialPage",required:!1,type:{name:"number"}},persistenceID:{defaultValue:null,description:"ID tag used to identify persistent storage information.",name:"persistenceID",required:!1,type:{name:"string"}},persistenceMode:{defaultValue:null,description:`Persistence information can either be stored in a cookie or in the localStorage object, you can use the persistenceMode to choose which. It can take three possible values:

 local - (string) Store the persistence information in the localStorage object
 cookie - (string) Store the persistence information in a cookie
 true - (boolean) check if localStorage is available and store persistence information, otherwise store in cookie (Default option)`,name:"persistenceMode",required:!1,type:{name:'true | "local" | "cookie"'}},persistentLayout:{defaultValue:null,description:"Enable persistent storage of column layout information.",name:"persistentLayout",required:!1,type:{name:"boolean"}},persistentSort:{defaultValue:null,description:"You can ensure the data sorting is stored for the next page load by setting the persistentSort option to true.",name:"persistentSort",required:!1,type:{name:"boolean"}},persistentFilter:{defaultValue:null,description:"You can ensure the data filtering is stored for the next page load by setting the persistentFilter option to true.",name:"persistentFilter",required:!1,type:{name:"boolean"}},persistence:{defaultValue:null,description:"By setting the persistence property to true the table will persist the sort, filter, group (groupBy, groupStartOpen, groupHeader), pagination (paginationSize), and column (title, width, visibility, order) configuration of the table.",name:"persistence",required:!1,type:{name:"true | PersistenceOptions"}},persistenceWriterFunc:{defaultValue:null,description:"The persistenceWriterFunc function will receive three arguments, the persistance id of the table, the type of data to be written and an object or array representing the data",name:"persistenceWriterFunc",required:!1,type:{name:"((id: string, type: keyof PersistenceOptions, data: any) => any)"}},persistenceReaderFunc:{defaultValue:null,description:"The persistenceReaderFunc function will receive two arguments, the persistance id of the table, and the type of data to be written. This function must synchronously return the data in the format in which it was passed to the persistenceWriterFunc function. It should return a value of false if no data was present.",name:"persistenceReaderFunc",required:!1,type:{name:"((id: string, type: keyof PersistenceOptions) => any)"}},clipboard:{defaultValue:null,description:`You can enable clipboard functionality using the clipboard config option. It can take one of four possible values:
    true - enable clipboard copy and paste
    "copy" - enable only copy functionality
    "paste" - enable only paste functionality
    false - disable all clipboard functionality (default)`,name:"clipboard",required:!1,type:{name:'boolean | "copy" | "paste"'}},clipboardCopyRowRange:{defaultValue:null,description:"The clipboardCopyRowRange option takes a Row Range Lookup value and allows you to choose which rows are included in the clipboard output:",name:"clipboardCopyRowRange",required:!1,type:{name:"enum",value:[{value:'"visible"'},{value:'"active"'},{value:'"selected"'},{value:'"all"'}]}},clipboardCopyFormatter:{defaultValue:null,description:'You can alter the finished output to the clipboard using the clipboardCopyFormatter callback. The callback function receives two arguments, the first is a string representing the type of content to be formatted (either "plain" or "html" depending on the type of data entering the clipboard). The second argument is the string that is about to be inserted into the clipboard. The function and should return a string that will be inserted into the clipboard.',name:"clipboardCopyFormatter",required:!1,type:{name:'"table" | ((type: "plain" | "html", output: string) => string)'}},clipboardCopyHeader:{defaultValue:null,description:"By default Tabulator will include the column header titles in any clipboard data, this can be turned off by passing a value of false to the clipboardCopyHeader property:",name:"clipboardCopyHeader",required:!1,type:{name:"boolean"}},clipboardPasteParser:{defaultValue:null,description:`Tabulator has one built in paste parser, that is designed to take a table formatted text string from the clipboard and turn it into row data. it breaks the data into rows on a newline character \\n and breaks the rows down to columns on a tab character \\t.
It will then attempt to work out which columns in the data correspond to columns in the table. It tries three different ways to achieve this. First it checks the values of all columns in the first row of data to see if they match the titles of columns in the table. If any of the columns don't match it then tries the same approach but with the column fields. If either of those options match, Tabulator will map those columns to the incoming data and import it into rows. If there is no match then Tabulator will assume the columns in the data are in the same order as the visible columns in the table and import them that way.

The inbuilt parser will reject any clipboard data that does not contain at least one row and two columns, in that case the clipboardPasteError will be triggered.

If you extend the clipboard module to add your own parser, you can set it to be used as default with the clipboardPasteParser property.`,name:"clipboardPasteParser",required:!1,type:{name:"string | ((clipboard: any) => any[])"}},clipboardPasteAction:{defaultValue:null,description:`Once the data has been parsed into row data, it will be passed to a paste action to be added to the table. There are three inbuilt paste actions:

insert - Inserts data into the table using the addRows function (default)
update - Updates data in the table using the updateOrAddData function
replace - replaces all data in the table using the setData function`,name:"clipboardPasteAction",required:!1,type:{name:"enum",value:[{value:'"insert"'},{value:'"update"'},{value:'"replace"'}]}},clipboardCopyStyled:{defaultValue:null,description:`By default Tabulator will copy some of the tables styling along with the data to give a better visual appearance when pasted into other documents.

If you want to only copy the un-styled data then you should set the clipboardCopyStyled option to false in the table options object:`,name:"clipboardCopyStyled",required:!1,type:{name:"boolean"}},clipboardCopyConfig:{defaultValue:null,description:`By default Tabulator includes column headers, row groups and column calculations in the clipboard output.

You can choose to remove column headers groups, row groups or column calculations from the output data by setting the values in the clipboardCopyConfig option in the table definition:`,name:"clipboardCopyConfig",required:!1,type:{name:"boolean | AdditionalExportOptions"}},clipboardCopied:{defaultValue:null,description:"The clipboardCopied event is triggered whenever data is copied to the clipboard.",name:"clipboardCopied",required:!1,type:{name:"(() => void)"}},clipboardPasted:{defaultValue:null,description:"The clipboardPasted event is triggered whenever data is successfully pasted into the table.",name:"clipboardPasted",required:!1,type:{name:"(() => void)"}},clipboardPasteError:{defaultValue:null,description:"The clipboardPasteError event is triggered whenever an attempt to paste data into the table has failed because it was rejected by the paste parser.",name:"clipboardPasteError",required:!1,type:{name:"(() => void)"}},groupHeaderClipboard:{defaultValue:null,description:"When copying to clipboard you may want to apply a different group header from the one usually used in the table. You can now do this using the groupHeaderClipboard table option, which takes the same inputs as the standard groupHeader property.",name:"groupHeaderClipboard",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},groupHeaderHtmlOutput:{defaultValue:null,description:"When the getHtml function is called you may want to apply a different group header from the one usually used in the table. You can now do this using the groupHeaderHtmlOutput table option, which takes the same inputs as the standard groupHeader property.",name:"groupHeaderHtmlOutput",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},dataTree:{defaultValue:null,description:"To enable data trees in your table, set the dataTree property to true in your table constructor:",name:"dataTree",required:!1,type:{name:"boolean"}},dataTreeElementColumn:{defaultValue:null,description:"By default the toggle element will be inserted into the first column on the table. If you want the toggle element to be inserted in a different column you can pass the field name of the column to the dataTreeElementColumn setup option.",name:"dataTreeElementColumn",required:!1,type:{name:"string | boolean"}},dataTreeBranchElement:{defaultValue:null,description:"Show tree branch icon.",name:"dataTreeBranchElement",required:!1,type:{name:"string | boolean"}},dataTreeChildIndent:{defaultValue:null,description:"Tree level indent in pixels",name:"dataTreeChildIndent",required:!1,type:{name:"number"}},dataTreeChildField:{defaultValue:null,description:"By default Tabulator will look for child rows in the _children field of a row data object. You can change this to look in a different field using the dataTreeChildField property in your table constructor:",name:"dataTreeChildField",required:!1,type:{name:"string"}},dataTreeCollapseElement:{defaultValue:null,description:`The toggle button that allows users to collapse and expand the column can be customized to meet your needs. There are two options, dataTreeExpandElement and dataTreeCollapseElement, that can be set to replace the default toggle elements with your own.

Both options can take either an html string representing the contents of the toggle element`,name:"dataTreeCollapseElement",required:!1,type:{name:"string | boolean | HTMLElement"}},dataTreeExpandElement:{defaultValue:null,description:"The toggle button that allows users to expand the column.",name:"dataTreeExpandElement",required:!1,type:{name:"string | boolean | HTMLElement"}},dataTreeStartExpanded:{defaultValue:null,description:`By default all nodes on the tree will start collapsed, you can customize the initial expansion state of the tree using the dataTreeStartExpanded option.*
This option can take one of three possible value types, either a boolean to indicate whether all nodes should start expanded or collapsed:`,name:"dataTreeStartExpanded",required:!1,type:{name:"boolean | boolean[] | ((row: RowComponent, level: number) => boolean)"}},dataTreeSelectPropagate:{defaultValue:null,description:"Propagate selection events from parent rows to children.",name:"dataTreeSelectPropagate",required:!1,type:{name:"boolean"}},dataTreeFilter:{defaultValue:null,description:"",name:"dataTreeFilter",required:!1,type:{name:"boolean"}},dataTreeSort:{defaultValue:null,description:"",name:"dataTreeSort",required:!1,type:{name:"boolean"}},dataTreeChildColumnCalcs:{defaultValue:null,description:`When you are using the dataTree option with your table, the column calculations will by default only use the data for the top level rows and will ignore any children.
To include child rows in the column calculations set the dataTreeChildColumnCalcs option to true in the table constructor.`,name:"dataTreeChildColumnCalcs",required:!1,type:{name:"boolean"}},cellClick:{defaultValue:null,description:"The cellClick callback is triggered when a user left clicks on a cell, it can be set on a per column basis using the option in the columns definition object.",name:"cellClick",required:!1,type:{name:"CellEventCallback"}},cellDblClick:{defaultValue:null,description:"",name:"cellDblClick",required:!1,type:{name:"CellEventCallback"}},cellContext:{defaultValue:null,description:"",name:"cellContext",required:!1,type:{name:"CellEventCallback"}},cellTap:{defaultValue:null,description:"",name:"cellTap",required:!1,type:{name:"CellEventCallback"}},cellDblTap:{defaultValue:null,description:"",name:"cellDblTap",required:!1,type:{name:"CellEventCallback"}},cellTapHold:{defaultValue:null,description:"",name:"cellTapHold",required:!1,type:{name:"CellEventCallback"}},cellMouseEnter:{defaultValue:null,description:"",name:"cellMouseEnter",required:!1,type:{name:"CellEventCallback"}},cellMouseLeave:{defaultValue:null,description:"",name:"cellMouseLeave",required:!1,type:{name:"CellEventCallback"}},cellMouseOver:{defaultValue:null,description:"",name:"cellMouseOver",required:!1,type:{name:"CellEventCallback"}},cellMouseOut:{defaultValue:null,description:"",name:"cellMouseOut",required:!1,type:{name:"CellEventCallback"}},cellMouseMove:{defaultValue:null,description:"",name:"cellMouseMove",required:!1,type:{name:"CellEventCallback"}},cellEditing:{defaultValue:null,description:"",name:"cellEditing",required:!1,type:{name:"CellEditEventCallback"}},cellEdited:{defaultValue:null,description:"",name:"cellEdited",required:!1,type:{name:"CellEditEventCallback"}},cellEditCancelled:{defaultValue:null,description:"",name:"cellEditCancelled",required:!1,type:{name:"CellEditEventCallback"}},validationFailed:{defaultValue:null,description:"The validationFailed event is triggered when the value entered into a cell during an edit fails to pass validation.",name:"validationFailed",required:!1,type:{name:"((cell: CellComponent, value: any, validators: Validator[] | StandardValidatorType[]) => void)"}},cellMouseDown:{defaultValue:null,description:"",name:"cellMouseDown",required:!1,type:{name:"CellEventCallback"}},cellMouseUp:{defaultValue:null,description:"",name:"cellMouseUp",required:!1,type:{name:"CellEventCallback"}},invalidOptionWarning:{defaultValue:null,description:"",name:"invalidOptionWarning",required:!1,type:{name:"boolean"}},debugInvalidOptions:{defaultValue:null,description:"Enabled by default this will provide a console warning if you are trying to set an option on the table that does not exist. With the new optional modular structure this is particularly valuable as it will prompt you if you are trying to use an option for a module that has not been installed",name:"debugInvalidOptions",required:!1,type:{name:"boolean"}},debugInitialization:{defaultValue:null,description:"Enabled by default this will provide a console warning if you try and call a function on the table before it has been initialized.",name:"debugInitialization",required:!1,type:{name:"boolean"}},debugEventsExternal:{defaultValue:null,description:"The debugEventsExternal option will create a console log for every external event that is fired so you can gain an understanding of which events you should be binding to.",name:"debugEventsExternal",required:!1,type:{name:"boolean"}},debugEventsInternal:{defaultValue:null,description:"The debugEventsInternal option will create a console log for every internal event that is fired so you can gain an understanding of which events you should be subscribing to in your modules.",name:"debugEventsInternal",required:!1,type:{name:"boolean"}},debugInvalidComponentFuncs:{defaultValue:null,description:"Disable component function warnings",name:"debugInvalidComponentFuncs",required:!1,type:{name:"boolean"}},debugDeprecation:{defaultValue:null,description:"Disable deprecation warnings",name:"debugDeprecation",required:!1,type:{name:"boolean"}},htmlOutputConfig:{defaultValue:null,description:"",name:"htmlOutputConfig",required:!1,type:{name:"AdditionalExportOptions"}},printAsHtml:{defaultValue:null,description:`By Default when a page is printed that includes a Tabulator it will be rendered on the page exactly as the table is drawn. While this ise useful in most cases, some users prefer to have more control over the print output, for example showing all rows of the table, instead of just those visible with the current position of the scroll bar.

Tabulator provides a print styling mode that will replace the Tabulator with an HTML table for the printout giving you much more control over the look and feel of the table for the print out., to enable this mode, set the printAsHtml option to true in the table constructor.

This will replace the table (in print outs only) with a simple HTML table with the class tabulator-print-table that you can use to style the table in any way you like.

It also has the benefit that because it is an HTML table, if it causes a page break your browser will automatically add the column headers in at the top of the next page.`,name:"printAsHtml",required:!1,type:{name:"boolean"}},printConfig:{defaultValue:null,description:`The HTML table will contain column header groups, row groups, and column calculations.

You can choose to remove any of these from the output data by setting the values in the printConfig option in the table definition`,name:"printConfig",required:!1,type:{name:"AdditionalExportOptions"}},printStyled:{defaultValue:null,description:"If you want your printed table to be styled to match your Tabulator you can set the printCopyStyle to true, this will copy key layout styling to the printed table.",name:"printStyled",required:!1,type:{name:"boolean"}},printRowRange:{defaultValue:null,description:"By default, only the rows currently visible in the Tabulator will be added to the HTML table. For custom row ranges it is also possible to pass a function into the printRowRange option that should return an array of Row Components",name:"printRowRange",required:!1,type:{name:"RowRangeLookup | (() => RowComponent[])"}},printHeader:{defaultValue:null,description:"You can use the printHeader table setup option to define a header to be displayed when the table is printed.",name:"printHeader",required:!1,type:{name:"StandardStringParam"}},printFooter:{defaultValue:null,description:"You can use the printFooter table setup option to define a footer to be displayed when the table is printed.",name:"printFooter",required:!1,type:{name:"StandardStringParam"}},printFormatter:{defaultValue:null,description:"The printFormatter table setup option allows you to carry out any manipulation of the print output before it is displayed to the user for printing.",name:"printFormatter",required:!1,type:{name:"((tableHolderElement: any, tableElement: any) => any)"}},groupHeaderDownload:{defaultValue:null,description:"",name:"groupHeaderDownload",required:!1,type:{name:"((value: any, count: number, data: any, group: GroupComponent) => string) | ((value: any, count: number, data: any) => string)[]"}},dataTreeParentField:{defaultValue:null,description:"The parent key field name",name:"dataTreeParentField",required:!1,type:{name:"string | number"}},showHeaderFilter:{defaultValue:null,description:"Hide HeaderFilter when grid is initialized",name:"showHeaderFilter",required:!1,type:{name:"boolean"}},selectionMode:{defaultValue:null,description:"if true, use native tabulator selections rules without using active selection module",name:"selectionMode",required:!1,type:{name:"boolean"}},multiSelect:{defaultValue:null,description:"Allow multi select rows (default true)",name:"multiSelect",required:!1,type:{name:"boolean"}},onTableRef:{defaultValue:null,description:"On the tableRef ready callback",name:"onTableRef",required:!1,type:{name:"((ref: MutableRefObject<ITabulator>) => void)"}},events:{defaultValue:null,description:"Grid events",name:"events",required:!1,type:{name:"(Partial<EventCallBackMethods> & IActiveSelectionModuleTableEvents)"}},containerClassName:{defaultValue:null,description:"Grid container class name",name:"containerClassName",required:!1,type:{name:"string"}},allowTextSelection:{defaultValue:null,description:"by default user text selection is disabled (CSS user-select='none')",name:"allowTextSelection",required:!1,type:{name:"boolean"}},updateColumnDefinition:{defaultValue:null,description:"",name:"updateColumnDefinition",required:!1,type:{name:"((column: ColumnLookup, definition: Partial<ColumnDefinition>) => Promise<void>)"}},apiRef:{defaultValue:null,description:"A mutable object to merge with these controls api",name:"apiRef",required:!1,type:{name:"unknown"}},gridMode:{defaultValue:null,description:"Grid mode: local or remote",name:"gridMode",required:!1,type:{name:"enum",value:[{value:'"remote"'},{value:'"local"'}]}},dataSet:{defaultValue:null,description:"Grid data set",name:"dataSet",required:!1,type:{name:"IGridRowData[]"}},headerLabel:{defaultValue:null,description:"Grid label in header buttons row",name:"headerLabel",required:!1,type:{name:"ReactNode"}},buttons:{defaultValue:null,description:"Grid header buttons",name:"buttons",required:!1,type:{name:'Record<"delete" | "update" | "view" | "create" | "clone" | "select" | "filterToggle" | "system", IFormButton | null> | IFormButtons'}},buttonsSize:{defaultValue:null,description:"Grid header buttons size. Default: 'small'",name:"buttonsSize",required:!1,type:{name:"enum",value:[{value:'"middle"'},{value:'"large"'},{value:'"small"'}]}},buttonsIconsOnly:{defaultValue:null,description:"If true, only button icons will be displayed, without title",name:"buttonsIconsOnly",required:!1,type:{name:"boolean"}},buttonsPosition:{defaultValue:null,description:"Grid header buttons size. Default: 'right'",name:"buttonsPosition",required:!1,type:{name:"enum",value:[{value:'"left"'},{value:'"center"'},{value:'"right"'}]}},editFormProps:{defaultValue:null,description:"Edit DFormModal parameters",name:"editFormProps",required:!1,type:{name:"IDFormModalProps"}},selectionFormProps:{defaultValue:null,description:"Selection DFormModal parameters",name:"selectionFormProps",required:!1,type:{name:"IDFormModalProps"}},appendSelection:{defaultValue:null,description:"Append row selection when using selectionFormProps (by default, the dataSet is replaced with the selected rows. This option allows you to change this behavior)",name:"appendSelection",required:!1,type:{name:"boolean"}},noHover:{defaultValue:null,description:"Disable row hover effect",name:"noHover",required:!1,type:{name:"boolean"}},rowDeleteMessage:{defaultValue:null,description:"Confirm message before rows delete",name:"rowDeleteMessage",required:!1,type:{name:"ReactNode"}},confirmDelete:{defaultValue:null,description:"Should confirm before delete",name:"confirmDelete",required:!1,type:{name:"boolean"}},resizeHeightWithParent:{defaultValue:null,description:"Selector of parent container (.className or #id). Tabulator Grid will resize height on container height change",name:"resizeHeightWithParent",required:!1,type:{name:"string"}}}}}catch{}const Ge={title:"DForm/Fields/TabulatorGrid",component:G,tags:["autodocs"],parameters:{docs:{source:{language:"tsx",format:!0,code:`
                    import React from "react";
                    import {DForm} from @krinopotam/ui-kit/dForm";
                    import {IDFormFieldProps} from @krinopotam/ui-kit/dForm";
                    import {InputField} from @krinopotam/ui-kit/dForm/fields/input/inputField";
                    type IComponent = IDFormFieldProps
                    /** DForm Input component */
                    export const InputComponent = (props: IComponent): React.JSX.Element => <DForm
                        buttons={null}
                        fieldsProps={
                            {field1: {...props, component: InputField}}
                        }
                    />
                    export default InputComponent
                `}}}},e={value:x,columns:H,columnDefaults:{resizable:"header",headerFilter:!0,headerFilterFunc:"like"},height:500,layout:"fitColumns",movableColumns:!0},n={args:{...e}},l={args:{...e,showHeaderFilter:!0,footerElement:d.jsx("div",{children:"My Footer"})}},o={args:{...e,dataTree:!0}},r={args:{...e,footerElement:d.jsx("div",{children:"My Footer"})}},i={args:{...e,height:void 0,pagination:!0,paginationMode:"local",paginationSize:10,paginationSizeSelector:[5,10,50,100],paginationCounter:"rows"}},s={args:{...e,data:void 0,height:void 0,pagination:!0,paginationSize:5,paginationSizeSelector:[5,10,50,100],paginationCounter:"rows",paginationMode:"remote",filterMode:"remote",sortMode:"remote",ajaxURL:"-",ajaxRequestFunc:(a,j,t)=>new Promise(E=>{setTimeout(()=>{const D=x.slice((t.page-1)*t.size,t.page*t.size);E({data:D,last_page:4})},1e3)}),ajaxParams:{key1:"value1",key2:"value2"}}};var p,c,h;n.parameters={...n.parameters,docs:{...(p=n.parameters)==null?void 0:p.docs,source:{originalSource:`{
  args: {
    ...baseArgs
  }
}`,...(h=(c=n.parameters)==null?void 0:c.docs)==null?void 0:h.source}}};var m,f,b;l.parameters={...l.parameters,docs:{...(m=l.parameters)==null?void 0:m.docs,source:{originalSource:`{
  args: {
    ...baseArgs,
    showHeaderFilter: true,
    footerElement: <div>My Footer</div>
  }
}`,...(b=(f=l.parameters)==null?void 0:f.docs)==null?void 0:b.source}}};var g,y,w;o.parameters={...o.parameters,docs:{...(g=o.parameters)==null?void 0:g.docs,source:{originalSource:`{
  args: {
    ...baseArgs,
    dataTree: true
  }
}`,...(w=(y=o.parameters)==null?void 0:y.docs)==null?void 0:w.source}}};var v,C,T;r.parameters={...r.parameters,docs:{...(v=r.parameters)==null?void 0:v.docs,source:{originalSource:`{
  args: {
    ...baseArgs,
    footerElement: <div>My Footer</div>
  }
}`,...(T=(C=r.parameters)==null?void 0:C.docs)==null?void 0:T.source}}};var V,q,R;i.parameters={...i.parameters,docs:{...(V=i.parameters)==null?void 0:V.docs,source:{originalSource:`{
  args: {
    ...baseArgs,
    height: undefined,
    pagination: true,
    paginationMode: 'local',
    paginationSize: 10,
    paginationSizeSelector: [5, 10, 50, 100],
    paginationCounter: "rows"
  }
}`,...(R=(q=i.parameters)==null?void 0:q.docs)==null?void 0:R.source}}};var k,S,F;s.parameters={...s.parameters,docs:{...(k=s.parameters)==null?void 0:k.docs,source:{originalSource:`{
  args: {
    ...baseArgs,
    data: undefined,
    height: undefined,
    pagination: true,
    paginationSize: 5,
    paginationSizeSelector: [5, 10, 50, 100],
    paginationCounter: "rows",
    paginationMode: 'remote',
    filterMode: "remote",
    sortMode: 'remote',
    ajaxURL: '-',
    //ajax URL. Workaround: if you need to use your own fetcher (for example Axios), then you must specify any non-empty string
    ajaxRequestFunc: (url, config, params) => {
      return new Promise(resolve => {
        setTimeout(() => {
          //make any remote fetch
          const dataSet = TabulatorTreeDataset.slice((params.page - 1) * params.size, params.page * params.size); //remote fetch imitation
          resolve({
            data: dataSet,
            last_page: 4
          });
        }, 1000);
      });
    },
    ajaxParams: {
      key1: "value1",
      key2: "value2"
    } //any additional params (you can pass a callback)
  }
}`,...(F=(S=s.parameters)==null?void 0:S.docs)==null?void 0:F.source}}};const je=["Simple","WithHeaderFilter","Tree","WithFooter","PaginationLocal","PaginationRemote"];export{i as PaginationLocal,s as PaginationRemote,n as Simple,o as Tree,r as WithFooter,l as WithHeaderFilter,je as __namedExportsOrder,Ge as default};
//# sourceMappingURL=tabulatorGridComponent.stories-61c635b5.js.map
